{"/about/":{"data":{"":"这是我的个人网站，使用 Hextra 搭建，感谢开源作者的贡献"},"title":"关于"},"/blog/":{"data":{"":"平时会从自己的CSDN、稀土掘金搬一些文章，但应该不会有网站独家博客\nB站：小狄同学呀\nGithub：xiaoditx\nACfun：小狄同学呀\nCSDN、稀土掘金：小狄同学呀"},"title":"小狄同学呀の博客"},"/blog/2025-08-26_%E7%AE%97%E6%B3%95%E7%9C%9F%E9%A2%98gesp202503%E5%9B%9B%E7%BA%A7%E8%8D%92%E5%9C%B0%E5%BC%80%E5%9E%A6%E6%B4%9B%E8%B0%B7b4263/":{"data":{"1分析题目#1.分析题目":"题目说，上下左右四个方向相邻的格子均不存在杂物的荒地才可以开垦，用这个思路想似乎是很难的，但换一个思路或许会容易些，我们假设下面这片$3×3$的荒地：\n...\r.#.\r... 此时中心出现杂物，由于可开垦的荒地上下左右均不能有杂物，因此这一个杂物影响了它上下左右的荒地，我们用!表示无杂物但不可开垦的荒地：\n.!.\r!#!\r.!. 也就是说，我们判断荒地是否不可开垦的思路转换为了找杂物，下面的，就是代码内容了。","2数据读入和初步处理#2.数据读入和初步处理":"","3当前可开垦的数目统计#3.当前可开垦的数目统计":"我们这里的思路是：既然只能除掉一个，那我们就先算一算不除掉能开垦多少，再找找除掉后能够空出地盘最多的杂物，由此，就需要先统计当前可开垦数目：\nint ans=0;//初始化一个为0的ans变量，用于存储最后输出 //下面的循环，读imap数组，数“0”的个数 for(int c=0;c\u003cn;c++){ for(int vc=0;vc\u003cm;vc++){ //标准的循环遍历 if(imap[vc][c]==0){//当前格子为0 ans++;//ans用来记录可开垦格子数，0为可开垦，记录为+1 } } } 显然，当前的状态是好判断的，只要为0，就说明可开垦，这是我们前面量化的数值，那么只要发现0就给ans变量加上一就行，循环一次后，imap中0的数量就存到ans里了。","4最优解查找#4.最优解查找":"这是我们就只差找到移除的最优解了，这里最简单的方法就是枚举object了，但我那个同学貌似是把记录的位置依次变成.然后分析可开垦数，多少有些低效了（也许我理解错他的意思了？总之这个方法很慢），实际上这个东西只要按照偏移读取就好。\n当一个杂物被移走的时候，按照定义，周围的格子数值都应该减1，其所在的位置则是变为正数然后减一，则我们可以知道只要其所在的格子是-1时，移走可开垦；只有其周围格子为1时，一走可开垦，由此，得出以下代码：\nint area,best=0;//两个变量来算杂物去除后变为可开垦的荒地数 for(int c=0;c\u003crecord_c;c++){ area=0;//area只是临时变量，每次循环初始化为0 //事实上，这里写int area;似乎更好 for(int vc=0;vc\u003c4;vc++){//四次偏移 int tx=px[vc]+object[c][0],ty=py[vc]+object[c][1];//计算XY if((tx\u003e=0) //边界检测，同前 \u0026\u0026 (tx\u003cm) \u0026\u0026 (ty\u003e=0) \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]==1){//如果为1，则证明只被当前杂物影响，移除该杂物就能开垦了 area++;//可开垦荒地数+1 } } } if(imap[object[c][0]][object[c][1]]==-1){//看看这个杂物有没有在别的杂物的影响范围内 area++;//不在的话再加一 } if(best\u003carea)best=area; if(best==5)break;//最大值是五，不可能在大了（自身+四个偏移），直接break节省时间 } 通过所谓“打擂台”的方式选出最优方案，由于自身加上偏移也就最多五个点，因此当best为5时就可以break了，毕竟已经没用方案能够更优了，这么做可以节省时间，在竞赛中，即使不这么做也能AC，仅仅几行就能做的简单优化也依旧是必须的，毕竟C++的观念就是效率至上。","5输出#5.输出":"由于最优解只看-1和1，这些可开垦荒地都是相对未移除杂物时新增的，直接将ans和best简单的相加即可的到最后结果\nans+=best;//ans加上挪出杂物腾出来的空间 std::cout\u003c\u003cans;//输出答案","一开始之前#一.开始之前":"一.开始之前同学去考了GESP，回来给我说他有一题TLE了，顺手把题目写给我了，当时看完有点思路，用易语言写了一下，结果越写越乱就放弃了，这周上课有些无聊，闲着也是闲着，干脆又把这题拾起来做了，回家试了试又改了改，顺利AC。\n原题是这样的：\n小杨有一大片荒地，可以表示为一个 \\(n\\) 行 \\(m\\) 列的网格图。\r小杨想要开垦这块荒地，但荒地中一些位置存在杂物，对于一块不存在杂物的荒地，该荒地可以开垦当且仅当其上下左右四个方向相邻的格子均不存在杂物。\r小杨可以选择至多一个位置，清除该位置的杂物，移除杂物后该位置变为荒地。小杨想知道在清除至多一个位置的杂物的情况下，最多能够开垦多少块荒地。 输入输出什么的直接看洛谷吧，我就不一一粘过来了：洛谷B4263","三解析#三.解析":"","二代码#二.代码":"虽然我是写出来了，但我毕竟不是专业学算法的，所以我也不知道什么时间复杂度空间复杂度的，更不知道我用的算法叫什么，我只知道我AC了，每次大抵是在7-25ms通过测试点（如下）\n下面是我的代码，这个是带注释的版本，但大概也会被我某些地方原因不明的写法迷惑住，如果看不懂可以直接看解析，会有几乎逐行的解读：\n#include #include int main(){ int m,n,record_c=0;//长宽与杂物数记录变量 char tmp;//其实想用string的来着 int px[4]={0,0,1,-1},py[4]={1,-1,0,0};//杂物的不可开垦偏移 std::cin\u003e\u003en\u003e\u003em;//读入长宽(处于设计原因，被逼无奈反着读了) int imap[m][n];//创建地图数组（二维） int object[m*n][2];//杂物坐标记录数组 memset(imap,0,sizeof(imap));//初始化地图为0（即默认无杂物可开垦） for(int c=0;c\u003cn;c++){//循环读入内容 for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;//暂时读入tmp if(tmp=='#'){//判断是否为#（杂物） imap[vc][c]=-1-imap[vc][c];//是杂物则以负数记录叠加 object[record_c][0]=vc;//记录杂物位置，减少后期工作量，节约时间 object[record_c][1]=c; record_c++;//把记录的变量+1 for(int dev_c=0;dev_c\u003c4;dev_c++){//四次计算偏移后的坐标并判断 int tx=px[dev_c]+vc,ty=py[dev_c]+c;//偏移后的X、Y /*边界判断，防止操作数组时超界 实际上，如果你觉得if严重影响执行效率，可以考虑定制化的边界判断，先操作边界再操作内部 这样会有更高的效率，但同样意味着你需要写更多的代码 */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) //这两行是对X的判断 \u0026\u0026 (ty\u003e=0) //下面两行是对Y的判断 \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){//对于“是否为杂物”进行判断 imap[tx][ty]++;//\u003e-1不为杂物，以++方式计录影响 }else{//\u003c=-1的情况 imap[tx][ty]--; } } } } } } //读入完成，感受人机缩进的力量吧 //（实则如果看的不舒服你完全可以用goto解决一下，但是不推荐） //下面是调试时使用的代码，在注释里保留了一下 // for(int c=0;c","写地图#写地图":"for(int c=0;c\u003cn;c++){//循环读入内容 for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;//暂时读入tmp if(tmp=='#'){//判断是否为#（杂物） imap[vc][c]=-1-imap[vc][c];//是杂物则以负数记录叠加 object[record_c][0]=vc;//记录杂物位置，减少后期工作量，节约时间 object[record_c][1]=c; record_c++;//把记录的变量+1 for(int dev_c=0;dev_c\u003c4;dev_c++){//四次计算偏移后的坐标并判断 int tx=px[dev_c]+vc,ty=py[dev_c]+c;//偏移后的X、Y /*边界判断，防止操作数组时超界 实际上，如果你觉得if严重影响执行效率，可以考虑定制化的边界判断，先操作边界再操作内部 这样会有更高的效率，但同样意味着你需要写更多的代码 */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) //这两行是对X的判断 \u0026\u0026 (ty\u003e=0) //下面两行是对Y的判断 \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){//对于“是否为杂物”进行判断 imap[tx][ty]++;//\u003e-1不为杂物，以++方式计录影响 }else{//\u003c=-1的情况 imap[tx][ty]--; } } } } } } （请不要在意我诸如c、dev_c之类的奇怪的变量名，我只是想写出c++这样的语句）\n我们使用一个很简单的循环逐个字符的读入，由于我们已经将地图初始化为了可开垦，所以督读到.大抵可以直接丢弃，只有#对我们才是重要的，我们将其记录入imap和object\n记录入imap的操作是这样的：-1-当前格内容，如果原本是0，那么现在就是-1，原本是1，现在就是-2，可以回看量化每个位置的信息那段，看看是不是对上了。\n写入完毕后，做四次循环，分别对应px和py数组的四次偏移，依次计算影响：非杂物块加上一，杂物块减去一。\n计算偏移时需要注意一点，偏移后的结果有几率超出数组范围，这个时候就不应该对这个不存在的坐标操作了，所以要加个if对于是否超界进行判断。","准备地图#准备“地图”":"想要解题，肯定得先接住题目给的数据，连数据都接不好还怎么分析，于是先写下接收前两个数据的代码，顺手为后面的事做准备：\n#include #include int main(){ int m,n,record_c=0;//长宽与杂物数记录变量 char tmp;//其实想用string的来着 int px[4]={0,0,1,-1},py[4]={1,-1,0,0};//杂物的不可开垦偏移 std::cin\u003e\u003en\u003e\u003em;//读入长宽(处于设计原因，被逼无奈反着读了) int imap[m][n];//创建地图数组（二维） int object[m*n][2];//杂物坐标记录数组 memset(imap,0,sizeof(imap));//初始化地图为0（即默认无杂物可开垦） } 这里用到了两个头文件，iostream和cstring，一个几乎是必需品，一个则是初始化数组用的。\n这里可能有人会说：诶？using namespace std怎么被你吞了？\n实际上，只要你勤加std::就可以不写这句话，这样做当然是有好处的，虽然在算法竞赛里不容易体现出来，不过我毕竟是个侧重应用的人（毕竟一上来就学的易语言），所以一直注重少用using的习惯，有关这个东西，大家可以搜一下“命名空间污染”自行了解。\n这里定义了整型变量m、n、record_c分别负责：接受输入n、接受输入m、存储杂物数量（这里是由于写的瑕疵，m和n用反了，结果发现不好改，最后只能做出用m接n这种举动了）；一个char型的变量tmp，也就是接受后面.和#输入的变量。\n代码中的px和py实际上是“偏移数组”，实际使用中，去一个数字，对于一个点$A$，将其X坐标+px[n]，其Y坐标+py[n]，可以得到一个偏移的点，本代码的偏移对应正的上左下右。\n定义完这些变量后，我们可以开始读入了，读入m和n，这两个数就可以得知正片土地的大小，可以帮助我们定义一个恰到好处的数组作为我们的“地图”（我这个人非常喜欢恰到好处，即使有各种风险，不过毕竟是易语言写多了的，似乎也合理）\nint imap[m][n]，这是创建了一个二维数组，imap就是地图的意思（本来写的是map，但是同学说这貌似是个保留字，就改成imap了），这样我们就可以直接用X和Y操作点了。\nobject是什么呢？这里其实是用它存储杂物的位置信息的，考虑到杂物可能有很多，终归感觉还是定义为$m×s$比较好，这也是个二维数组，只不过是一个类似结构体数组的东西（实则每次存都是object[n][0]存X、object[n][1]存Y，完全可以写成结构体，但我懒，而且我喜欢数组，嘻嘻）\n最后一步，给imap数组初始化为0，至于为什么是0，请移步下一段。","四后记#四.后记":"还是忍不住想给大家分享一下这份我手写的原稿代码，虽然有一些细节上的瑕疵，但总体还是完整的 经过这次的解题，我意识到有一种写题方法是极优的，当你写完了代码运行起来却事与愿违时，不妨想想如何用自然语言来描述你的算法，这样的方式相比对着代码抓头发等容易发现思想上的纰漏，各位搞算法的可以尝试一下。\n有些困了，脑子也不好用了，可能迷迷糊糊的写了一些原因不明的话，先睡了，等睡醒再改改吧","量化每个位置的信息#量化每个位置的信息":"对于一个格子，它可以是荒地，可以是杂物，可以是被杂物影响的荒地，也有可能是在杂物影响范围内的杂物，需要注意的是：一个荒地有可能同时被两个甚至更多杂物影响。\n注意看下面的例子：\n.....\r.#.#.\r..... 这个例子中，两个#中间的.，即使在一边的杂物被去除后，仍然处在另一个杂物的影响之内，仍无法开垦，那么我们就认为，这次移除对于这单个点来说是无效的。\n那我们该怎么记录这个点在几个杂物的影响范围内呢？我们有一个量化策略，使用0表示可开垦，1表示一个杂物影响，2表示两个，最多可到4。\n同样的道理，对于放置杂物的格子，如果拿掉了，这一格也有可能无法开垦，我们同样要记录，这里我们使用-1表示杂物，-2表示被在一个杂物影响范围内的杂物，以此类推（这样设定是为了后面记录方便，这个我们姑且不谈）"},"title":"算法真题：GESP202503四级——荒地开垦（洛谷B4263）"},"/blog/2025-08-26_vscode%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99g++%E5%8D%B4%E5%AE%8C%E7%BE%8E%E7%BC%96%E8%AF%91api%E8%B0%83%E7%94%A8%E9%94%99%E5%9B%A0%E5%88%86%E6%9E%90/":{"data":{"":"前一段时间写了个小软件，想给它加个读写配置项功能，刚学几天C++的我上网查了半天资料，找到两个Windows的API分别是读ini的GetPrivateProfileString和写ini的WritePrivateProfileString，根据网上的教程，我写出了下面这三行：\nLPTSTR lpPath = new char[MAX_PATH]; strcpy(lpPath, \".\\\\config.ini\"); ::WritePrivateProfileString(\"config\", \"t\", \"120\", lpPath); 刚刚写完，VScode安的插件瞬间爆红，然后给出了这样的报错： 但是我确定我是完全按照教程走的，所以到底是哪里的问题呢？\n于是我尝试编译，结果非常惊人，g++没有任何报错的编译成功并且在当前目录新建了config.ini并写入了指定内容\n这有些奇怪，还是查查官方文档吧\n上MSDN，查WritePrivatePeofileString，却并没有查到，只查到了WritePrivatePeofileStringA和WritePrivatePeofileStringW（末尾都多了个字母）这两个函数\n没办法了，只好点进一个看看，我选择了WritePrivatePeofileStringA，诶，这个参数的类型好像不对，跟着教程写的是LPTSTR，但这里面写的是LPCSTR\n向下划，我在例子板块的下方看到了一串提示\nwinbase.h 标头将 WritePrivateProfileString 定义为一个别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将中性编码别名与不中性编码的代码混合使用可能会导致编译或运行时错误不匹配。 有关详细信息，请参阅函数原型的 约定。\n也就是说，WritePrivatePeofileString不是这个API的原名，它只是根据条件进行选择的\n回到VScode，按住Ctrl并单击WritePrivatePeofileString，看到了Windows.h中的内容：\n#ifdef UNICODE #define WritePrivatePeofileString WritePrivatePeofileStringW #else #define WritePrivatePeofileString WritePrivatePeofileStringA #endif VScode显示，上方是亮着的，证明VScode的环境下有UNICODE这个宏\n这下破案了，由于VScode有UNICODE宏而g++没有，所以插件检查时是按照WritePrivatePeofileStringW检查的，此时插件认为需要使用unicode，路径需要使用wchar_t也就是宽字符存储，g++编译时，按照WritePrivatePeofileStringA，此时g++认为要用ANSI，路径使用char也就是普通字符存储，于是我们使用的char的代码在g++下正常而没有通过VScode的插件检查\n因此，我们的书写是正确的，但是由于VScode的环境与g++不同，被插件当作了错误，此时我们应当指明我们要使用WritePrivatePeofileStringA函数：\nchar* lpPath = new char[MAX_PATH]; strcpy(lpPath, \".\\\\config.ini\"); ::WritePrivateProfileStringA(\"LiMing\", \"Sex\", \"Man\", lpPath); delete[] lpPath; 到这里就结束了，烦人的提醒终于消失不见了\n另附：LPxxxSTR数据类型的具体含义\n核心基础类型:\nCHAR: 表示一个 ANSI (8-bit) 字符 (char)。 WCHAR: 表示一个 宽字符 (Unicode, 通常是 16-bit UTF-16) (wchar_t)。 TCHAR: 自适应字符类型。根据项目设置（是否定义了 _UNICODE 宏）编译为 CHAR 或 WCHAR。用于编写既可编译为 ANSI 也可编译为 Unicode 的代码。 字符串指针类型:\nLPSTR: Long Pointer to STRing。指向以 NULL 结尾的 ANSI 字符串 (CHAR*)。 typedef CHAR* LPSTR; LPWSTR: Long Pointer to Wide STRing。指向以 NULL 结尾的 Unicode (UTF-16) 字符串 (WCHAR*)。 typedef WCHAR* LPWSTR; LPTSTR: Long Pointer to TCHAR STRing。指向以 NULL 结尾的 自适应字符 (TCHAR*) 字符串。根据 _UNICODE 宏定义，编译时等同于 LPSTR (ANSI) 或 LPWSTR (Unicode)。 typedef TCHAR* LPTSTR; 常量字符串指针类型:\nLPCSTR: Long Pointer to Constant STRing。指向以 NULL 结尾的 常量 ANSI 字符串 (const CHAR*)。 typedef const CHAR* LPCSTR; LPCWSTR: Long Pointer to Constant Wide STRing。指向以 NULL 结尾的 常量 Unicode (UTF-16) 字符串 (const WCHAR*)。 typedef const WCHAR* LPCWSTR; LPCTSTR: Long Pointer to Constant TCHAR STRing。指向以 NULL 结尾的 常量自适应字符 (const TCHAR*) 字符串。根据 _UNICODE 宏定义，编译时等同于 LPCSTR (ANSI) 或 LPCWSTR (Unicode)。 typedef const TCHAR* LPCTSTR; 关键区别总结表：\n类型 字符宽度 常量性 (const) 基础类型等价 (ANSI Build) 基础类型等价 (Unicode Build) 描述 LPSTR ANSI (8-bit) 非 const char* char* 指向 ANSI 字符串的指针 LPCSTR ANSI (8-bit) const const char* const char* 指向 只读 ANSI 字符串的指针 LPWSTR Unicode (16-bit) 非 const wchar_t* wchar_t* 指向 Unicode (UTF-16) 字符串的指针 LPCWSTR Unicode (16-bit) const const wchar_t* const wchar_t* 指向 只读 Unicode (UTF-16) 字符串的指针 LPTSTR 自适应 非 const char* (LPSTR) wchar_t* (LPWSTR) 指向自适应字符串的指针 (TCHAR*) LPCTSTR 自适应 const const char* (LPCSTR) const wchar_t* (LPCWSTR) 指向 只读 自适应字符串的指针 (const TCHAR*) 重要说明:\nLP 前缀: “Long Pointer” 是一个历史遗留物，在现代 32/64 位系统中，所有指针都是 “long”，可以简单地把 LP 理解为 “Pointer to”。 C 后缀: 表示 const，即指针指向的内容是只读的，不能通过这个指针修改字符串内容。 T 中缀: 表示类型是 TCHAR，它会根据项目字符集设置自适应。这是为了编写同时支持 ANSI 和 Unicode 构建的代码。 W 后缀: 表示 “Wide”，即 Unicode (UTF-16)。 STR 后缀: 表示 “String” (以 NULL 结尾的字符数组)。 现代 Windows 开发实践: 强烈推荐始终使用 Unicode 构建项目 (在 Visual Studio 项目属性中设置 “字符集” 为 “使用 Unicode 字符集”)。这定义了 _UNICODE 宏。 在 Unicode 构建下： TCHAR = WCHAR LPTSTR = LPWSTR LPCTSTR = LPCWSTR 直接使用 LPCWSTR/LPWSTR 或 LPCWSTR/LPWSTR 的别名 std::wstring (C++) 通常更清晰，避免 TCHAR 系列的歧义，除非你明确需要维护同时支持 ANSI/Unicode 的旧代码库。 ANSI (LPSTR/LPCSTR) API 函数在内部通常只是将字符串转换为 Unicode 然后调用对应的 Unicode 版本函数，存在性能开销和潜在的字符集转换问题。优先使用显式的 Unicode (W) 版本 API。 兼容性: TCHAR 系列主要是为了兼容旧的 Windows 9x 系统（主要使用 ANSI）和现代 NT 系统（原生 Unicode）。现代开发（Windows 2000 及以后）应首选 Unicode。 简单记忆:\n看 W -\u003e Unicode。 看 C -\u003e const (不能修改字符串内容)。 看 T -\u003e 自适应，根据项目设置变 ANSI 或 Unicode。 没有 W 也没有 T -\u003e ANSI。 没有 C -\u003e 字符串内容可修改 (非常量)。 有 C -\u003e 字符串内容只读 (常量)。 使用建议:\n新项目：始终开启 Unicode 构建 (_UNICODE defined)。优先使用 LPCWSTR (输入参数) 和 LPWSTR (输出参数)，或者在 C++ 中使用 const wchar_t* 和 std::wstring。 维护旧项目/需要 ANSI 兼容：使用 LPCTSTR (输入) 和 LPTSTR (输出) 或对应的 TCHAR 基础类型，并确保正确处理 _UNICODE 宏定义。 与 Windows API 交互时，注意 API 函数通常有 A (ANSI) 和 W (Wide/Unicode) 两个版本（如 MessageBoxA 和 MessageBoxW）。使用通用宏 MessageBox 会根据 _UNICODE 自动选择正确的版本。传递的字符串指针类型也必须与之匹配（LPCSTR 对应 A 版本，LPCWSTR 对应 W 版本，LPCTSTR 对应通用宏）。"},"title":"VScode插件报错，g++却完美编译？API调用错因分析"},"/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/":{"data":{"":"学习C/C++时，常常会遇到一个很烦人的东西：指针，说实话，指针在很多人入门C/C++时都是属于噩梦级的，它牵涉了庞大的知识体系，容易出现各种未定义行为，因此被称为C/C++中的最难知识点，那么这篇文章，就让我们好好聊一聊，这个BOSS级的指针。","11-malloc-memory-allocation#1.1. malloc (Memory Allocation)":"malloc函数允许你申请指定长度的内存，常见的使用模板如下：\n\u003ctype\u003e* \u003cptr_name\u003e = (\u003ctype\u003e*) malloc(\u003csize\u003e) 其中，等号左侧内容是指针的定义，用来保存申请到的内存信息（也就是起始地址），等号右侧的(*)是在转换数据类型，因为malloc返回的是void*型的也就是说没有数据类型泛型指针，我们需要告诉编译器这个指针应该是指向什么类型的数据的\nNote\n我们上面说的“没有数据类型”是指“没有标记指针指向的内容的数据类型”，更偏向于在说“不知道类型”\nmalloc只要一个参数，那就是申请多大的内存，我们直接使用sizeof函数即可，申请内存存放n个typeA型数据就申请n*sizeof(typeA)长度的内存\n下面是使用示例\nint *arr = (int *)malloc(5 * sizeof(int)); // 分配5个整数大小的内存 Note\nmalloc函数返回值可能为NULL，发生在申请失败时，大项目中要对此做错误处理；malloc申请到的内容都不初始化，可能包含垃圾数据，一定要手动初始化","12-calloc-contiguous-allocation#1.2. calloc (Contiguous Allocation)":"calloc与malloc类似，这个函数的语法如下：\nvoid* calloc(size_t num, size_t size); calloc的一个好处是分为了数量和单个大小两部分，不需要你自己计算了，另一个好处就是它会初始化你申请的内存的所有字节为0\n下面是例子：\nint *arr = (int *)calloc(5, sizeof(int)); // 分配并初始化5个整数大小的内存","13-realloc-reallocate-memory#1.3. realloc (Reallocate Memory)":"realloc函数可以用于调整已分配内存块的大小，当新大小＞原大小时，新增部分未初始化；当其＜原大小时，多余部分被释放，语法如下：\nvoid* realloc(void* ptr, size_t new_size); 用例如下：\narr = (int *)realloc(arr, 5 * sizeof(int)); // 扩展到5个整数大小","14-free-free-memory#1.4. free (Free Memory)":"free函数用于释放通过 malloc、calloc 或 realloc 分配的内存,语法如下\nvoid free(void* ptr); 这样做，是为了节约系统资源，否则会出现内存泄漏\nNote\n内存在使用Free释放后，指针仍然会存在，但不再指向有效内存，此时就成为了悬空指针，建议将其置为 NULL。\nWarning\n重复释放同一块内存；释放某块内存后继续访问该内存","1c语言实现#1.C语言实现":"C语言有这样几个函数：malloc、calloc、realloc、free，定义在 头文件中，负责完成动态内存分配的工作","1内存泄漏#1.内存泄漏":"大量使用new却不delete（或者大量申请内存不free()），会导致电脑大量资源被占用，因为你并不释放用过的内存，所以电脑不知道你用没用完，自然不敢分配给其他内容，时间一长，就有大量内存是你虽然不用但是系统也用不了的，这就是内存泄漏\n内存泄漏的最好解决方案就是C++的智能指针，可以自动管理指针","1常量指针指针常量#1.常量指针、指针常量":"指针可以指向常量，我们称呼指向常量的指针为常量指针，下面展示常量指针的一个定义示例：\nconst int *ptr; 编译器首先会看到ptr是个指针（*），然后在看到ptr指向int数据，最后再看到ptr指向的内容是常量，此情况下，ptr是可变的，但它指向的内容是不可变的\n与之对应的，还有指针常量，也就是指向为常量的指针，下面也演示一个示例：\nint * const ptr; 编译器首先看到ptr是个常量，然后在看到它是个指针，最后才看到它指向int型数据，此时ptr指向不可变，但其指向的内容可变\n你当然可以组合一下，让它变成这个样子：\nconst int * const ptr; 这玩意叫常量指针常量，在很多面试题里喜欢拿来说事。","1指针的基本定义格式#1.指针的基本定义格式":"C/C++的指针本质就是变量，因此也和变量遵循近似的定义方式，下面是基本模板：\n\u003ctype\u003e * \u003cname\u003e; 其中，填充指针所指向的数据的数据类型，填充这个指针的名称（类似于变量名，可以自己在规则内随便起名）；*是C/C++的特殊符号，有很多重意义，在这里用于标注紧跟的标识符是指针。\n下面的内容定义了一个整数型指针：\nint *ptr; // 这里是无初始值的，所以不指向任何内容","1程序与内存#1.程序与内存":"不管你使用什么语言，只要它最后生成了可执行程序，在运行时都是被分为四部分读入内存的，在内存中，分别是：\n代码段：程序编译出的机器码逐行存放在代码段\n数据段：静态变量、全局变量等生命周期跨越整个程序的数据存放的位置\n堆栈段：又分为堆段和栈段，堆段放置动态的变量，栈段存放上下文信息（函数的局部变量、调用时的参数、返回地址）\n从上面可以看出，我们在开发中使用到的变量实际上都是写入了内存的，因此理论上我们可以通过修改内存来修改变量","21new#2.1.new":"new是C++的一个关键字，负责开辟一块连续的内存空间存放指定类型的数据，不同于C语言版本需要自己计算内存大小、自行数据转换，C++的new会直接指定申请的内存的数据类型，它的基本写法是这样的：\nnew type; 如果new出来的内存不是直接使用的（比如使用构造函数初始化智能指针），我们就需要一个指针来存储，写法大致是这样：\ntype *name = new type; 我们可以写一个申请单个int变量长度的内存的程序试试手\nint *ptr = new int; 我们不止可以使用new关键字开辟一个变量的长度的内存，也可以开辟可容纳多个变量的内存空间，如下：\nint *ptr = new int[5] 此时我们开辟了5*sizeof(int)大小的内存空间，ptr指针可以在ptr到ptr+4之间自由活动。\n另外需要说明的是，我们可以在new时使用构造函数赋予内存初始值，比如我们可以写：new int(10)","22delete#2.2.delete":"和C一样的，在用完了申请的内存后，需要进行释放，以便告诉计算机对应的内存已经不会被用到了，好让计算机分配给别的东西，这就会用到delete。\ndelete很简单，直接就写成：\ndelete ptr_name; 他会释放紧跟着的指针变量所指向的内存地址\n当然，这种方式有一个局限，就是不能很好的释放诸如new int[10]申请的内存，因此就需要使用delete[]来与之对应：\nint *ptr = new int[10]; delete[] ptr; 注意[]中不需要填充任何内容","2c的实现#2.C++的实现":"C++的动态内存分配使用new和delete实现，相对于C语言，C++的分配更为简单","2内存地址变量地址#2.内存地址、变量地址":"内存是一小块一小块存储单元线性排列组成的的，因此我们可以为内存的每一块都依次标上序号，这样的序号我们称之为内存地址，内存地址相当于内存每一个单元的身份证号，对于一块内存，有且只有一个内存地址与之对应，以此，我们可以很方便的利用内存地址描述、操作内存中的区块。\n上面讲过，高级语言编写的程序运行时变量都是写在内存之中的，因此我们可以使用内存地址来描述一个变量的起始位置，在这种情况下，变量对应的内存地址就称为变量地址。\n我们看下面的例子：\nint a; a = 10; 对于编译器，你定义了一个变量，并且在之后赋值为了10，那么它转换后的机器语言代码大致动作如下：\n找连续的空内存，累计大小正好是一个int型的大小\n将10的二进制值写入内存，假内存长度大于数字长度，则数字前面的部分全部为0\n也就是说变量名在高级语言中属于标识符，你为一块内存起了个名字，这个名字是你在定义时告诉编译器的，相对于汇编使用内存地址，你可以更方便的在开发中明白某个内容的用意是什么，但它的本质还是内存操作，只是操作内存的部分由编译器帮你编写了。","2悬空指针#2.悬空指针":"悬空指针，又叫“悬垂指针”、“迷途指针”、”失效指针“等等，其成因是内存销毁了，但指针仍在指向这一块内存，比如：\nint *ptr = new int; delete ptr; // 内存已经释放 (*ptr)++; // 此时还在解引用ptr 这种情况下，内存已经释放了，随时会被重新分配，因此*ptr这样的语句就很危险。\n想要避免这样的情况，就要在释放内存后立刻将ptr设为NULL\n当然悬空指针肯定不止这一种成因，有时生命周期长的指针指向生命周期短的变量也会使得悬空指针出现：\nint *ptr; { // 单独的作用域 int var = 10; ptr = \u0026var; } // 此处不在var作用域，var已销毁 *ptr = 20;// 出错，var已经不存在了，对应的内存状况未知 因此，指针在使用时一定要注意生命周期的问题","2数组指针指针数组#2.数组指针、指针数组":"类似于常量指针、指针常量，数组也能与指针结合\n数组指针就是指向数组的指针，示例如下：\nint (*ptr)[10]; 这里需要使用()改变优先级，直接告诉编译器ptr是个指针，指向一个数组\n指针数组就是存着指针的数据，用下面的代码可以定义：\n(int *) ptr[10]; 此时ptr是数组，每一个成员都是指针\n与常量同理，你可以组合出数组指针数组，但我已经懒得思考了，所以具体代码就不写了（我写这里时已经1:19了，并且我刚写完下面的智能指针等内容）","2星号的位置#2.星号的位置":"需要注意的是，指针的定义有一个非常需要注意的内容，就是*的位置，有时它在不同位置是同样的效果，但是阅读起来却会给人两种感觉，可能会导致阅读者对代码产生误解。\n// 下面两种都是正确的 int *ptr1; // 星号紧跟标识符 int* ptr2; // 星号紧跟数据类型 对于指针的定义，C/C++不关心数据类型、*、标识符中间的空格，因此上面的两种间隔方式都是对的，但是普遍来讲在开发中更推荐第一种，因为第二种写法容易给人一种错觉：ptr2的数据类型是int*，这在单个指针的定义中还看不出什么，但是如果多写几个，情况就不一样了，前面我们说到过，*算是一种特殊符号，它只作用于紧跟的标识符，所以之后出现的被分隔的标识符不会被作用到！\n我们来看例子：\nint* ptr1,ptr2,ptr3,*ptr4; 此时，ptr1、ptr4是指针，另外两个则是普通变量，*并没有作用于2、3，想要定义的全部都是指针变量，则需要：\nint *ptr1,*ptr2,*ptr3,*ptr4; 在项目开发中，建议避免int* ptr;的使用，这样能够有效的防止误解的产生，当然你也可以选择讲所有指针的定义放到普通变量之后，，如果你翻看windows.h就会发现很多数据类型的定义都是这种顺序（其实也许不止这个头，但我只看过这个头）\nNote\n其实用哪一种是风格的选择，因此没有绝对的对何错，现代C++反而更倾向于将 * 与类型结合，以强调“指针类型”概念，所以只需注意多变量定义时的陷阱即可，不需要纠结到底用哪一种","3restrict修饰符#3.restrict修饰符":"Note\nrestrict关键字是C语言关键字，在C99标准引入，C++标准并不支持这一关键字，不过主流编译器（比如GCC, Clang, MSVC）可能会在C++模式中将其作为扩展支持，有时需要写作__restrict，但并不是都支持的且使用不一定相同\n有时编译器不敢擅自对程序进行优化，即使只是为了防止某些小概率事件发生\n比如当你写下：\nbool func(int *ptr1,int *ptr2){ *ptr1 = 10; *ptr2 = 20; if(*ptr1 != *ptr2){ return 1; } return 0; } 对于这个函数，分别将*ptr1、*ptr2赋值成了10、20，所以自然不会相等，对此，我们似乎可以优化这个函数，使其变成：\nbool func(int *ptr1,int *ptr2){ return 1; } 但真的是这样吗？\n如果你仔细想想就会发现，这种情况在ptr1=ptr2时是不成立的，因为虽然分别赋了不同值，但由于指向同一块内存，所以赋值操作一前一后，后者覆盖了前者的内容，最后，*ptr1 = *ptr2\n于是编译器就不敢优化了，因为这种情况虽然概率小，但未必不会发生，此时我们如果想让编译器去优化，就应该告诉它：这两个指针不一样\n那么该怎么告诉它呢，答案就是restrict，这个关键字告诉编译器这个指针是只想这一块内存的唯一方式，没有另外的指针指向着一块内存，这时，编译器就会去优化了\nbool func(restrict int *ptr1,restrict int *ptr2){ *ptr1 = 10; *ptr2 = 20; if(*ptr1 != *ptr2){ return 1 } return 0; } 注意，这是一种”保证“，假如你写了restrict但实际上还有指针指向了这块内存，那么程序就可能会因为优化出现问题，所以请一定要谨慎使用","3指针的初始化#3.指针的初始化":"普通变量可以初始化，指针变量当然也可以初始化，指针变量的初始化如下：\n// 我们这里先介绍借助已有变量的初始化，其他方式之后再讲 int var; // 先要有一个int变量 int *ptr = \u0026var; // 借助已有变量初始化 上述代码出现了\u0026符号，这个符号跟在标识符前方时是取地址的意思，可以获取变量、函数等内容在内存中的地址。\n指针变量一般直接使用=进行初始化，将右侧内容写入指针变量，也就是说，右侧的初始值应当是内存地址。","3汇编与内存#3.汇编与内存":"汇编中（起码在intel汇编中）使用[]标记地址，汇编编译器在看到这个符号时，就会将里面的内容理解为地址，然后读取内容后参与操作，比如MOV EAX,[EBX]指令的作用，就是到EBX寄存器（一种高速但很小的存储器，位价很高）存储的内存地址值对应的内存中取出数据然后移动到EAX寄存器，此例中，EAX存储数据，EBX存储地址，EBX存储的地址对应的内存存储数据。\n实际上，汇编语言更多时候使用诸如MOV EAX,BYTE[EBX]的格式，BYTE叫“类型修饰符”或“大小指示符”，近似于高级语言中的数据格式，约定了“这个地址指向的数据有多长”","3野指针#3.野指针":"当指针因为各种原因具有了随机的值时，这个指针就是野指针，比如我们使用取随机数取到了一个数字，再传换成了int*赋值给了一个int指针，我们无法预见这个指针在运行时会有怎么样的行为，如果这个指针读数据，那么就会读到意义不明的数据；如果这个指针写数据，则有可能会导致软件甚至系统的数据被修改导致运行时崩溃，这就是未定义行为\n下面的几种行为很容易出现野指针：\n使用结果带有随机性的函数的返回值作为指针指向的地址\n不初始化指针变量\n随便给指针变量了一个初始值\n程序开发中一定要避免","4cc的内存操作#4.C/C++的内存操作":"作为现代最贴近硬件的高级语言，C/C++自然保存了内存操作，这也就是我们要讲的指针。\n指针在本质上讲是变量，只不过存储的是地址，因此是一类特殊的变量，指针变量的数据类型可以说是“某类型指针”，比如“整数指针”就是指向整数的指针。类比汇编的内存操作中的内容，变量类似于寄存器，可以存储各种数据，此时我们单独拿出一个寄存器，使其只存储地址，这个寄存器就是指针。\n指针提供了灵活操作内存的可能，扩展了C/C++的能力，同时也可以用于节约复制传址造成的大开销，如果你对指针有所了解，你甚至会发现它允许你将一个有你自定义的数据类型交给已经写好的函数进行传递（我是指Win32的窗口状态信息）\n我们将在下面细致讨论他。","4使用指针#4.使用指针":"使用指针时，*又有了新的含义，当其紧跟着已经定义过的标识符时，*就是解引用符号，与汇编[]发挥相同效用，操作被解引用的地址就可以理解为在直接操作地址对应的内存：\n*ptr = 20 指针很大一部分难点就是要需要区分ptr和*ptr，前面我们讲过，指针变量就相当于汇编里存了数据的寄存器，因此我们可以修改指针变量的内容，这会调整其指向；我们也可以修改指针变量指向内容的值。\n下面是C++的例子，大家可以自己复制下来放到编译器里运行试试：\n#include int main(){ int var = 10; // 普通变量 int *ptr = \u0026var; // 初始化ptr指向var std::cout\u003c\u003c\u0026var\u003c\u003c\" \"\u003c\u003cptr\u003c\u003c\" \"\u003c\u003c(*ptr)\u003c\u003c\" \"\u003c\u003cvar\u003c\u003cstd::endl; (*ptr)++; // 增加指针指向的值，注意括号是必须的 std::cout\u003c\u003c\u0026var\u003c\u003c\" \"\u003c\u003cptr\u003c\u003c\" \"\u003c\u003c(*ptr)\u003c\u003c\" \"\u003c\u003cvar\u003c\u003cstd::endl; return 0; } 可以很明显的看出，指针变量的单独使用，其内容是地址，与对应的变量取地址的结果相同；指针解引用后的内容是真正的数据，也就是对应变量的内容\n注意(*ptr)++之中括号是必须的，因为*ptr++会被理解为解引用prt++而不是解引用ptr再++，这是改变优先级的操作\nNote\n上面的代码中使用(*ptr)，这在第六行是必须的，但在输出时貌似并不必须，只是我不知道当时看的哪个指针教程教了一个优先级，导致我现在各种没必要的地方也去加括号","4未初始化指针#4.未初始化指针":"定义指针后，未经初始化，也没有赋任何值，指针内存的数据就是上一次用过这一块内存的程序（变量）所留下来的内容，这个内容是不确定的，因此指针不初始化就使用是是绝对错误的，它是野指针的一种","4泛型指针#4.泛型指针":"C/C++支持一种叫泛型指针的东西，泛型指针本质上是指针，只是没有数据类型\n泛型指针写作下面的形式：\nvoid* ptr_name; 泛型指针本身不难理解，指针无非就是地址，数据类型只是标记理解方式，假如我们只要看地址，而不需要程序去理解”这是什么数据“，我们就可以使用void*，通常，泛型指针会出现在某些函数的返回值中，比如一个申请一块内存并且每一位都填充1的函数，返回指针，具体类型交给使用者决定。","510自定义删除器#5.10.自定义删除器":"智能指针的大概实现就是在构造函数处定义指针，然后在析构函数处释放内存，但我们可以让这个过程更自定义一些，以便让智能指针可以为我们管理更多的东西，这就需要自定义删除器，也就是让智能指针在析构函数处做出我们期待的行为\n自定义删除器可以是函数（指针）、类（的对象），或者lambda表达式\n下面的例子采用了最经典的文件句柄管理的例子，包含了上面的三种方法，详细的讲解通过注释写出了：\n#include #include #include // 函数形式的删除器，返回值是void void FileDeleter(FILE* file) { if (file) { std::cout \u003c\u003c \"使用函数删除器关闭文件\" \u003c\u003c std::endl; fclose(file); } } // 类形式的删除器 class FileDeleterClass { public: void operator()(FILE* file) const { // 使用operator()重载操作符 if (file) { std::cout \u003c\u003c \"使用类删除器关闭文件\" \u003c\u003c std::endl; fclose(file); } } }; // Lambda 表达式删除器 auto lambdaDeleter = [](FILE* file) { if (file) { std::cout \u003c\u003c \"使用Lambda删除器关闭文件\" \u003c\u003c std::endl; fclose(file); } }; int main() { // 创建临时文件用于演示 FILE* temp1 = tmpfile(); FILE* temp2 = tmpfile(); FILE* temp3 = tmpfile(); if (!temp1 || !temp2 || !temp3) { // 虽然只是演示，但错误处理的意识也要有 std::cerr \u003c\u003c \"创建临时文件失败\" \u003c\u003c std::endl; return 1; } std::cout \u003c\u003c \"开始演示三种自定义删除器（unique_ptr）\" \u003c\u003c std::endl; // 使用函数形式的删除器 std::unique_ptr\u003cFILE, decltype(\u0026FileDeleter)\u003e filePtr1(temp1, FileDeleter); // decltype是让编译器推导数据类型你也可以写做下面的形式： // std::unique_ptr // 使用类形式的删除器 std::unique_ptr\u003cFILE, FileDeleterClass\u003e filePtr2(temp2); // 使用Lambda表达式的删除器 std::unique_ptr\u003cFILE, decltype(lambdaDeleter)\u003e filePtr3(temp3, lambdaDeleter); // 尝试向文件写入一些数据 fprintf(filePtr1.get(), \"Hello from file 1\\n\"); fprintf(filePtr2.get(), \"Hello from file 2\\n\"); fprintf(filePtr3.get(), \"Hello from file 3\\n\"); std::cout \u003c\u003c \"文件使用完毕，即将自动调用删除器...\" \u003c\u003c std::endl; // 当 main 函数结束时，三个 unique_ptr 会超出作用域 // 它们各自的删除器会被自动调用 return 0; } 限于篇幅原因，很多内容我们无法展开，比如shared_ptr的使用和unique_ptr是不同的，很多张要的概念也没有展开，各位可以自行阅读下面的内容：\nC++: 智能指针的自定义删除器 Custom Deleter 有什么用？ - 知乎\n【C++高阶】：自定义删除器的全面探索-CSDN博客","511一些坑#5.11.一些坑":"智能指针可能会遇到循环引用的问题，可以到对应的位置阅读（点链接）","51定义智能指针与初始化#5.1.定义智能指针与初始化":"智能指针的定义是这样的：\nstd::ptr_type\u003ctype\u003e ptr_name; 其中，ptr_type填上上面说的三种中的一种，type填数据类型，ptr_name填指针名，此时我们的指针是没有初始值的，我们还需要赋初始值才能使用\n刚刚的内容改成：\nstd::ptr_type\u003ctype\u003e ptr_name(...); 这个是通过构造函数赋值的方法，比如：\nstd::shared_ptr\u003cint\u003e ptr(new int); 这就是new了一块内存然后用于构建智能指针ptr，其初始值为new int的返回结果\n假设你更喜欢看=的初始化，那当然也是可以的：\nauto ptr = make_shared\u003cint\u003e(20); 此时我们就得到了一个指向内容为20的内存的智能指针。","52unique_ptr#5.2.unique_ptr":"std::unique_ptr指向一个内存，当它移走或结束了生命周期时，也就是说不再指向那一块内存，对应的内存会自动delete，可以看下面的例子：\n{std::unique_ptr\u003cint\u003e ptr(new int(10));} // ptr超出作用域被销毁，自动delete 对于一块内存，只会有一个unique_ptr指向它，因此只要这个指针不再指向这块内存，就自动销毁","53shared_ptr#5.3.shared_ptr":"与unique_ptr不同，std::shared_ptr允许多指针同时指向同一内存，因此它是计数销毁的指针，也就是当很多shared_ptr指向同一个内存，只有这些指针都不指向这块内存了（引用计数为0），它才会被销毁","54weak_ptr#5.4.weak_ptr":"shared_ptr存在一个瑕疵，就是如果遇到了循环引用，照样会内存泄漏，于是便引入了我们的weak_ptr也就是弱引用\n在某种程度上，std::weak_ptr和shared_ptr其实差不多，只是它不参与引用计数，也就是说，当weak和shared同时指向一块内存，只要shared都不在指向该内存，无论weak是否还在指着，内存都会被销毁\nweak_ptr介于shared_ptr和普通指针之间，它提供了安全的访问，使得我们无需担心普通指针会遇到的悬空指针，也不会担心出现shared_ptr的循环引用","55转移所有权放弃所有权#5.5.转移所有权、放弃所有权":"对于智能指针，你可以直接理解为它是一个帮你保管指针的第三方，对于一个unique_ptr，它所指向的内存只会被它自己指向，我们便可以说某块内存是该智能指针所有的\n我们可以使用std::move来转移所有权：\nstd::unique_ptr\u003cint\u003e ptr1 = std::make_unique\u003cint\u003e(10); // 转移所有权 std::unique_ptr\u003cint\u003e ptr2 = std::move(ptr1); // 现在 ptr1 为 nullptr，ptr2 拥有对象 if (!ptr1) { std::cout \u003c\u003c \"ptr1 已失去所有权\" \u003c\u003c std::endl; } 由于ptr1已经将指针转移给了ptr2，它就不再管理这个对象，因此其值变为了nullptr也就是不指向任何内容，ptr2则是指向ptr1之前指向的内存\nTip\n对于nullptr，其在if等条件判断语句中拥有与fault相似的效果，!nullptr则有与true类似的效果，可以使用这个方式直接写if(!ptr)来判断指针ptr是否为空\n当然了，ptr1可以直接变成nullptr而不转移所有权，也就是直接放弃所有权，不转移到其他智能指针手中，此时指针不再被智能指针托管，回归普通指针，我们可以使用release()实现：\nstd::unique_ptr\u003cint\u003e ptr = std::make_unique\u003cint\u003e(100); int* raw_ptr = ptr.release(); // ptr 变为 nullptr，release返回原始指针 // 这里你也可以选择不把指针存起来，但这一定会内存泄漏 // 现在需要手动管理 raw_ptr delete raw_ptr; 注意释放后的智能指针不再智能管理，因此需要你在release()后手动的delete掉对应的内存，因为放弃所有权是不会自动delete的","56获取原始指针#5.6.获取原始指针":"放弃所有权会返回一个原指针，但有时我们可能会更希望在保留所有权的状态下拿到原始指针，比如我们想要给已有的智能指针做个拷贝，此时我们就需要使用get()\nstd::shared_ptr\u003cint\u003e ptr = std::make_shared\u003cint\u003e(42); int* raw_ptr = ptr.get(); // 获取但不放弃所有权 Warning\n当你获取到原始指针时，一定不要试图去delete，我们在后面的内容中会论述为什么这样做是危险的","57释放资源#5.7.释放资源":"智能指针虽然可以自动的管理指针，但是那只是达成了某些条件才触发的，有时我们希望在这些条件没达成之时就释放掉对应的内存，那么假如我们写了下面的内容：\nstd::unique_ptr\u003cint\u003e ptr(new int); delete ptr.get(); // delete ptr; Warning\n上述代码是坚决不可取的！！！！\n如果你采用了delete ptr.get();，这将导致双重释放错误，我们手动释放的操作智能指针是不知道的，因此当我们的智能指针结束了生命周期或者在其他符合条件的情况下，仍然会去尝试释放这块已经释放过的内存，这将导致很多问题在运行时发生。\n加入你采用了上方注释中的delete ptr;，情况会好些，但我说的“好些”是指这种写法压根不会通过编译，因此不会在运行时搞出各种各样稀奇古怪的状况。\n那么该怎么正确的释放呢？答案是reset()\nreset可以改变智能指针的朝向，无参数时，它会将智能指针指向的内容销毁（或计数-1或什么都不做），然后让智能指针变为nullptr；有参数时，提供一个新的内存地址，reset释放（或计数-1等）旧对象指向新对象\n因此对于unique_ptr，我们可以使用reset销毁对应的内存并将该智能指针值改为nullptr（也有可能是指向新对象，总之不再指向原来指向的位置了）\n对于shared_ptr，我们可以将所有指向同一块内存的指针都reset一下，这样计数就变为0了\n下面看例子：\nstd::unique_ptr\u003cint\u003e ptr = std::make_unique\u003cint\u003e(50); ptr.reset(); // 释放当前对象，ptr 变为 nullptr // ptr.reset(new int(60)); // 释放旧对象，管理新对象","581user_count#5.8.1.user_count()":"shared_ptr有一些特有的操作，常用的是use_count()，它可以查看某个shared_ptr指向的内容的引用计数，也就是同时有多少shared_ptr在指向这个内存\nauto ptr1 = std::make_shared\u003cint\u003e(100); auto ptr2 = ptr1; std::cout \u003c\u003c \"引用计数: \" \u003c\u003c ptr1.use_count() \u003c\u003c std::endl; // 输出 2","582unique#5.8.2.unique()":"C++20标准之前，shared_ptr还有一个unique()命令，不过在20以后就不再使用了，这个命令可以检查智能指针是否是指向的内存的唯一所有者\nNote\nunique()在C++20标准之后是“不能使用”，实际上其早在C++17中就已经被弃用了，只不过是在C++20中被正式移除了\nunique()用例如下：\nptr.unique();","58shared特有操作#5.8.shared特有操作":"","591lock#5.9.1.lock()":"weak是削弱的shared，其出现目的就是解决循环引用之类的问题，但有时我们也想把它变成一个shared_ptr，这时我们就需要使用lock()\nNote\n你当然可以直接用get()拿到地址然后再去定义一个shared_ptr，但你要明白weak是弱引用指针，它指向的内存可能已经被释放了，所以这样一条手动路径就有些危险了\nlock()是weak转shared的一个相对安全的方式，对于正常的内存，lock()返回一个shared_ptr，对于一个已经释放的内存，则会返回一个nullptr\nstd::shared_ptr\u003cint\u003e shared = std::make_shared\u003cint\u003e(200); std::weak_ptr\u003cint\u003e weak = shared; if (auto temp = weak.lock()) { // 尝试获取 shared_ptr std::cout \u003c\u003c \"对象存在，内容为: \" \u003c\u003c *temp \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"对象已被释放\" \u003c\u003c std::endl; }","592expired#5.9.2.expired()":"expired可以检测weak指向的内存有没有被释放（也可以说说叫检查指针有没有过期）\nstd::weak_ptr\u003cint\u003e weak; { auto shared = std::make_shared\u003cint\u003e(300); weak = shared; std::cout \u003c\u003c \"过期: \" \u003c\u003c weak.expired() \u003c\u003c std::endl; // false } std::cout \u003c\u003c \"过期: \" \u003c\u003c weak.expired() \u003c\u003c std::endl; // true","59weak特有操作#5.9.weak特有操作":"","5引用#5.引用":"C++提供了一种C语言没有的形式叫引用，它与指针相似，都是基于地址操作的，所以我们放在一起讲。\n一个变量具有以下属性：\n变量地址：变量的起始位置\n数据类型：变量的长度、编码等信息\n修饰信息：决定变量以什么形态存在\n生命周期等等….\n对于指针变量，他存储了某个地址，同时它也有自己的地址，也就是我们在借助一个变量访问一个内存，指针正如它的名字那样，它就是一个“指针”，本身不可能作为“目的地”，但可”指向真正的目的地\n引用则与之不同，引用本身可以理解为普通变量，只是不会在定义时寻找空的内存，而是直接把自己的地址信息改成别的变量的，你可以理解为内存是一间小屋，变量是允许你进入的门，引用就是再开一个门：\nint a; // 一个变量a int \u0026b = a; // 一个引用b b=20; a=10; 上面就是引用的写法了，此时我们直接改a，a和b的值同时变化，因为它们本质上对应的同一块内存，只是取了个别名而已。","5智能指针#5.智能指针":"Note\n智能指针是C++特有的内容，如果你只想学习C语言，请直接跳过本条到1.常量指针、指针常量\nTip\n接下来的内容篇幅很长，但智能指针是C++中很重要的概念，请各位一定对此要有耐心\n动态内存分配很容易搞出内存泄漏，C++提供了方便的方式也就是智能指针，它可以来避免这种危险（C语言没有智能指针，需要手动管理指针），智能指针会根据情况自动的释放内存\n智能指针由提供，包括shared_ptr、unique_ptr和weak_ptr三种，他们有着不同的释放判断方式，但基本功能都差不多，我们之后将逐一讲解","5空指针#5.空指针":"指针没有内容就是空指针，与未初始化指针不同，空指针有着确定的值，但这个值是NULL，也就是说这个指针一定没有值，NULL不会和任何内存对应，因此解引用NULL是十分荒谬的行为，这会导致软件允许出错\nint *ptr=NULL; std::cout\u003c\u003c*ptr; 使用时一定要注意规避这种情况，可以在无法确定指针值的情况下加入判断来提升程序的异常处理能力，比如从函数中获取的作为返回值的指针值就需要判断是否为NULL","6函数指针#6.函数指针":"用过易语言可能会了解，有一种指针叫做函数指针，毕竟函数最后编译出的机器指令还是存在内存中的代码段的，也会有地址，自然也能有指针，其基本写法是\n返回类型 (*指针变量名)(参数类型1, 参数类型2, ...); 例如：\nint func(int a,char b);// 函数（声明） int (*ptr_func)(int a,char b); // 指针 函数指针通常会被用作回调函数传递给别的函数，一般的用途是让对应的函数在特定事件发生时自动调用被指向的函数\n大多数时候，函数指针的数据类型都是很长的，我们有两个选择：\n使用auto，让编译器自行推到\n使用typedef，简化书写\n使用std::function\n使用decltype获取数据类型，适合极度复杂的情况","6多级指针#6.多级指针":"指针是可以指向指针的，像这样：\nint *ptr; int **ptr2=\u0026ptr; 如果想通过ptr2访问到ptr指向的内存，就需要写*(*ptr2)，这样的嵌套理论上可以无限地进行，但是实际上你在应用中用到三级以上的指针就很罕见了","6循环引用#6.循环引用":"Note\n此处内容需要智能指针的前置知识了解\nC++提供智能指针是为了解决内存泄漏而生，但依旧没有完全规避掉内存泄漏，比如循环引用依旧会导致内存泄漏发生\n循环引用常发生在两个或多个对象通过shared_ptr互相持有时，我们先写出两个示例类，使之可以达到互相持有的条件：\nclass classB; // 向前声明classB class classA{ public: std::shared_ptr\u003cclassB\u003e ptr; } class classB{ public: std::shared_ptr\u003cclassA\u003e ptr; } 此时，只需要两个shared_ptr分别指向这两个类的对象，然后再在成员中互相指向对方就形成了循环引用：\nstd::shared_ptr\u003cclassA\u003e ptr1(new classA); std::shared_ptr\u003cclassB\u003e ptr2(new classB); ptr1-\u003eptr = ptr2; // 该语句等效于(*ptr1).ptr = ptr2; ptr2-\u003eptr = ptr1; 此时存在两个对象，分别是classA对象和classB对象，这两个对象的引用计数都为2，对于classA的对象，存在ptr1和ptr2-\u003eptr的引用，对于classB对象则类似（为了简化语言，我们接下来说A对象、B对象）\nTip\n关于ptr2-\u003eptr这一类写法，请参考语法糖部分的说明\n当ptr1与ptr2都销毁了时，A对象、B对象引用计次均减为1，但由于不为零，并不会释放内存，此时虽然我们的程序无法用到这两个对象，但它们仍然客观存在于我们的内存中，保持互相指向对方的状态，不会被智能指针释放\n解决这一问题，请使用weak_ptr进行弱引用，这样对象内部的成员就不会增加引用计次（这个行为貌似成为解耦合，不过我也不是很清楚来着，嘿嘿）","7__ptr32__ptr64#7.__ptr32、__ptr64":"微软为了跨平台，提供了__ptr32与__ptr64，这两个指针的特点就是：固定，前者无论在32位系统还是64位系统长度都为32位，后者则永远64位，这两个指针形式是为了同一指针长度而出现的，32位系统上，__ptr64会被截去一半；64位系统上，__ptr32会被扩充一倍\n具体内容请参考微软官方文档","8长指针#8.长指针":"Warning\n长指针是16位x86架构（实模式、分段内存模型）的历史概念，在现代32/64位平坦内存模型中已无必要且不被标准支持，本部分内容仅为了让你能了解涉及的关键字，防止看不懂某些古早的代码\n由于历史原因，C/C++支持了远指针、巨指针，这两个统称为长指针，相较之下普通指针称为近指针\n支持这两个指针的原因是早期计算机寻址能力很差，一个指针变量能存的数小于实际的内存数量，就导致指针无法记录所有地址，很多地址都无法被表示，因此就引入了基址、偏移的概念，人们表示一个内存，不再用单独的地址，而是使用一个基址与一个偏移组合，写成基址:偏移，算出基址*16+偏移即为真正的物理地址\n早期C/C++支持了这一用法，也就是长指针，这让程序有了更大的内存空间可用\nfar int * ptr1; // 远指针 large int * ptr2; // 巨指针 巨指针和远指针差不多，只不过巨指针多了一些规范，我们先看这样两个基址:偏移表述的物理地址：\n1F2A:3A13 = 223B3\n1D09:5323 = 223B3\n也就是说，我们用不同的基址:偏移算出了同样的物理地址，这就是远指针可能的问题，巨指针使用了特殊规则，使得一个物理地址只会有一个表述","一汇编层面的指针理解#一.汇编层面的指针理解":"","七数组退化为指针#七.数组退化为指针":"数组在某种意义上是指针的特殊形式，其指向数组内容的开头，标记数据类型与数据的量，因此具有一些指针的性质\n如果手头有编译器，可以试试下面的代码：\nint a[5]={1,2,3,4,5}; std::cout\u003c\u003ca[2]\u003c\u003cstd::endl\u003c\u003c2[a]; 你会发现输出了两次3，因此我们不难发现数组操作的本质：\n对于数组操作X[Y]，以X+Y得到一个地址，随后解引用，得到内容\n我们可以说数组是指针的变种，那么自然数组也可以退化为指针，在大多数表达式中，数组名会隐式转换为指向其首元素的指针:\nint a[10]; int *ptr; ptr = a;","三动态内存分配#三.动态内存分配":"你可能会问：指针一定需要指向已经有的变量吗？答案是：没必要。\n上面使用已有变量取地址初始化讲解只是为了方便讲解，指针真正的大用途是动态内存分配，也就是灵活的、直接的申请内存、操作内存，标准店的定义是：\n动态内存分配是指在程序运行时根据需要分配和释放内存，而不是在编译时确定内存大小\nC++和C的实现是不一样的，我们分开讲","九写在最后#九.写在最后":"本文考虑篇幅，很多内容并没有细讲，再加上笔者本身实力有限，您可以阅读下面由笔者精选的内容进行更细致的学习：\n【笔记】C++泛型指针、原生指针、智能指针和引用 - 知乎\nC语言实现泛型编程 | 菜鸟教程\n【C++高阶】：智能指针的全面解析_智能指针详解-CSDN博客\nC++: 智能指针的自定义删除器 Custom Deleter 有什么用？ - 知乎\n【C++高阶】：自定义删除器的全面探索-CSDN博客\n【C++11】C++智能指针循环引用问题分析 - bdy - 博客园\n__ptr32、__ptr64 | Microsoft Learn\n揭秘C语言长指针与短指针的奥秘：如何高效运用，避免编程陷阱 - 云原生实践\n深入理解C和C++中的函数指针与回调机制 - 知乎\nC语言指针进阶（一）——深入详解“函数指针”与“指针函数”-CSDN博客\n转发本文章到以下平台？","二cc指针基础#二.C/C++指针基础":"","五语法糖#五.语法糖":"对于类的指针，C++提供了语法糖\n一般操作类的指针，我们需要这样：\nclass classA{ int num; } int main(){ classA A; classA* ptr = \u0026A; (*ptr).num=10; } 我们需要(*ptr).num=10;来解引用后使用成员，，但我们也可以这么写：\nptr-\u003enum=10; 写法选哪个纯粹看个人喜好，我个人更喜欢-\u003e，看上去简洁不少","八指针的移动长度#八.指针的移动长度":"指针变量内容变化，朝向就会变化，我们可以用++、--来让指针向上或向下移动一位，这可以用于在数组中游走，不过有一点需要注意，指针变量+1不代表内存地址加一，而是意味着内存地址加上一个对应数据类型的数据的大小的值，比如假设classA的每个成员需要占据50块内存，classA的指针+1时地址就+50","六指针有关的错误#六.指针有关的错误":"","四进阶的指针常见种类#四.进阶的指针常见种类":"讲完了指针的基础，我们可以看看常用的一些进阶概念了"},"title":"C/C++指针种类+常见错误+组合技巧，挑战写出全网最全指针文章"},"/blog/2025-10-18_1143_%E8%BD%BB%E9%87%8F%E4%BD%BF%E7%94%A8git%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E6%95%99%E5%AD%A6/":{"data":{"":"Git 是一个分布式版本控制系统，用于跟踪文件的更改，特别是源代码文件的更改。以下是一些 Git 的简单操作，适合初学者入门：\n初始化仓库 git init：在当前目录创建一个新的 Git 仓库。 克隆仓库 git clone [url]：克隆一个远程仓库到本地。 添加文件到暂存区 git add [file]：将指定文件添加到暂存区。 git add .：将当前目录下的所有更改添加到暂存区。 提交更改 git commit -m “[message]\"：将暂存区的更改提交到仓库，并附带一条提交信息。 查看状态 git status：查看当前仓库的状态，包括未跟踪的文件、已修改的文件等。 查看差异 git diff：查看工作区与暂存区之间的差异。 git diff –staged：查看暂存区与最后一次提交之间的差异。 查看提交历史 git log：查看提交历史。 git log –oneline：以简洁格式查看提交历史。 分支操作 git branch：列出所有本地分支。 git branch [branch-name]：创建一个新分支。 git checkout [branch-name]：切换到指定分支。 git checkout -b [branch-name]：创建并切换到新分支。 合并分支 git merge [branch-name]：将指定分支合并到当前分支。 推送到远程仓库 git push [remote] [branch]：将本地分支的更改推送到远程仓库。 git push -u [remote] [branch]：将本地分支推送到远程仓库，并设置为默认上游分支。 拉取远程仓库的更改 git pull [remote] [branch]：从远程仓库拉取更改并合并到当前分支。 撤销操作 git checkout – [file]：撤销工作区中文件的更改。 git reset HEAD [file]：将文件从暂存区撤出。 git revert [commit]：创建一个新的提交，撤销指定提交的更改。 标签 git tag [tag-name]：创建一个轻量级标签。 git tag -a [tag-name] -m “[message]\"：创建一个带注释的标签。 git push [remote] [tag-name]：将标签推送到远程仓库。 查看远程仓库 git remote -v：查看远程仓库的详细信息。 配置 git config –global user.name “[name]\"：设置全局用户名。 git config –global user.email “[email]\"：设置全局用户邮箱。 这些操作是 Git 的基础，适合日常使用。随着你对 Git 的熟悉，可以学习更高级的功能，如变基（rebase）、 stash、子模块等。"},"title":"轻量化使用为目的的Git简单命令行操作教程"},"/docs/":{"data":{"":"这里是所有我参与编写的文档，其中包含项目说明、语法标准、文档翻译等内容，可以查看通过下方选项点击跳转\nBeepMusic开发者支持\rDCC语法与使用说明\rFTXUI文档简中翻译\rPaper Lily简中社区\r研究性学习报告"},"title":"文档汇总"},"/docs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E4%B8%8E%E9%80%89%E7%94%A8/":{"data":{"":"编写：xiaoditx\n校对：马赫阳","1-c语言的诞生#1. C语言的诞生":"1972年，贝尔实验室的丹尼斯·麦卡利斯泰尔·里奇在开发UNIX操作系统时创造了C语言。这是一种与汇编相比更加贴近自然语言的语言，与汇编语言相比具有更强的可读性。\n下面是一段经典的输出Hello World的代码，这几乎是每个学习C语言开发的人所经历的共同的第一课。\n#include int main() { printf(\"Hello, World!\\n\"); return 0; } 这五行内容，完成了一个工作：在控制台上输出一串文本\n有人可能觉得这是一项简单的事情，认为C语言仅此而已，并没有什么伟大的意义，那这就大错特错了，我们来看一眼汇编语言的相同功能的实现吧：\ndata segment ;数据段 string db 'Hello,World!$' data ends code segment ;代码段 assume cs:code,ds:data start: mov ax,data ;获取段基址 mov ds,ax ;将段基址送入寄存器 mov dx,offset string mov ah,9 int 21h mov ah,4ch int 21h code ends end start 想要写出这么一串汇编代码，起码需要知道的知识有：寄存器的概念、代码段是什么、数据段是什么、基址是什么、汇编的诸多语法，多数的汇编语言教材写过五十多页依然需要外部软件辅助否则不能在软件层面上看到一点效果，C语言明显的就好多了\n对于C语言的那几行，大多数教程几乎不超过一千字：什么是头文件，什么是主函数，这些概念都很简单，讲讲就能明白\n因此C语言的有点就是如下所示的几条：\n从软件层面而非硬件层面出发，降低学习成本 原生支持大量操作，简化书写，便于阅读 当然，缺点也是有的，当我们使用gcc -S -masm=intel m.c -o m.s命令编译程序时，可以看到编译器将C代码翻译成了这样的内容：\n总共是三十行整，那么我们这里用通常的写法写出等效的汇编代码：（输出内容多了个词但是不影响）\n纯汇编的版本只用了十五行，也就是说，编译器多写了一倍，只是实现了相同的效果，事实上，这种差异在编译后期更加明显，通常的gcc编译程序在链接阶段需要连接一些库文件，最终成品有时比纯汇编大了几十倍都有可能。\n这便是C语言的缺点所在，使用结果上的“多写”换来了过程上的“少写”，究其原因还是因为模板化，以这里的输出为例，我们要输出的内容是文本，使用了printf函数，但这个函数也能输出整数、浮点数等，为了保证普适性，编译器不得不都把适配其他数据类型的代码也写进了编译后的文件，但实际上有的功能我们并不会用到。\ntips：笔者其实对C没什么好感，抛开内存泄漏的问题，过程语言本身就不是那么方便，有时用C++写软件不得不用上C的语法，说实话，真是够麻烦的（听说目前的GCC编译器还是用C++写的，挺好笑的）","1-易语言#1. 易语言":"编程语言一直发展，延伸到了中国，2000年，一款中文编程语言横空出世，采用表格编程，同样为解释运行，使用简单的中文进行软件开发，这就是易语言：\n.如果（用户输入==\"你好\"）\r输出框.显示（\"你好，世界！\"）\r.否则\r输出框.显示（\"无法识别\"） 与其他编程语言不同，易语言的第一课直接就是窗口的开发，软件开发周期短、中文学习编程难度低，一瞬间吸引了很多人前来\n下面是一张易语言的代码编写页面的截图：\n易语言优点如下：\n降低英语门槛 简化开发，加速开发效率 强大的官方组件，涵盖各方面内容 缺点也是有的：\n仅限于Windows平台 缺乏开源生态 仅支持三十二位编译，运行效率不足","1简洁的语法#1.简洁的语法":"1989年，吉多·范罗苏姆设计的Python将代码可读性推向极致，通过使用极其接近自然语言的语法，python的上手难度大大减小，大量编程初学者纷纷涌来学习\n下面是一个python输出Hello World的示例程序：\nprint(\"Hello World\") 仅仅一行，python便可以完成输出，这就体现出了它的一大特色：简洁，python对于在它先前的语言一些冗长的内容进行了化简，使得开发者得以聚焦于真正的算法而非功能实现。","2-c新生#2. C++新生":"C语言确实很强大，但这并不意味着人们就已经满足于C语言的开发效率，C语言仍然有些不尽如人意的地方：C语言是一种过程语言，代码复用率不够，因为自身设计问题，容易出现危险的类型转换与各种错误，同时有很高的内存泄漏风险，开发过程中，C语言的报错机制并不完善且仅在万行代码内能保证稳定的运行\n因此，在1983年，C++出现了，丹麦的本贾尼·斯特劳斯特卢普教授在C语言基础上增加类等概念，创造了所谓“支持面向对象编程”的C++，这种语言的内存泄漏率明显降低，对百万行级别的大项目也做了支持\nC++的出现无疑是里程碑式的，随着它的出现，多态、封装、对象、继承、命名空间、虚函数、模板等概念迅速流行，也使得之后的语言或多或少受其影响（如Java），将语言的抽象能力视为重中之重\n下面是c++的一些特性展示：\nclass Person { public: virtual void SenRen_BanKa() = 0; }; class DiYongJie : public Person { public: std::string play = \"YuZu soft!\" void SenRen_BanKa() override { std::cout \u003c\u003c \"Ciallo!\" \u003c\u003c std::endl; } }; 虽然增添了很多概念，但C++与C语言仍是强关联的，对于C语言的代码，C++基本上都能兼容（但是老的头文件肯定是要替换掉的），两者语言上实际上很相似：\n#include using namespace std; int main(){ cout\u003c\u003c\"Hello World\"; return 0; } 这种保留与进化并存使得C++快速成功，大型软件开发因此成为可能，至今仍广泛应用于游戏引擎、操作系统等高性能领域。","2-文言wenyan-lang#2. 文言（Wenyan-lang）":"中文编程在易语言之后兴起了一段时间，在2019年又兴起了一款名为文言的编程语言\n顾名思义，文言，就是使用文言文来编写程序，这使得其几乎变为了一种艺术形式而非编程工具：\n吾有一數。曰三。名之曰「甲」。\r為是「甲」遍。\r吾有一言。曰「「問天地好在。」」。書之。\r云云。 文言编程语言属于一种实验性的语言，用于传播文言文化与计算机文化，与chicken语言、///、glass语言、Piet语言等同样，属于是一种半艺术品，这标志着编程语言的高度发展，使得人们开始考虑探索具有一定的创造性、艺术性的分支\ntips：易语言是笔者接触的第一款编程语言，这绝对是个“新手友好型语言”，因为实在是太方便了，图形化界面下就可以完成窗口设计，以至于所有教程的第一课都是从窗口开始讲的，正因如此我才在之后觉得其它语言的GUI创建极为麻烦","2强大的标准库#2.强大的标准库":"将Python与C++相比，一个不争的事实是，C++的int型变量只能存储-2,147,483,648~2,147,483,647之间的内容，即使是最长的long long型变量，都只能表示-9,223,372,036,854,775,808~9,223,372,036,854,775,807的内容，而python的int变量却无任何限制，可以存储任意大小的数据而不溢出。\n上面说到的差异，我们带入实际开发中，对比一下C++和python的高精计算就能明白，算法平台洛谷上有一道题目：求1到n的阶乘之和，我们来看看python的答案：\nn=int(input()) ans=0#最终答案存储 rec=1#阶乘累加的变量 for i in range(1,n+1): rec*=i ans+=rec print(ans) 几行就搞定了，这是个很简单的题目，对吧？\n可是洛谷上标的难度还是相对不小的，为什么呢？下面来看C++代码就能明白了：\n#include #include using namespace std; struct bigint { int len, nm[1000]; // 使用结构体模拟大整数 bigint() { // 无参数的初始化 len = 0; // 初始长度为0 memset(nm, 0, sizeof(nm)); // 初始化为0 } bigint(int num) { // 用int初始化 memset(nm, 0, sizeof(nm)); len = 0; do { nm[len++] = num % 10; num /= 10; } while (num); } int operator[](int idx) const { // 返回对应位的值 return nm[idx]; } void process() { // 处理进位 int carry = 0; for (int i = 0; i \u003c 1000; ++i) { nm[i] += carry; carry = nm[i] / 10; nm[i] %= 10; } zero_processing(); } void zero_processing() { // 重置长度 len = 0; for (int i = 999; i \u003e= 0; --i) { if (nm[i] != 0) { len = i + 1; break; } } if (len == 0) len = 1; // 处理全0的情况 } void print() { // 输出 for (int i = len - 1; i \u003e= 0; --i) cout \u003c\u003c nm[i]; } }; bigint operator+(const bigint\u0026 a, const bigint\u0026 b) { bigint c; for (int i = 0; i \u003c max(a.len, b.len); ++i) c.nm[i] = a[i] + b[i]; c.process(); return c; } bigint operator*(const bigint\u0026 a, int b) { bigint c; for (int i = 0; i \u003c a.len; ++i) c.nm[i] = a[i] * b; c.process(); return c; } int main() { int n; cin \u003e\u003e n; bigint ans(0), tmp(1); for (int i = 1; i \u003c= n; ++i) { tmp = tmp * i; ans = ans + tmp; } ans.print(); return 0; } C++写这一题是异常的长，这就是因为这一题数据计算结果会很长，C++需要使用模拟算法来防止结果溢出，而python本身就有一套模拟机制，无需用户自行编写。","3-特点对比#3. 特点对比":"特性 C C++ 编程范式 过程式 多范式 内存管理 手动 手动+智能指针 标准库大小 精简 庞大 命名空间管理 缺乏 完善 头文件包含机制 原始 改进 应用场景 嵌入式系统 大型商业软件 tips：由于C++在保留了大量C风格的操作的同时加入了优秀便捷的标准库，有时C++甚至被算法界戏称为\"C with STL\"","python的优势#python的优势":"从定义上讲，python是个解释型语言，具有和Java一样的灵活性和高可移植性，而作为一个脚本语言，python又更擅长于数据计算等自动化工作，因此被广泛应用于大语言模型、网络爬虫中。\npython的优点如下：\n标准库功能强大，操作简洁 开源社区持续维护 第三方库丰富 解释型语言调试省时 tips：近几年有人把python喷得一无是处，认为解释型语言运行效率奇低，我只能说各有各的好处，就比如说python可以在信息技术必修一就讲解TK这个窗口库，而C++还要自己在MSDN中摸爬滚打找文档（亲身经历）","一编程语言的诞生#一.编程语言的诞生":"人类是懒惰的，自古便是如此，东汉时期，一种名为提花机的东西被广泛运用，这种物件最早可以追溯到商代，它与它所处的时代几乎是格格不入的，是它的功能：\n花本式提花机出现于东汉，又称花楼。它用线制花本贮存提花程序，再用衢线牵引经丝开口。花本是提花机上贮存纹样信息的一套程序，它由代表经线的脚子线和代表纬线的耳子线根据纹样要求编织而成。\n借助客观物件记录程序以节省精力，提花机，在东汉之时，悄然埋下了一颗超前于时代的种子，随着丝绸之路被打通，提花机流入欧洲，在一代代工人、物理学家、数学家手下，逐渐生根发芽，长成了名为\"计算机技术“的参天大树。","七中文互联网的探索#七.中文互联网的探索":"","三汇编语言程序员们对自然语言的第一次追逐#三.汇编语言：程序员们对自然语言的第一次追逐":"既然机器语言那么难写，那该怎么办呢？程序员们想了个办法：既然直接跟机器\"聊天\"有些困难，那我找个翻译不就好了？于是汇编语言便诞生了。\n百度百科这么定义汇编语言：\n汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。\n简单来说，汇编语言就像是一个万能的翻译官，这位\"翻译官\"制定了一种语言，当你需要和任意一个机器\"对话\"时，只要找到这位\"翻译官\"，对着他说出它制定的那套语言，他就可以根据情况用不同的表述转述给机器\n举个例子，A机器规定0000是加法运算，B机器规定1010是加法运算，此时，汇编语言规定了加法运算就是+,那么我们写程序时只要写+就行了，汇编语言针对A机器，会传述给它0000，而对于B机器则是1010\n正因汇编语言这种“因人而异”的翻译，在一定程度上解决了机器语言对机器的强依赖性问题，同时，通过诸如把0000变到+的操作，使得编写程序更加直观、更好记忆（1 0000 2好记好写还是1+2更加方便呢？这是很明显的吧）\n因此，汇编语言有时也被称作助记符，也就是辅助记忆的文本的意思，参照如下定义：\n助记符（mnemonic）是便于人们记忆、并能描述指令功能和指令操作数的符号，助记符是表明指令功能的英语单词或其缩写。\n汇编的引入使得记忆不再枯燥且难以理解，比如有MOV、ADD、CALL等命令，只要稍微有些英语基础就可以很好的理解，也就能比二进制更加快速的记住了。\n考虑到不同设计的机器之间有一些不可忽视的不同，汇编也衍生出了不同的版本，诸如IBM PC汇编、ARM汇编、GNU ASM、MASM、NASM等等，这里不去展开。\n这里引用一篇文章中对汇编语言的评价：\n汇编语言的出现，让程序员们从繁琐的二进制编程中解放出来，能够更加专注于程序的逻辑和功能实现，为计算机软件的发展奠定了重要基础\n总的来说，汇编语言就是让人达到\"知其然而不知其所以然\"的状态，着对于计算机技术的学习在大多数时候实际上是个好的状态，因为这样就可以摆脱繁琐的底层原理，当想用计算机解决某个问题时，就能去直接想使用怎么样的算法，而不是先看看机器的底层架构是如何的。\ntips：笔者非常喜欢汇编语言，它贴近底层，是打破计算机科学底层大门的钥匙，这是极具挑战性的语言，也是最能学到软件运行原理的语言","九选择建议#九.选择建议":"我们研究得出，编程语言各有所长，语言选取，应当针对自己的需求合理搭配，考虑开发效率与应用场景，下面有一些推荐的搭配方案\n底层开发\n推荐：C/Rust/少量汇编 场景：操作系统、嵌入式系统 优点：贴近底层，可以编译为多种形态 快速开发\n推荐：Python/JavaScript/少量shell/易语言 场景：Web应用、数据分析 优点：现成函数，高效开发 跨平台需求\n推荐：Java/Kotlin/QT框架 场景：企业级应用、移动开发 优点：跨平台，好移植 学术研究\n推荐：Python/Julia 场景：科学计算、机器学习 优点：简化代码，不让写代码成为累赘 兴趣驱动\n尝试：文言/易语言 价值：理解编程本质，培养计算思维 选取编程语言是，以下内容是关键考量维度：\n项目性能要求：高性能需求坚决不找高级语言，专业计算尽量不找低级语言 团队技术栈现状：根据团队成员的技能决定 社区生态成熟度：社区是开发的支柱，Rust社区就是典型的案例，良好成熟的社区是总能在各处帮助到每一位开发者 个人学习曲线：根据个人的学习计划选择","二第一代编程语言机器语言#二.第一代编程语言——机器语言":"人类和机器第一次”交流\"，借助的，是机器语言，这是一种只由单纯的0与1构成的\"语言\"，这便是定义上的第一代计算机语言了\n零和一的世界，是计算机的最底层的“本质”，因此足够基础，足够复杂，书写效率也相对较低，下面有一小段机器语言代码，大家可以感受一下\n二进制表示： 10001011 01000101 00000100 01011011 10001001 11000011 十六进制表示： 8b 45 04 5b 89 c3 可以明显看出，零和一的混搭使得代码内容难以辨认，因此人类也很难凭借所谓肌肉记忆之类的东西快速识别。\n实际上，上面的一大串内容，甚至不足以支撑一个简单的加法运算，假如现在我们不小心写错了一个字符：\n错误的： 10001011 01000101 00000100 01011011 10001101 11000011 正确的： 10001011 01000101 00000100 01011011 10001001 11000011 有人可以做到一眼看出哪个是错的吗？大概是没有的。机器语言实现加法最起码需要三行内容，三行之内，纠错难度都尚且如此之高，实际使用用于软件开发时困难可想而知。\n这就引出了机器语言的优点与弊病：\n优点如下\n最接近底层，运行足够快 机器可以直接识别运行，无需辅助的程序 不会出现多余无用的内容（程序体积小） 缺点如下：\n记忆难度大 直面底层，学习难度大 对于机器的依赖性强，一种机器一种结构，难以移植 只有0、1，容易写错且纠错困难 不禁想到了王爽在《汇编语言》中此般描述：\n书写和阅读机器码程序不是一件简单的工作，要记住所有抽象的二进制码。上面只是一个非常简单的小程序就暴露了机器码的灰色难懂和不易查错。写如此小的一个程序尚且如此，实际上一个有用的程序至少要有几十行机器码，那么，情况将怎么样呢？","五java实现跨平台梦想#五.Java：实现跨平台梦想":"高级语言诞生一段时间后，互联网蓬勃发展，但当时仅仅依赖着HTML这种标记语言来显示静态页面，所以当时访问互联网实质上就是浏览在线的word文档，这大大限制了互联网的潜能，人们很快注意到了这一点，都在寻找一种让网站动起来的手段，但早期语言对设备的要求很专一，电脑软件是坚决不能再单片机等硬件上运行的，所以人们探究的方向就变成了拥有一种技术去开发具有跨平台传播能力的软件\n在这种背景下，Sun公司推出了Java语言，伴随着\"Write Once, Run Anywhere\"的革命性理念，也就是“一次开发，多平台运行”，一经问世便迅速成功，1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0），标志着Java成为一种独立的开发工具。仅仅八个月后，就有约8.3万个网页应用了Java技术来制作\n下面是java的代码：\npublic class Main { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 实际上，java依旧保留了C/C++的很多思想，因为它本身是由Sun公司研发的Oak语言发展来的，而Oak语言，就是Sun公司为了开发单片机程序而制作的简化的C++\n由于Java在设计之初就是为了开发消费类家用电子产品软件，因此对于“可靠性”做了很多优化，因此，Java拥有如下几个有点：\n由C/C++演进，易上手，语法更简洁 移取了指针这一概念，硬件对于开发人员几乎完全黑盒，保证了软件安全性的同时还降低了学习成本 具有高可移植性 这些优点使得Java在企业级应用开发中占据主导地位，Android开发的基础语言之一，但为了可移植而带来的性能损耗也使其不适合高性能计算场景。\ntips：Java以罗嗦著称，是许多程序员调侃的点，说实话，我对Java早期的印象就是“把C++的类单独拉出来了”","八总体总结发展规律#八.总体总结：发展规律":"根据上面的几个例子，我们可以看出语言的变化特点：\n抽象层级提升\n编程语言不断的向着“抽象”发展，代码复用率逐渐提高，使得开发效率得以提高\n演进方式 ：机器指令 → 符号化 → 结构化 → 面向对象 → 函数式编程\n效率平衡演进\n开发人员们更乐意讨论开发和使用孰轻孰重\n演进方式 ：执行效率优先 → 开发效率优先 → 两者动态平衡\n领域专业化\n各个领域出现了专门性的语言，典型的如Windows系统下的.rc文件、Inno Setup的专门编写安装包的语言\n演进方式 ：通用语言 → 领域特定语言（DSL）\n语法简约化 演进方式 ：冗余语法 → 简洁表达 → 自然语言逼近（第五代编程语言探索方向）","六python简洁哲学的胜利#六.Python：简洁哲学的胜利":"","十一再版随笔#十一.再版随笔":"语言这个东西本身就是充满争议的，没有绝对的谁对谁错谁好谁坏，就像php被诸多程序员以“世界上最好的语言”来反讽，但终归还是广泛使用的，管它是什么语言，只要适合自己就是好语言。\n前一段时间看了个笑话，是C++和Python的对话，下面大致的记录一下\nC++问Python“你叫什么名字”，Python不回答，C++认为是自己不够礼貌，于是开始介绍自己，结果在说自己名字时卡壳了，因为出现了栈错误，它只能一边报错一边离开，等到C++走远了，Python这才大喊：“Python！”\n这笑话是想讲C++不好写，时不时就出错崩溃，而Python反应很慢，可能C++几百行代码都跑完了它还在入口，这个笑话做得很好的一点就是，同时阐明了C++和Python的缺点，也就是说，传达出了没有完美的语言这一概念","十后记#十.后记":"这个主题是我很久以前便想要开始研究的，借此次研究性学习得以实现，自是无比兴奋的，因而忙前忙后做了许多事情，虽然也确实添了些乱。\n作为文档的编写者，我就不如组长那般有如此身后的专业素养，和转于一个研究方向的钻劲了，只好接着自己学的不精的知识与自诩尚可的文学水平，苟且写下了这些最终呈现的文字，终究是有些惶恐，担心写下的内容存在瑕疵，如果各位读者能够发现文章中的错误，无论大小，万望可以在GitHub上的Issue中提交。","参考文献#参考文献":"川合秀实《三十天自制操作系统》| 人民邮电出版社 编程语言发展简史 作为程序员必须知道的编程语言编年史 王爽《汇编语言》| 清华大学出版社 百度百科-汇编语言 百度百科-助记符 Deep Learning - Ian Goodfellow、Yoshua Bengio、Aaron Courville 黑马程序员《网页设计与制作项目教程》（第2版） | 人民邮电出版社 从机器到智能：汇编语言的前世今生与未来 洛谷-P1009-阶乘之和 Java 张毅刚、赵光权、刘旺《单片机原理及应用》第三版 | 高等教育出版社 郭卫斌、罗勇军《算法竞赛入门到进阶》 | 清华大学出版社 MSDN-Microsoft Learn C++、C 和汇编程序\\C++语法参考 C++ reference 汪楚奇《深入浅出程序设计竞赛》 | 高等教育出版社 郁红英、王磊、武磊、李春强《计算机操作系统》（第三版） | 清华大学出版社","四高级语言的黎明cc的革命#四.高级语言的黎明：C/C++的革命":"","声明#声明":"文中“机器语言”板块中，机器语言代码由汇编代码通过Online x86 and x64 Intel Instruction Assembler实现，不确定是否存在转换问题，因此不具参考价值，只用于辅助理解机器语言的不便捷性。","序言#〇.序言":"计算机技术离不了各种编程语言，因此编程语言的发展可以在侧面上反应计算机技术的发展，编程语言的每一次演进都能见证着时代对于计算机技术的需求，可以说，编程语言的发展史，就是计算机技术的发展史。\n本研究性学习报告将从\"编程语言\"的历史着手，分析各个时代下不同语言的特征，试图窥见计算机技术的发展历程，同时，也想借此分析出究竟如何选择适合自己的编程语言。\n本文的基本结构如下：\n编程语言的史前雏形 机器语言与汇编语言 高级语言的演进路径 现代编程语言的多维发展 编程语言的发展规律与选择建议"},"title":"研究性学习综合报告"},"/docs/beepmusic/":{"data":{"beepmusic#BeepMusic":"BeepMusicV 2.1.2.0 终端版本（其实只有终端版，嘻嘻）\n跳转到开发者帮助","功能介绍#功能介绍":"一款可以将简谱转换为频率和时长的软件，转换结果可供Beep函数使用，使蜂鸣器实现奏乐效果","开发者帮助#开发者帮助":"HELPS文件夹下是项目帮助，有些教程文档（我怕我自己忘了怎么写了放进去的），其中README.md会介绍项目的整体结构、各个文件的功能","播放帮助#播放帮助":"对于连续播放短声音困难的硬件，建议使用耳机将蜂鸣器转为电脑内音，经过测试，通常的设备在播放「千本桜」（t=180）时，即使使用耳机，仍然会有声音是无法放出的，因此可以采用t=45;参数播放，录制结果后对结果加速4.2倍左右","示例#示例":"《call of silence》\n参考Call of Silence简谱，基本遵循原谱内容，在后半部分和前面的细节部分做了一定的调整\n下面是标准的速度版本：\nt=72; -6_ 3_ 3. 3_ -7. -6__ 1-. -6_ 3_ 3. 3_ 7. +1__ 3-. 6_ +3_ +3. +3_ 7. +1__ 5-. 5_ 3__ 5-. +2_ +1__ +2.. +1__. 6-. 0--- 3_ 2_ 2_ 1_ 1_ 5_ 1 -7_ 1-. 3_ 2_ 2_ 1_ 1_ 3_ 2 3_ 1-. 3_ 2_ 2_ 1_ 1_ 5_ 5_ 5_ -7_ 1-. -6_ 1_ 2 2_ 1_ 2_ 3_ 2_ 2 1. 0 0_ +1_ 7_ 3__ 6. 0_ +1_. 7_ 3__ 1. 0_ +1_ 7_ 3__ 6 6__ 7 +2__ +1. 0_ +1_ 7 3__ 6_. 0_ +1_ 7_ 3__ 1_- 0_ +1_ 7_ +1__ +2 +3_ +3_. +1_ 7- 对于外放，蜂鸣器可能会吞掉一些声音，t=45;可能更合适","简谱表示规则#简谱表示规则":"基本音符：1(do), 2(re), 3(mi), 4(fa), 5(sol), 6(la), 7(si), 0(休止符)\n前缀：调整音高，+升高八度，-降低八度（可叠加，如++5）\n后缀：\n用于调整单个音的时值\n_：减时线（每增加一个，时值减半）\n-：增时线（每增加一个，时值加倍）\n.：附点（时值增加50%，最多两个）\n~：延音线（连接相同音高的连续音符使之合并）\n速度设置：t=x;（x拍/分钟，默认60），此值为BPM值，简谱一般会提供，不提供的也有参考信息进行查询，一些专业软件也提供检测功能","自行编译方式#自行编译方式":"法一：运行根目录下的build.bat文件，该文件会在release目录下生成两个可执行文件，分别是64位和32位，前者需要安装有g++，后者需要安装有i686-w64-mingw32-g++，如果没有前者，编译不进行，没有后者，则只编译64位版本 法二：运行MakeExe.bat，生成调试版 法三：使用编辑器打开build.bat，把不想要的位数版本删掉（在文档下方，已用注释分割出）","软件操作#软件操作":"初始输出如下：\n===============================================\rC++ 简谱转Beep播放器 (增强版)\r===============================================\r当前曲谱: t=120; 1 2 3 4 5 6 7 #1 +1\r音符解析结果:\r=============================================\r记谱 频率(Hz) 时长(ms) 类型\r------------------------------------------\r1 261 500 音符\r2 293 500 音符\r3 329 500 音符\r4 349 500 音符\r5 392 500 音符\r6 440 500 音符\r7 493 500 音符\r#1 277 500 音符 (升半音)\r+1 523 500 音符\r=============================================\r控制选项:\r[P] 播放音乐 [H] 帮助文本\r[I] 自定义曲谱 [Q] 退出程序\r请选择: 其中\n按下P，播放当前乐谱 按下H，可查看帮助文本 按下I，可输入自定义曲谱 按下Q，退出软件 按下I后，如果是误触，可以输入return（大小写不敏感）来退出录入状态，原本的曲谱可以保留\n软件初次启动时会注册Ctrl+Alt+Shift+S的热键，乐曲播放时可使用此热键停止\n默认设置下，按下P会看到这样的输出：\n请选择: 播放中... (按任意键停止) Play: 1 =\u003e Freq: 261 Hz, Duration: 500ms Play: 2 =\u003e Freq: 293 Hz, Duration: 500ms Play: 3 =\u003e Freq: 329 Hz, Duration: 500ms Play: 4 =\u003e Freq: 349 Hz, Duration: 500ms Play: 5 =\u003e Freq: 392 Hz, Duration: 500ms Play: 6 =\u003e Freq: 440 Hz, Duration: 500ms Play: 7 =\u003e Freq: 493 Hz, Duration: 500ms Play: #1 =\u003e Freq: 277 Hz, Duration: 500ms Play: +1 =\u003e Freq: 523 Hz, Duration: 500ms 按任意键以继续... play表示发出声响的音符，后面跟着音符的原文是便于查找，Freq标记声音频率，Duration标记持续时间\n特殊的，如下\n0\rRest: 0 =\u003e Duration: 1000ms 对于休止符，输出Rest，Freq参数会被省略"},"title":"_index"},"/docs/beepmusic/%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/":{"data":{"1标准方案原生cout#1.标准方案（原生cout）":"1.标准方案（原生cout）使用\\033[开头m结尾，中间包裹参数\n属性代码 功能 属性代码 功能 属性代码 功能 0 重置所有属性 30 黑色 40 黑色 1 高亮/加粗 31 红色 41 红色 2 暗淡 32 绿色 42 绿色 4 下划线 33 黄色 43 黄色 5 闪烁 34 蓝色 44 蓝色 7 反转 35 品红 45 品红 8 隐藏 36 青色 46 青色","2y_print#2.y_print":"256色输出的简化包装，项目中未采用此方案，在function.cpp中予以保留，可以在其他改版中使用但不建议PR中包含此内容（虽然我知道根本不会有人给这个项目交PR🤓）\ny_print(“hello”,10); 0 = 黑色 8 = 灰色 1 = 蓝色 9 = 淡蓝色 2 = 绿色 10 = 淡绿色 3 = 浅绿色 11 = 淡浅绿色 4 = 红色 12 = 淡红色 5 = 紫色 13 = 淡紫色 6 = 黄色 14 = 淡黄色 7 = 白色 15 = 亮白色"},"title":"彩色输出"},"/docs/beepmusic/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/":{"data":{"ini结构说明#ini结构说明":"还没写","项目结构介绍#项目结构介绍":"项目结构介绍结构与文件功能\nroot/ ├── .vscode/ vscode配置文件 │ ├── setting.json │ └── tasks.json ├── head/ │ ├── function.h 封装部分常用的函数（的声明部分） │ └── mainhead.h 头文件（提供大部分cpp）+函数声明（提供main.cpp） ├── HELPS/ │ ├── Color_Print.md 彩色输出帮助 │ ├── Hot_Key.md 热键帮助 │ ├── RC_help.md resources.rc文件的一些帮助内容 │ └── README.md 项目介绍 ├── Icons/ │ ├── favicon.ico 同上级目录的icon.ico，仅名称不同 │ ├── ori.jpg 软件图标原图 │ └── result.png 软件图标透明图 ├── release/ 编译结果（使用build.bat的） │ ├── installer/ 用于放置安装包相关内容 │ │ ├── install_win_64.exe 安装包（编译结果） │ │ └── installer_creator.iss 源码（模板） │ ├── BeepMusic_release_win_x64.exe │ └── BeepMusic_release_win_x86.exe ├── src_c/ │ ├── config.cpp 配置文件读写 │ ├── function.cpp 封装功能函数的定义，简化开发（如彩色输出） │ ├── mods.cpp 菜单栏选项对应激活的函数 │ ├── play_core.cpp 存放核心解析、演奏函数 │ ├── test.cpp 测试文件（保留做纪念也可随时启用进行测试） │ └── UI.cpp UI显示（其实就是输出看起来像是UI的东西） ├── tools/ │ └── XD开发工具-T1 │ ├── 开发工具.exe 热键查询+鼠标查询工具（之前用易语言写的小玩意） │ ├── 源码.e 程序源码，遵守本仓库协议开源 │ ├── iext.fnr 支持库文件 │ └── krnln.fnr 支持库文件 ├── 备忘.txt 更新备忘录，记录需要的功能等 ├── BeepMusic_alpha.exe 开发调试版本的编译结果 ├── build.bat 编译最终版本用的批处理，该批处理会同时编译resources.rc ├── icon.ico 软件图标 ├── LICENSE 开源协议 ├── main.cpp 主函数放置的文件，编译在此处进行 ├── MakeExe.bat 生成调试版用的批处理，不使用VScode的开发者可以借此编译 ├── README.md 本项目的readme └── resources.rc 资源文件，放置图标信息、软件信息"},"title":"文件结构"},"/docs/beepmusic/%E7%83%AD%E9%94%AE%E6%B3%A8%E5%86%8C/":{"data":{"热键注册帮助#热键注册帮助":"热键注册帮助微软键代码查询：Virtual-Key 代码\n键代码查询工具：本地路径./tools/XD开发工具-T1，仅支持10进制查询"},"title":"热键注册"},"/docs/beepmusic/rc%E6%96%87%E4%BB%B6%E5%B8%AE%E5%8A%A9/":{"data":{"":"在 Windows 资源文件 (.rc) 中，这些关键字用于定义可执行文件的版本信息结构，以下是详细解释：","信息块解析#信息块解析":"BLOCK \"StringFileInfo\"\n作用：包含所有语言特定的字符串信息 结构： BLOCK \"StringFileInfo\"\rBEGIN\rBLOCK \"\" // 如 \"040904B0\"\rBEGIN\rVALUE \"Key\", \"Value\" // 实际显示的版本信息\rEND\rEND BLOCK \"VarFileInfo\"\n作用：定义文件的翻译信息（语言和代码页） 结构： BLOCK \"VarFileInfo\"\rBEGIN\rVALUE \"Translation\", , END 示例：VALUE \"Translation\", 0x0804, 1200 表示简体中文 Unicode","关键概念说明#关键概念说明":"部分 功能 典型值 文件属性区 定义二进制特性 FILEFLAGSMASK 有效标志位掩码 VS_FFI_FILEFLAGSMASK FILEFLAGS 实际版本标志 0x0L (正式版) FILEOS 目标操作系统 VOS_NT_WINDOWS32 FILETYPE 文件类型 VFT_APP (应用程序) FILESUBTYPE 文件子类型 VFT2_UNKNOWN 字符串信息区 用户可见信息 StringFileInfo 多语言字符串容器 语言标识 “080404B0” (简体中文) 变量信息区 语言配置 VarFileInfo 语言定义容器 Translation 默认语言设置 0x0804, 1200","工作流程#工作流程":"系统先读取 VarFileInfo 确定默认语言 在 StringFileInfo 中查找匹配的 LangID+CodePage 块 显示对应语言的字符串信息 文件属性区 (FILEOS等) 提供系统级元数据 ⚠️ 注意：当修改语言时，必须同步更新：\nStringFileInfo 中的语言块 ID (如 080404B0) VarFileInfo 中的 Translation 值 实际字符串内容（如需本地化） Windows 资源文件(.rc文件) 关于资源文件","核心结构解析#核心结构解析":"FILEFLAGSMASK\n作用：指定哪些位在 FILEFLAGS 字段中是有效的 值：通常设置为 VS_FFI_FILEFLAGSMASK（预定义值 0x3FL） 含义：表示只检查 FILEFLAGS 的低 6 位 FILEFLAGS\n作用：描述文件属性标志 常用值： 0x0L：正式版 VS_FF_DEBUG (0x1L)：调试版本 VS_FF_PRERELEASE (0x2L)：预发布版 VS_FF_PATCHED (0x4L)：已修补版本 VS_FF_PRIVATEBUILD (0x8L)：私有构建 示例：0x0L 表示标准发布版本 FILEOS\n作用：指定文件支持的操作系统 常用值： VOS_NT_WINDOWS32：Windows NT 32 位系统 VOS__WINDOWS32：通用 Windows 32 位 VOS_DOS_WINDOWS16：Windows 3.x 16 位 FILETYPE\n作用：定义文件类型 常用值： VFT_APP：应用程序 (EXE) VFT_DLL：动态链接库 VFT_DRV：设备驱动 VFT_FONT：字体文件 VFT_VXD：虚拟设备驱动 FILESUBTYPE\n作用：当 FILETYPE 需要细分时指定子类型 对 VFT_APP：必须设为 VFT2_UNKNOWN（无子类型） 对 VFT_DRV：可指定打印机/键盘等子类型 对 VFT_FONT：可指定矢量/位图字体"},"title":"rc文件帮助"},"/docs/covi%E3%81%AE%E6%8A%80%E6%9C%AF%E7%A5%9E%E6%AE%BF/":{"data":{"":"2025年10月8日第一次修订","第一条制定依据#第一条——制定依据":"本规定的制定，遵守《中华人民共和国宪法》以及相关法律法规。","第七条限制宣传#第七条——限制宣传":"在未经过群主或管理员允许的情况下，发布以盈利为目的广告、与群聊讨论内容无关的文件、文本、网址等且造成五名以上群成员明确表示反感的，一律踢出群聊并拉入黑名单。","第三条处罚方式#第三条——处罚方式":"根据违反的规则不同、造成影响的程度不同等因素，将对违反规定者做出以下几种中一个或多个的惩罚：\n一分钟到一个月不等的禁言 解除管理员身份 口头教育 警告 严重警告 踢出群聊 踢出群聊并拉入黑名单 举报至QQ官方 举报至国家有关部门 其中，踢出群聊的处罚措施允许成员加回，用于群聊等级的清空","第九条不服教导#第九条——不服教导":"违反规定后，在管理员或群主教导下表示不服并拒不认错的，应当加重处罚。","第二条规定适用范围#第二条——规定适用范围":"凡是加入本群者，均代表认同此规定且愿意遵守这一规定，任何群员不得以任何理由违反群规定，否则将受到相应的处罚。","第五条刷屏内容#第五条——刷屏内容":"同一人使用大量无用、重复的信息连续无间断的发送，或者使用特殊技术手段使得图片等内容占据很长一段空间的，一律予以一个小时以上禁言，屡教不改者，当加重处罚。","第八条管理员的废除和处罚#第八条——管理员的废除和处罚":"管理员因为个人情感等因素不按照规定给予群成员处罚或对应违规行为处理不妥当的，应调整对于事件的处理结果并给予口头警告，两次以上的，应撤去管理员身份。\n管理员违反群聊规定的，应撤去管理员身份并接受在普通处罚的基础上加重一级的处罚。\n管理员在处理群内事务时，对他人恶语相向，使用明显拥有侮辱性、攻击性的词汇时，应当撤去管理员身份；阴阳怪气、态度恶劣的，将规劝其改正态度，再次出现此类情况时，将撤去管理员身份。","第六条破坏和谐#第六条——破坏和谐":"进行地域歧视、种族歧视或进行恶意的人身攻击、嘲讽等不利于群内团结的行为的，一律予以一天以上禁言，严重或屡教不改者，当加重处罚。","第十一条预处理措施#第十一条——预处理措施":"在遇到可能或确定存在违规的行为并且群聊内较为混乱的情况下，管理员或群主可以临时设置全体当事人一个小时的禁言，在此期间内，所有在线的管理员与群主一同判断是否违规或应当适用那种处罚措施，在商讨完毕后方可进行调整。","第十条主动认错#第十条——主动认错":"违反规定后，在管理员、群主或其他群成员劝说下主动认错、道歉的，应当减轻处罚，未被教导主动道歉的，将减轻两级，可以以此减到无处罚状态。","第四条不适宜内容的处理#第四条——不适宜内容的处理":"在群内发布明确违反国家法律法规规定的内容（包括但不限于涉及黄、赌毒；非法公开户籍信息；辱骂烈士）的，一律踢出本群并拉入黑名单，同时举报至国家相关机关。\n交流时明显谈及时事政治相关的敏感话题并且引起多于二十五条消息参与讨论的，予以一天以上禁言，屡教不改者，当加重处罚。\n由于界定难度，相关内容是否不宜发出将由群主与管理员共同判断，目前明确不允许的是：散播政治谣言、分裂国家言论和未经核实的重大事件","管理须知处罚如何加重#管理须知：处罚如何加重":"2025.10.8第一编\n对于标记了“屡教不改者，当加重处罚”或“严重屡教不改者，当加重处罚”的条目和满足本规定第十条或第十一条规定的，加重或减轻的依据为如下列表的顺序：\n禁言一分钟（或以上）\n禁言五分钟（或以上）\n禁言一小时（或以上）\n禁言十二小时（或以上）\n禁言一天（或以上）\n禁言十天（或以上）\n禁言一个月（29天23小时59分钟）\n踢出群聊并拉入黑名单\n初犯时采用触犯的规定中明确的方式和时长进行处罚，下一次违规则以原条目处罚的下一条处置，以此类推。额外的加重意为在此基础上再向下一条使用，减轻则反之，加重和减轻是可叠加的。\n每次进行禁言处置，应在当前条以上，下一条以下进行选择，超出范围将视为管理员失职。\n对于同时违反多项规定的，将采用累计的方式，统计应适用的禁言的时长和，当起始时间相加超过一个月（29天23小时59分钟）则整合为踢出群聊并拉入黑名单并执行。"},"title":"_index"},"/docs/dcc-script/":{"data":{"":"DCC是一款简单的编程语言，语法上是仿照汇编设计的，所以你甚至可以通过汇编模块将纯汇编代码引入你的程序\n设计理念上讲，DCC不仅学习了汇编的风格，还吸收了C++与易语言的部分思想，如面向对象编程、中文编程、多态等等，调和了高级语言和低级语言的差异，为各种编程问题提供了独特的解决方案\n实际上，DCC是为了简化纯文字游戏开发而制作的，因此，其官方库尤为适合制作纯文字游戏，尤其是利用控制台的纯文字游戏\n基础语法\r高级语法"},"title":"DCC script"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/":{"data":{"":"下面将介绍DCC的基本语法和思想，使用基础语法，你几乎可以使用DCC的所有功能来编写纯DCC程序，可以编写出简单的控制台程序、模块文件\n函数调用\r特殊函数\r数据类型\r敏感性\r常量\r数值/逻辑运算符\r注释\r优先级\r缩进"},"title":"基础语法"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%BC%98%E5%85%88%E7%BA%A7/":{"data":{"":"DCC改变符号优先级，对于函数调用，在一个参数的位置，可以使用（）或()包裹一个语句，这个语句的执行结果会成为这个参数位的值，括号的包裹内，一定是函数名+参数（参数可空）的形式\n例子：\n；普通语句\r输出 “1”\r；嵌套语句\r输出 （转到文本 (取整 3-2)）"},"title":"改变优先级"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/":{"data":{"":"DCC程序的骨架就是函数，纯DCC程序不含缩进，因此函数名会整齐的排列在左侧\n程序中，标准的函数调用是这样写的：\n函数名 [参数1][,参数2][,参数3][,......] 参数是可省略的，但针对指定个参数的函数，对应数目的逗号需要要保留，下面列出来的几个语句都是合法的：\n输出 ,\r输出 \"你好\",\r输出 \"你好\",1 函数名支持使用一切Unicode字符定义，因此可以包含多种语言"},"title":"函数调用"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%B8%B8%E9%87%8F/":{"data":{"":"DCC拥有系统常量和自定义常量，使用时需使用#进行表达，如下面的示例：\n#asm\r#iostream\r#cpp\r#换行符\r#逻辑型 实际使用效果：\n定义变量 #大数,20"},"title":"常量"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%8F%E6%84%9F%E6%80%A7/":{"data":{"":"DCC对大小写敏感但对符号不敏感，例如，Get和GET对于DCC而言是两个函数，但[]和【】甚至【]对于DCC是同一个符号，下面以引号为例：\n；合法的引号：\r“你好”\r\"你好\"\r“你好\"\r\"你好”\r”你好“\r“你好“\r”你好”\r”你好\"\r\"你好“"},"title":"敏感性"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E5%80%BC%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/":{"data":{"":"DCC支持运算符号如下：\n*\r×\r/\r÷\r%\r+\r-\r！\r!\r\u0026\r^\r\u0026\u0026\r||\r^^\r**\r~\r\u003e\u003e\r\u003c\u003c\r|\rand\ror\rnot\r且\r或\r非"},"title":"数值/逻辑运算符"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/":{"data":{"":"DCC原生支持数据类型包括整数型、小数型、双精度小数型、逻辑型、文本型、大数等数据类型，对于常数的表达，DCC也有相应的符号来描述常数的数据类型\n对于数字，直接写出即可，是否小数会根据前后的代码智能判断，对于文本型，使用全角或半脚引号包裹（参见敏感性章节的示例），对于真、假、true、FALSE（不区分大小写）这四个关键字，则认为是逻辑型数据（布尔型）"},"title":"数据类型"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Ben/":{"data":{"":"DCC原生支持数据类型包括整数型、小数型、双精度小数型、逻辑型、文本型、大数等数据类型，对于常数的表达，DCC也有相应的符号来描述常数的数据类型\n对于数字，直接写出即可，是否小数会根据前后的代码智能判断，对于文本型，使用全角或半脚引号包裹（参见敏感性章节的示例），对于真、假、true、FALSE（不区分大小写）这四个关键字，则认为是逻辑型数据（布尔型）"},"title":"数据类型"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%B3%A8%E9%87%8A/":{"data":{"":"DCC使用全角或半角的分号来书写注释，如下：\n；注释\r;注释 出现这种注释标记，从标记后面一直到这一行的结束都是注释内容，内容不会生效也不会编译进程序\n有时，为了灵活的嵌套，DCC还会支持收尾包裹式的注释，使用@或/**/标记首尾，从第一个标记到下一个标记之间的内容都是注释，@符号（仅限@）在文本常量中出现不会被视为注释的标记\n“这是文本@这还是文本”@这里是注释@\"这里不是注释\"\r“你好，@这里是文本，不会成为注释@，你好”\r输出@注释@ （转到文本 3@这也是注释@）\r/*这种注释和C语言的性质相同*/ 上面这两种注释是支持多行的"},"title":"注释"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/":{"data":{"":"DCC拥有一些特殊函数会特殊高亮，这些函数在编译中会被特殊处理，也是DCC的功能核心，这些功能即使不引入库也可以照常使用，而这些函数名也就成为了DCC的保留字，不允许其他任何库用作函数名\n函数名 类型 功能 如果 流程控制 判断参数是真还是假 如果结束 流程控制 标志如果彻底结束 否则 流程控制 如果的参数为假进入该分支 if 流程控制 同上“如果”，下面的英文中文都是对应的，不再做解释 else 流程控制 --- endif 流程控制 --- 计次循环 流程控制 循环开始，指定循环次数并给出变量记录 记次循环尾 流程控制 标记计次循环结束 跳出循环 流程控制 跳出当前循环，代码跳转到循环尾后 到循环尾 流程控制 到达循环尾前，进入下一次循环或者完成循环 条件循环 流程控制 根据条件决定是否循环 for 流程控制 --- endfor 流程控制 --- break 流程控制 --- continue 流程控制 --- while 流程控制 --- 定义函数 函数操作 定义一个函数 结束函数定义 函数操作 完成函数定义 def 函数操作 --- enddef 函数操作 --- 创建板块 作用域 创建一个板块，独立于整个文件 结束创建板块 作用域 结束板块的创建，示意内容全部写完 creatd 作用域 --- endcd 作用域 --- 包裹体 作用域 暂定的功能，实际功效待定 包裹体尾 作用域 暂定的功能，实际功效待定 block 作用域 --- endblock 作用域 ---"},"title":"特殊函数"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E7%BC%A9%E8%BF%9B/":{"data":{"":"DCC借助缩进理解语义\n对于纯DCC代码，不会存在缩进，缩进只在嵌套中存在（见下一节）\n下面是存DCC代码示例：\n打开剧情\r如果 （转为文本 （输入））=10\r输出 \"ciallo\"\r如果结束\r展示剧情 10"},"title":"缩进"},"/docs/dcc-script/2.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/":{"data":{"":"DCC拥有一些高级语法，这些语法会使得DCC拥有更强的互联能力，变得高度可扩展"},"title":"高级语法"},"/docs/dcc-script/2.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/%E5%B5%8C%E5%A5%97/":{"data":{"":"","c嵌套#C++嵌套":"使用+++可以包裹C++代码，这三个字符单独占一行，不允许注释\n前语句\r+++\r#include\rint main(){\rstd::cout\u003c\u003c\"hello word\";\r}\r+++\r后语局 C++代码在文件任意位置定义即可在全局中调用","json嵌套#JSON嵌套":"DCC通过一定方式是可以嵌套JSON的，因此高亮需要对JSON语法进行支持，JSON内嵌时，相对前行和后行会有缩进，具体缩进多少不会严格规定，如：\n前语句\r{\r\"name\": \"Tom\"\r}\r后语句 嵌套的JSON代码需要使用JSON语法进行高亮"},"title":"嵌套"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/":{"data":{"":"翻译版本：2025/8/27","支持的平台#支持的平台":"Linux MacOS Windows WebAssembly","特性#特性":"函数式风格。灵感来源于 1 和 React 无依赖 跨平台 简洁优雅的语法（个人观点） 键盘和鼠标导航 支持 UTF8 和 全角字符 (→ 测试) 支持动画效果。演示 1, 演示 2 支持绘图功能。演示 通过示例和教程学习 支持多种构建系统和软件包 良好的工程实践：文档、测试、模糊测试、性能测试、自动化 CI、自动化打包等","示例#示例":"#include #include #include int main() { using namespace ftxui; // 创建包含三个文本元素的简单文档 Element document = hbox({ text(\"左侧\") | border, text(\"中间\") | border | flex, text(\"右侧\") | border, }); // 创建宽度全屏、高度自适应文档的屏幕 auto screen = Screen::Create( Dimension::Full(), // 宽度 Dimension::Fit(document) // 高度 ); // 将文档渲染到屏幕上 Render(screen, document); // 将屏幕输出到控制台 screen.Print(); } 预期输出：\n┌────┐┌────────────────────────────────────┐┌─────┐ │左侧││中间 ││右侧 │ └────┘└────────────────────────────────────┘└─────┘","简介#简介":"FTXUI 是一个简单、跨平台的 C++ 库，用于构建终端用户界面！"},"title":"FTXUI中文文档"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/cpp20-modules/":{"data":{"":"此功能仍处于开发阶段，API 可能在未来的版本中发生变更。\n我们需要您的贡献来帮助改进 FTXUI 中 C++20 模块的兼容性和可用性。\n如果您遇到任何问题或有建议，请提交 Issue。\nFTXUI 实验性地支持 C++20 模块，以减少编译时间并改善代码组织。每个头文件都有一个对应的模块。\n使用 FTXUI_BUILD_MODULES 选项来构建 FTXUI 项目本身以提供 C++20 模块，例如使用 CMake 和 Ninja：\ncmake \\ -DCMAKE_GENERATOR=Ninja \\ -DFTXUI_BUILD_MODULES=ON \\ .. ninja 要使用模块，您需要兼容 C++20 的编译器、CMake 3.20 或更高版本，并使用兼容的生成器（如 Ninja）。\n注意，Makefile 生成器不支持模块。\n然后，在您自己的代码中，您可以正常使用这些模块：\nimport ftxui; int main() { auto screen = ftxui::ScreenInteractive::TerminalOutput(); auto button = ftxui::Button(\"点我\", screen.QuitClosure()); screen.Loop(button); return 0; } 注意，ftxui 是一个便捷模块，它简单地聚合了所有模块：\nexport import ftxui.component; export import ftxui.dom; export import ftxui.screen; export import ftxui.util; 您也可以根据需要仅导入特定的模块。\n要使用 CMake 正确查找和链接模块，请使用 target_link_libraries 来获取正确的编译器、链接器等标志。\ntarget_link_libraries(my_executable #...其他依赖... PRIVATE ftxui::modules )","模块列表#模块列表":"这些模块直接对应于相应的头文件，或是一组相关的头文件以提供更便捷的接口。以下是可用的模块：\nftxui ftxui.component ftxui.component.Animation ftxui.component.CapturedMouse ftxui.component.Component ftxui.component.ComponentBase ftxui.component.ComponentOptions ftxui.component.Event ftxui.component.Loop ftxui.component.Mouse ftxui.component.Receiver ftxui.component.ScreenInteractive ftxui.component.Task ftxui.dom ftxui.dom.Canvas ftxui.dom.Deprecated ftxui.dom.Direction ftxui.dom.Elements ftxui.dom.FlexboxConfig ftxui.dom.LinearGradient ftxui.dom.Node ftxui.dom.Requirement ftxui.dom.Selection ftxui.dom.Table ftxui.screen ftxui.screen.Box ftxui.screen.Color ftxui.screen.ColorInfo ftxui.screen.Deprecated ftxui.screen.Image ftxui.screen.Pixel ftxui.screen.Screen ftxui.screen.String ftxui.screen.Terminal ftxui.util ftxui.util.AutoReset ftxui.util.Ref"},"title":"C++20 模块"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/examples/":{"data":{"":"button.cpp\rbutton_animated.cpp\rbutton_in_frame.cpp\rbutton_style.cpp\rcanvas_animated.cpp\rcheckbox.cpp\rcheckbox_in_frame.cpp\rcollapsible.cpp\rcomposition.cpp\rcustom_loop.cpp\rdropdown.cpp\rdropdown_custom.cpp\rflexbox_gallery.cpp\rfocus.cpp\rfocus_cursor.cpp\rgallery.cpp\rhomescreen.cpp\rinput.cpp\rinput_in_frame.cpp\rinput_style.cpp\rlinear_gradient_gallery.cpp\rmaybe.cpp\rmenu.cpp\rmenu2.cpp\rmenu_entries.cpp\rmenu_entries_animated.cpp\rmenu_in_frame.cpp\rmenu_in_frame_horizontal.cpp\rmenu_multiple.cpp\rmenu_style.cpp\rmenu_underline_animated_gallery.cpp\rmodal_dialog.cpp\rmodal_dialog_custom.cpp\rnested_screen.cpp\rprint_key_press.cpp\rradiobox.cpp\rradiobox_in_frame.cpp\rrenderer.cpp\rresizable_split.cpp\rscrollbar.cpp\rselection.cpp\rslider.cpp\rslider_direction.cpp\rslider_rgb.cpp\rtab_horizontal.cpp\rtab_vertical.cpp\rtextarea.cpp\rtoggle.cpp\rwindow.cpp\rwith_restored_io.cpp\rborder.cpp\rborder_colored.cpp\rborder_style.cpp\rcanvas.cpp\rcolor_gallery.cpp\rcolor_info_palette256.cpp\rcolor_truecolor_HSV.cpp\rcolor_truecolor_RGB.cpp\rdbox.cpp\rgauge.cpp\rgauge_direction.cpp\rgraph.cpp\rgridbox.cpp\rhflow.cpp\rhtml_like.cpp\rlinear_gradient.cpp\rpackage_manager.cpp\rparagraph.cpp\rseparator.cpp\rseparator_style.cpp\rsize.cpp\rspinner.cpp\rstyle_blink.cpp\rstyle_bold.cpp\rstyle_color.cpp\rstyle_dim.cpp\rstyle_gallery.cpp\rstyle_hyperlink.cpp\rstyle_inverted.cpp\rstyle_italic.cpp\rstyle_strikethrough.cpp\rstyle_underlined.cpp\rstyle_underlined_double.cpp\rtable.cpp\rvbox_hbox.cpp\rvflow.cpp"},"title":"示例文件"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/ftxui/":{"data":{"ftxuicomponent#ftxui/component":"增加：\nftxui::Component：有状态的交互式组件。 内置组件：Checkbox、Input、Menu、Button。 支持键盘/光标输入和组合。 适用于交互式应用程序。\n–\u003e跳转至文档\n模块可以独立使用，也可以组合使用：screen → dom → component。","ftxuidom#ftxui/dom":"提供：\nftxui::Element：用于布局和用户界面的树形结构。 可组合和响应式的元素。 Render() 函数，用于绘制到 Screen 上。 适用于结构化和样式化的用户界面。\n–\u003e跳转至文档","ftxuiscreen#ftxui/screen":"FTXUI 分为三个模块，每个模块都构建在前一个模块之上：\nftxui/screen - 底层渲染 ftxui/dom - 布局与组合 ftxui/component - 用户交互 ftxui/screen定义：\nftxui::Screen：一个包含样式化字符的二维网格。 ftxui::Pixel：渲染的基本单位。 辅助工具，如 ftxui::Color 和 Dimension。 用于直接终端绘制和样式设置。\n–\u003e跳转至文档"},"title":"ftxui"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/ftxui/component/":{"data":{"":"ftxui::component 模块定义了产生交互式组件的逻辑，这些组件能够响应用户事件（键盘、鼠标等）。\nexamples 章节提供了一系列示例。\nftxui::ScreenInteractive 定义了渲染组件的主循环。\nftxui::Component 是指向 ftxui::ComponentBase 的共享指针。后者定义了：\nftxui::ComponentBase::Render()：如何渲染界面。 ftxui::ComponentBase::OnEvent()：如何响应事件。 ftxui::ComponentBase::Add()：在两个组件之间构建父子关系。组件树用于定义如何使用键盘进行导航。 ftxui::Element 用于渲染单个帧。\nftxui::Component 用于渲染动态用户界面，生成多个帧，并在事件发生时更新其状态。\n多个组件的图库。（演示）\n所有预定义的组件可在 “ftxui/dom/component.hpp” 中找到。\n\\include ftxui/component/component.hpp","component-catchevent#事件捕获":"由 \\ref ftxui/component/component.hpp 中的 ftxui::CatchEvent() 生成。此组件装饰其他组件，在底层组件之前捕获事件。\n示例：\nauto screen = ScreenInteractive::TerminalOutput(); auto renderer = Renderer([] { return text(\"我的界面\"); }); auto component = CatchEvent(renderer, [\u0026](Event event) { if (event == Event::Character('q')) { screen.ExitLoopClosure()(); return true; } return false; }); screen.Loop(component); ftxui::CatchEvent 也可以用作装饰器：\ncomponent = component | CatchEvent(handler_1) | CatchEvent(handler_2) | CatchEvent(handler_3) ;","component-checkbox#复选框":"此组件定义一个复选框。它是一个可以打开/关闭的单个条目。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Checkbox() 生成。\n@htmlonly\n@endhtmlonly","component-collapsible#可折叠组件":"对于用户可切换显示/隐藏的视觉元素非常有用。本质上是 ftxui::Checkbox() 和 ftxui::Maybe() 组件的组合。\nauto collapsible = Collapsible(\"显示更多\", inner_element);","component-container#容器":"","component-dropdown#下拉菜单":"下拉菜单是一个组件，打开时显示一个元素列表供用户选择。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Dropdown() 生成。","component-force-redraw#强制帧重绘":"通常，ftxui::ScreenInteractive::Loop() 负责在处理完新的事件组（例如键盘、鼠标、窗口调整大小等）后绘制新帧。但是，您可能希望响应FTXUI未知的任意事件。为此，您必须通过线程使用 ftxui::ScreenInteractive::PostEvent（这是线程安全的）发布事件。您需要发布 ftxui::Event::Custom 事件。\n示例：\nscreen-\u003ePostEvent(Event::Custom); 如果不需要处理新事件，可以使用：\nscreen-\u003eRequestAnimationFrame();","component-horizontal#水平容器":"由 “ftxui/component/component.hpp” 中的 ftxui::Container::Horizontal() 生成。它水平显示组件列表并处理键盘/鼠标导航。","component-maybe#条件显示组件":"由 \\ref ftxui/component/component.hpp 中的 ftxui::Maybe() 生成。此组件可用于通过布尔值或谓词显示/隐藏任何其他组件。\n使用布尔值的示例：\nbool show = true; auto component = Renderer([]{ return \"Hello World!\"; }); auto maybe_component = Maybe(component, \u0026show) 使用谓词的示例：\nauto component = Renderer([]{ return \"Hello World!\"; }); auto maybe_component = Maybe(component, [\u0026] { return time \u003e 10; }) 通常，ftxui::Maybe 也可以用作装饰器：\ncomponent = component | Maybe(\u0026a_boolean) | Maybe([\u0026] { return time \u003e 10; }) ;","component-radiobox#单选按钮":"单选框组件。这是一个条目列表，其中一项可以被选中。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Radiobox() 生成。\n@htmlonly\n@endhtmlonly","component-renderer#渲染器":"由 \\ref ftxui/component/component.hpp 中的 ftxui::Renderer() 生成。此组件通过使用不同的函数来渲染界面，从而装饰另一个组件。\n示例：\nauto inner = [...] auto renderer = Renderer(inner, [\u0026] { return inner-\u003eRender() | border }); ftxui::Renderer 也支持组件装饰器模式：\nauto component = [...] component = component | Renderer([](Element e) { return e | border)) | Renderer(bold) 作为简写形式，您还可以将组件与元素装饰器组合：\nauto component = [...] component = component | border | bold;","component-resizable-split#可调整分割":"定义两个子组件之间的水平或垂直分隔。分隔线的位置可通过鼠标调整和控制。有四种可能的分隔方式：\nftxui::ResizableSplitLeft() ftxui::ResizableSplitRight() ftxui::ResizableSplitTop() ftxui::ResizableSplitBottom() 来自 “ftxui/component/component.hpp” 示例：\n@htmlonly\n@endhtmlonly","component-slider#滑块":"表示一个滑块对象，它由一个带有分箱中间间隔的范围组成。可以通过 ftxui::Slider() 创建。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Slider() 生成。","component-tab#标签页容器":"由 “ftxui/component/component.hpp” 中的 ftxui::Container::Tab() 生成。它接收一个组件列表并只显示其中一个。这对于实现标签栏非常有用。\n垂直：\n水平：","component-toggle#切换按钮":"一种特殊类型的菜单。条目水平显示。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Toggle() 生成。\n@htmlonly\n@endhtmlonly","component-vertical#垂直容器":"由 “ftxui/component/component.hpp” 中的 ftxui::Container::Vertical() 生成。它垂直显示组件列表并处理键盘/鼠标导航。","菜单-component-menu#菜单 （component-menu）":"定义一个菜单对象。它包含一个条目列表，其中一项被选中。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Menu() 生成。\n@htmlonly\n@endhtmlonly","输入框componentinput#输入框（component::input）":"示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Input() 生成。\n@htmlonly\n@endhtmlonly","过滤输入#过滤输入":"可以使用 ftxui::CatchEvent 过滤输入组件接收的字符。\nstd::string phone_number; Component input = Input(\u0026phone_number, \"电话号码\"); // 过滤非数字字符。 input |= CatchEvent([\u0026](Event event) { return event.is_character() \u0026\u0026 !std::isdigit(event.character()[0]); }); // 过滤超过10个字符后的输入。 input |= CatchEvent([\u0026](Event event) { return event.is_character() \u0026\u0026 phone_number.size() \u003e= 10; });"},"title":"component（组件模块）"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/ftxui/dom/":{"data":{"dom-border#边框":"在元素周围添加边框。\n代码：\nborder(text(\"元素\")) 终端输出：\n┌──────┐ │元素 │ └──────┘ Note\n您可以使用管道操作符实现相同的行为。\n代码：\ntext(\"元素\") | border 边框还有多种样式，如下所示：\nnamespace ftxui { Element border(Element); Element borderLight(Element); Element borderHeavy(Element); Element borderDouble(Element); Element borderRounded(Element); Element borderEmpty(Element); Decorator borderStyled(BorderStyle); Decorator borderWith(Pixel); }","dom-canvas#画布":"参见 API auto c = Canvas(100, 100); c.DrawPointLine(10, 10, 80, 10, Color::Red); auto element = canvas(c); 可以在 ftxui::Canvas 上使用盲文、方块或简单字符进行绘制：\n简单示例：\n复杂示例：","dom-colors#颜色":"大多数终端控制台可以显示彩色文本和彩色背景。FTXUI 支持所有调色板：\nDecorator color(Color); Decorator bgcolor(Color); 颜色图库：","dom-colors-palette-16#16色调色板":"大多数终端支持以下颜色：\n默认色\n黑色\n深灰色\n浅灰色\n白色\n蓝色\n亮蓝色\n青色\n亮青色\n绿色\n亮绿色\n洋红色\n亮洋红色\n红色\n亮红色\n黄色\n亮黄色\n使用管道操作符应用上述颜色的示例：\ntext(\"蓝色前景\") | color(Color::Blue); text(\"蓝色背景\") | bgcolor(Color::Blue); text(\"黑底白字\") | color(Color::Black) | bgcolor(Color::White);","dom-colors-palette-256#256色调色板":"支持256色的终端。 @htmlonly\n@endhtmlonly\ntext(\"亮粉色\") | color(Color::HotPink);","dom-colors-true-color#真彩色":"支持真彩色的终端，您可以直接使用24位RGB色彩空间：\n使用以下构造函数指定颜色的RGB或HSV值：\n有两个构造函数：\nftxui::Color::RGB(uint8_t red, uint8_t green, uint8_t blue); ftxui::Color::HSV(uint8_t hue, uint8_t saturation, uint8_t value); @htmlonly\n@endhtmlonly","dom-gauge#进度条":"这是一个表示进度比例的视觉元素。\n代码：\nborder(gauge(0.5)) 终端输出：\n┌────────────────────────────────────────────────────────────────────────────┐ │██████████████████████████████████████ │ └────────────────────────────────────────────────────────────────────────────┘ 进度条可以多种方向显示，如下所示：\nnamespace { Element gauge(float ratio); Element gaugeLeft(float ratio); Element gaugeRight(float ratio); Element gaugeUp(float ratio); Element gaugeDown(float ratio); Element gaugeDirection(float ratio, GaugeDirection); }","dom-graph#图表":"@htmlonly\n@endhtmlonly\n参见：\nElement graph(GraphFunction);","dom-layout#布局":"使元素能够以以下方式排列：\n使用 ftxui::hbox 水平排列 使用 ftxui::vbox 垂直排列 使用 ftxui::gridbox 在网格中排列 使用 ftxui::flexbox 沿一个方向环绕排列。 使用 ftxui::hbox、ftxui::vbox 和 ftxui::filler 的示例。\n使用 ftxui::gridbox 的示例：\n使用 flexbox 的示例：\n查看此示例及相关的演示。\n元素也可以使用 ftxui::flex 装饰器变得灵活。\n代码：\nhbox({ text(\"左\") | border , text(\"中\") | border | flex, text(\"右\") | border, }); 终端输出：\n┌──┐┌─────────────────────────────────────────────────────┐┌───┐ │左││中 ││右│ └──┘└─────────────────────────────────────────────────────┘└───┘ 代码：\nhbox({ text(\"左\") | border , text(\"中\") | border | flex, text(\"右\") | border | flex, }); 终端输出：\n┌──┐┌───────────────────────────────┐┌───────────────────────────────┐ │左││中 ││右 │ └──┘└───────────────────────────────┘└───────────────────────────────┘","dom-linear-gradient#线性渐变":"FTXUI 支持线性渐变。可应用于前景或背景。\nDecorator color(const LinearGradient\u0026); Decorator bgcolor(const LinearGradient\u0026); ftxui::LinearGradient 由角度（度）和颜色停止点列表定义。\nauto gradient = LinearGradient() .Angle(45) .AddStop(0.0, Color::Red) .AddStop(0.5, Color::Green) .AddStop(1.0, Color::Blue); 您也可以使用简化的构造函数：\nLinearGradient(Color::Red, Color::Blue); LinearGradient(45, Color::Red, Color::Blue); 参见演示。","dom-paragraph#段落":"类似于 ftxui::text，但会根据容器的宽度将单个单词沿多行换行。\n示例代码：\nparagraph(\"一段很长的文本\") 更详细的示例请参阅详细示例。段落还包括许多其他变体，如下所示：\nnamespace ftxui { Element paragraph(std::string text); Element paragraphAlignLeft(std::string text); Element paragraphAlignRight(std::string text); Element paragraphAlignCenter(std::string text); Element paragraphAlignJustify(std::string text); }","dom-separator#分隔符":"显示垂直/水平线，以视觉上将容器的内容分成两部分。\n代码：\nborder( hbox({ text(\"左\"), separator(), text(\"右\") }) ) 终端输出：\n┌──┬──┐ │左│右│ └──┴──┘ 分隔符有多种样式，如下所示：\nnamespace ftxui { Element separator(void); Element separatorLight(); Element separatorHeavy(); Element separatorDouble(); Element separatorEmpty(); Element separatorStyled(BorderStyle); Element separator(Pixel); Element separatorCharacter(std::string); Element separatorHSelector(float left, float right, Color background, Color foreground); Element separatorVSelector(float up, float down, Color background, Color foreground); }","dom-style#样式":"除了彩色文本和彩色背景外，许多终端还支持文本效果，例如：bold（粗体）、italic（斜体）、dim（暗淡）、underlined（下划线）、inverted（反色）、blink（闪烁）。\nElement bold(Element); Element italic(Element); Element dim(Element); Element inverted(Element); Element underlined(Element); Element underlinedDouble(Element); Element strikethrough(Element); Element blink(Element); Decorator color(Color); Decorator bgcolor(Color); Decorator colorgrad(LinearGradient); Decorator bgcolorgrad(LinearGradient); 示例\n要使用这些效果，只需用所需的效果包装您的元素：\nunderlined(bold(text(\"此文本为粗体并带下划线\"))) 或者，使用管道操作符将其链接到您的元素：\ntext(\"此文本为粗体\") | bold | underlined","dom-table#表格":"能够轻松地将数据格式化为整洁的表格状视觉形式。\n代码示例：","dom-text#文本":"此模块定义了一组层次化的 ftxui::Element（元素）。元素管理布局，并且可以响应终端尺寸变化。请注意以下使用此模块创建简单布局并运用多个操作符的示例：\n@subpage module-dom-examples 章节提供了一系列示例。\n示例：\nnamespace ftxui { ... // 定义文档 Element document = vbox({ text(\"窗口\") | bold | color(Color::Blue), gauge(0.5) text(\"页脚\") }); // 通过调用 `ftxui::border` 装饰器函数添加边框。 document = border(document); // 使用管道操作符添加另一个边框。 document = document | border. // 使用 |= 操作符添加另一个边框。 document |= border ... } 元素列表\n所有元素均已包含，可通过引入相应的头文件访问：\n#include \\include{strip} “ftxui/dom/elements.hpp”\n文本最简单的控件。它显示文本。\ntext(\"我是一段文本\"); 我是一段文本。","dom-vtext#垂直文本":"与 ftxui::text 相同，但垂直显示。\n代码：\nvtext(\"你好\"); 终端输出：\n你 好","dom-window#窗口":"ftxui::window 是一个带有额外标题的 ftxui::border。要在元素周围添加窗口，请将其包装并指定一个字符串作为标题。 代码：\nwindow(\"窗口\", text(\"元素\")) 终端输出：\n┌窗口─┐ │元素 │ └─────┘"},"title":"dom（布局模块）"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/ftxui/screen/":{"data":{"ftxuicolor#ftxui::Color":"The @ref ftxui::Color class is used to define foreground and background colors for each @ref ftxui::Pixel.\nIt supports various color spaces and predefined palettes. FTXUI will dynamically fallback to the closest available color in the terminal if the requested color is not supported by the terminal.\nColor Spaces\nDefault: ftxui::Color::Default (terminal’s default color) 16-color palette Demo: ftxui::Color::Black, ftxui::Color::Red, … 256-color palette Demo: ftxui::Color::Chartreuse1, ftxui::Color::DarkViolet, … True color (24bit) [Demo](https://arthursonzogni.github.io/FTXUI/examples/?file=dom/color_truecolor_HSV: ftxui::Color::RGB(uint8_t red, uint8_t green, uint8_t blue) ftxui::Color::HSV(uint8_t h, uint8_t s, uint8_t v). Note\nYou can query the terminal capability using @ref ftxui::Terminal::ColorSupport();\nThis can manually be set using @ref ftxui::Terminal::SetColorSupport().","ftxuidimension#ftxui::Dimension":"The @ref ftxui::Dimension utility controls screen sizing:\nDimension::Full() — use full terminal width or height Dimension::Fit(element) — size to fit the rendered @ref ftxui::Element Dimension::Fixed(n) — use exactly n columns or rows These values are to be passed to ftxui::Screen::Create().\n@ref ftxui::Screen::Create() provides two overloads:\nScreen::Create(Dimension) sets both width and height to the same kind of dimension Screen::Create(Dimension width, Dimension height) allows distinct control per axis auto screen = ftxui::Screen::Create( ftxui::Dimension::Full(), // width ftxui::Dimension::Fixed(10) // height ); Once created, render an element and display the result:\nftxui::Render(screen, element); screen.Print();","ftxuipixel#ftxui::Pixel":"Each cell in the screen grid is a @ref ftxui::Pixel, which holds:\nUnicode codepoint. character @ref ftxui::Color: foreground_color background_color Booleans: blink bold dim italic inverted (swap foreground and background colors) underlined underlined_double strikethrough auto screen = ftxui::Screen::Create( ftxui::Dimension::Fixed(5), ftxui::Dimension::Fixed(5), ); auto\u0026 pixel = screen.PixelAt(3, 3); pixel.character = U'X'; pixel.bold = true; pixel.foreground_color = ftxui::Color::Red; pixel.background_color = ftxui::Color::RGB(0, 255, 0); screen.Print(); Note\nPixelAt(x, y) performs bounds checking and returns a reference to the pixel at the specified coordinate. If out-of-bounds, a dummy pixel reference is returned.\nEach cell in the screen is a @ref ftxui::Pixel. You can modify them using:\nauto\u0026 pixel = screen.PixelAt(x, y); pixel.character = U'X'; pixel.bold = true; pixel.foreground_color = Color::Red;","ftxuiscreen#ftxui::Screen":"The ftxui::screen module is the low-level foundation. It can be used standalone, but it is primarily designed to be used together by ftxui::dom and ftxui::component modules.\nIt provides a @ref ftxui::Screen.\nftxui::ScreenThe @ref ftxui::Screen class represents a 2D grid of styled characters that can be rendered to a terminal.\nIt provides methods to create a screen, access pixels, and render elements.\nYou can access the individual cells (@ref ftxui::Pixel) of the screen using the @ref ftxui::Screen::PixelAt method, which returns a reference to the pixel at the specified coordinates.\nExample\n#include #include void main() { auto screen = ftxui::Screen::Create( ftxui::Dimension::Full(), // Use full terminal width ftxui::Dimension::Fixed(10) // Fixed height of 10 rows ); // Access a specific pixel at (10, 5) auto\u0026 pixel = screen.PixelAt(10, 5); // Set properties of the pixel. pixel.character = U'X'; pixel.foreground_color = ftxui::Color::Red; pixel.background_color = ftxui::Color::RGB(0, 255, 0); pixel.bold = true; // Set bold style screen.Print(); // Print the screen to the terminal } Note\nIf the coordinates are out of bounds, a dummy pixel is returned.\nThe screen can be printed to the terminal using @ref ftxui::Screen::Print() or converted to a std::string with @ref ftxui::Screen::ToString().\nPrint() auto screen = ...; screen.Print(); ToString() auto screen = ...; std::cout \u003c\u003c screen.ToString(); Note that you can reset the cursor position to the top-left corner of the screen after printing by calling @ref ftxui::Screen::ResetCursorPosition().\nExample\nauto screen = ...; while(true) { // Drawing operations: ... // Print the screen to the terminal. Then reset the cursor position and the // screen content. std::cout \u003c\u003c screen.ToString(); std::cout \u003c\u003c screen.ResetCursorPosition(/*clear=*/true); std::cout \u003c\u003c std::flush; // Sleep for a short duration to control the refresh rate. std::this_thread::sleep_for(std::chrono::milliseconds(100)); }"},"title":"screen"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/getting-started/":{"data":{"":"","入门模板#入门模板":"要获取完整可运行的项目，请克隆官方入门仓库：\ngit clone https://github.com/ArthurSonzogni/ftxui-starter 按照该仓库 README.md 中的构建说明进行操作。","安装-ftxui#安装 FTXUI":"要在您的项目中配置FTXUI，请遵循安装指南，该指南提供了针对多种构建系统和包管理器的说明。","最小示例#最小示例":"将以下代码保存为 main.cpp：\n#include #include #include int main() { using namespace ftxui; Element document = hbox({ text(\"左侧\") | border, text(\"中间\") | border | flex, text(\"右侧\") | border, }); auto screen = Screen::Create(Dimension::Full(), Dimension::Fit(document)); Render(screen, document); screen.Print(); } 使用您喜欢的构建系统进行构建和运行。\n如果不确定如何操作，请从安装页面描述的其中一种方法开始。\n预期输出：\n┌────┐┌────────────────────────────────────┐┌─────┐ │左侧││中间 ││右侧 │ └────┘└────────────────────────────────────┘└─────┘"},"title":"开始使用"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/":{"data":{"":"","后续步骤#后续步骤":"安装 FTXUI 后：\n开始使用：编写并运行您的第一个程序 示例：了解 FTXUI 的功能 模块说明： DOM 组件 屏幕","支持的安装方式#支持的安装方式":"CMake Bazel Vcpkg Conan 手动安装 Nix Debian/Ubuntu Arch Linux openSUSE XMake","概述#概述":"FTXUI 可通过多种构建系统和包管理器集成到您的项目中。\n本页面是可用集成方法的入口指南。","贡献指南#贡献指南":"如果您使用其他构建系统或包管理器，欢迎贡献安装指南。\n您也可以在 GitHub issue tracker 中提交功能请求。"},"title":"安装指南"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/arch/":{"data":{"":"FTXUI 已在 AUR（Arch 用户仓库）中打包。使用 AUR helper安装：\nyay -S ftxui 您也可以手动从 https://aur.archlinux.org/packages/ftxui 下载 PKGBUILD。\n安装完成后，您可以在 CMake 项目中使用它，只需在 CMakeLists.txt 中添加以下内容：\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) Note\n这是一个非官方软件包。这意味着它不是由 FTXUI 团队维护，而是由社区维护。软件包维护者似乎会积极更新 至最新版本。感谢维护者的工作！"},"title":"Arch Linux"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/bazel/":{"data":{"":"FTXUI 可通过 Bazel 和 Bzlmod（Bazel 模块）集成到您的项目中。\n该库已注册到 Bazel 中央注册表\nMODULE.bazel\nbazel_dep(name = \"ftxui\", version = \"6.1.9\") BUILD.bazel\ncc_binary( name = \"main\", srcs = [\"main.cpp\"], deps = [ \"@ftxui//:component\", \"@ftxui//:dom\", \"@ftxui//:screen\", ], )","入门项目#入门项目":"您可以使用官方的 Bazel 入门项目来获得一个最小的可用设置：\nftxui-bazel (starter)"},"title":"Bazel"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/cmake/":{"data":{"":"本页面介绍如何使用 CMake 集成 FTXUI。","使用-fetchcontent#使用 FetchContent":"此方法在配置时下载 FTXUI，不需要系统级安装。\ninclude(FetchContent) FetchContent_Declare(ftxui GIT_REPOSITORY https://github.com/ArthurSonzogni/FTXUI GIT_TAG v6.1.9 # 替换为版本号、标签或提交哈希 ) FetchContent_MakeAvailable(ftxui) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) 这种方法确保可重现的构建和便捷的依赖管理。","使用-find_package#使用 find_package":"如果 FTXUI 已通过系统级安装或包管理器（如 vcpkg 或 Conan）安装，可以使用：\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) 确保包在您的 CMAKE_PREFIX_PATH 中可见。","使用-git-子模块#使用 Git 子模块":"您也可以将 FTXUI 添加为 Git 子模块，将其保留在您的代码库中：\ngit submodule add https://github.com/ArthurSonzogni/FTXUI external/ftxui git submodule update --init --recursive 当克隆已包含 FTXUI 作为子模块的代码库时，请确保使用以下命令获取子模块：\ngit clone --recurse-submodules # 或者，如果已经克隆： git submodule update --init --recursive 然后在您的 CMakeLists.txt 中：\nadd_subdirectory(external/ftxui) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) 如果您希望将 FTXUI 打包到自己的代码库中，这种方法很适用。","可选的-cmake-标志#可选的 CMake 标志":"FTXUI 支持以下 CMake 选项：\n选项 描述 默认值 FTXUI_BUILD_EXAMPLES 构建捆绑的示例 OFF FTXUI_BUILD_DOCS 构建文档 OFF FTXUI_BUILD_TESTS 启用测试 OFF FTXUI_ENABLE_INSTALL 生成安装目标 ON FTXUI_MICROSOFT_TERMINAL_FALLBACK 改进 Windows 兼容性 ON/OFF 启用选项的方法：\ncmake -DFTXUI_BUILD_EXAMPLES=ON ..","集成方法#集成方法":"","验证集成#验证集成":"要确认设置正常工作，请构建并运行一个最小示例。 如果需要完整模板，请参阅：ftxui-starter"},"title":"CMake"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/conan/":{"data":{"":"FTXUI 可以通过 Conan 包管理器方便地获取和集成到您的项目中。","cmake#CMake":"Conan 通常与 CMake 协同工作，因此您也需要安装 CMake：\nWindowsWindows (Chocolatey)Linux (Ubuntu/Debian)MacOS 访问 CMake 官网 下载 Windows 安装程序 运行安装程序，确保勾选 “Add CMake to the system PATH” 选项 choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System' sudo apt-get update sudo apt-get install cmake 这里推荐Homebrew安装，如果没有，请先安装它：\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 获取CMake\nbrew install cmake","conan#Conan":"首先，确保您的系统已安装 Conan。如果尚未安装，可以使用 pip 安装：\npip install conan","准备目录#准备目录":"当你确保拥有了Conan和CMake后，创建一个项目目录，例如ftxui-demo：\nmkdir C:\\ftxui-demo cd C:\\ftxui-demo","前置条件#前置条件":"","安装依赖并构建#安装依赖并构建":"完成后，我们运行以下命令安装 FTXUI 及其依赖项：\nconan install . --output-folder=build --build=missing 这将从 Conan 的远程仓库下载并安装 ftxui/6.0.2 及其所有依赖项。\n当安装结束后，可以尝试在项目目录下创建一个 demo.cpp 文件进行测试：\n#include #include #include int main() { using namespace ftxui; auto document = hbox({ text(\" Hello \"), text(\"FTXUI \") | bold | color(Color::Red), text(\" world! \") }); auto screen = Screen::Create(Dimension::Full(), Dimension::Fit(document)); Render(screen, document); std::cout \u003c\u003c screen.ToString() \u003c\u003c std::endl; return 0; } 如果测试顺利，我们就可以在项目目录下创建一个 CMakeLists.txt 文件了：\ncmake_minimum_required(VERSION 3.20) project(ftxui-demo) # 设置C++标准 set(CMAKE_CXX_STANDARD 20) # 查找通过Conan安装的FTXUI包 find_package(ftxui CONFIG REQUIRED) # 创建可执行文件 add_executable(demo demo.cpp) # 将可执行文件链接到FTXUI库 target_link_libraries(demo PRIVATE ftxui::component)","配置#配置":"确保环境无误后，获取conanfile.py并放置在项目目录下，你可以考虑从GitHub下载 或是从本站复制\nFTXUI 的社区维护包可在Conan Center 找到。\nNote\n这是一个非官方构建脚本。这意味着它不是由 FTXUI 团队维护，而是由社区维护。软件包维护者似乎会积极更新 至最新版本。感谢维护者的工作！\n⚠️ 如果您了解相关流程，请考虑向 Conan Center 添加一个\"官方构建脚本。 这可以是一个 GitHub Action，在发布新版本时自动更新 Conan Center。"},"title":"Conan"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/conan/conanfile/":{"data":{"":"from conan import ConanFile from conan.errors import ConanInvalidConfiguration from conan.tools.microsoft import is_msvc_static_runtime, is_msvc from conan.tools.files import apply_conandata_patches, export_conandata_patches, get, copy, rmdir, rm from conan.tools.build import check_min_cppstd from conan.tools.scm import Version from conan.tools.cmake import CMake, CMakeDeps, CMakeToolchain, cmake_layout import os required_conan_version = \"\u003e=1.53.0\" class FTXUIConan(ConanFile): name = \"ftxui\" description = \"C++ Functional Terminal User Interface.\" license = \"MIT\" url = \"https://github.com/conan-io/conan-center-index\" homepage = \"https://github.com/ArthurSonzogni/FTXUI\" topics = (\"ncurses\", \"terminal\", \"screen\", \"tui\") package_type = \"library\" settings = \"os\", \"arch\", \"compiler\", \"build_type\" options = { \"shared\": [True, False], \"fPIC\": [True, False], } default_options = { \"shared\": False, \"fPIC\": True, } @property def _min_cppstd(self): return 17 @property def _compilers_minimum_version(self): return { \"gcc\": \"8\", \"clang\": \"7\", \"apple-clang\": \"12\", \"Visual Studio\": \"16\", \"msvc\": \"192\", } def export_sources(self): export_conandata_patches(self) def config_options(self): if self.settings.os == \"Windows\": del self.options.fPIC def configure(self): if self.options.shared: self.options.rm_safe(\"fPIC\") def layout(self): cmake_layout(self, src_folder=\"src\") def validate(self): if self.settings.compiler.cppstd: check_min_cppstd(self, self._min_cppstd) minimum_version = self._compilers_minimum_version.get(str(self.settings.compiler), False) if minimum_version and Version(self.settings.compiler.version) \u003c minimum_version: raise ConanInvalidConfiguration( f\"{self.ref} requires C++{self._min_cppstd}, which your compiler does not support.\" ) if is_msvc(self) and self.options.shared and is_msvc_static_runtime(self): raise ConanInvalidConfiguration(\"shared with static runtime not supported\") def source(self): get(self, **self.conan_data[\"sources\"][self.version], strip_root=True) def generate(self): # BUILD_SHARED_LIBS and POSITION_INDEPENDENT_CODE are automatically parsed when self.options.shared or self.options.fPIC exist tc = CMakeToolchain(self) tc.variables[\"CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS\"] = True tc.variables[\"FTXUI_BUILD_DOCS\"] = False tc.variables[\"FTXUI_BUILD_EXAMPLES\"] = False tc.generate() tc = CMakeDeps(self) tc.generate() def build(self): apply_conandata_patches(self) cmake = CMake(self) cmake.configure() cmake.build() def package(self): copy(self, pattern=\"LICENSE\", dst=os.path.join(self.package_folder, \"licenses\"), src=self.source_folder) cmake = CMake(self) cmake.install() rmdir(self, os.path.join(self.package_folder, \"lib\", \"cmake\")) if Version(self.version) \u003e= \"4.1.0\": rmdir(self, os.path.join(self.package_folder, \"lib\", \"pkgconfig\")) if Version(self.version) \u003e= \"4.1.1\": rm(self, \"ftxui.pc\", os.path.join(self.package_folder, \"lib\"), ) def package_info(self): self.cpp_info.set_property(\"cmake_file_name\", \"ftxui\") if Version(self.version) \u003e= \"4.1.0\": self.cpp_info.set_property(\"pkg_config_name\", \"ftxui\") self.cpp_info.components[\"ftxui-dom\"].set_property(\"cmake_target_name\", \"ftxui::dom\") self.cpp_info.components[\"ftxui-dom\"].libs = [\"ftxui-dom\"] self.cpp_info.components[\"ftxui-dom\"].requires = [\"ftxui-screen\"] if self.settings.os in [\"Linux\", \"FreeBSD\"]: self.cpp_info.components[\"ftxui-dom\"].system_libs.append(\"m\") self.cpp_info.components[\"ftxui-screen\"].set_property(\"cmake_target_name\", \"ftxui::screen\") self.cpp_info.components[\"ftxui-screen\"].libs = [\"ftxui-screen\"] if self.settings.os in [\"Linux\", \"FreeBSD\"]: self.cpp_info.components[\"ftxui-screen\"].system_libs.append(\"m\") self.cpp_info.components[\"ftxui-component\"].set_property(\"cmake_target_name\", \"ftxui::component\") self.cpp_info.components[\"ftxui-component\"].libs = [\"ftxui-component\"] self.cpp_info.components[\"ftxui-component\"].requires = [\"ftxui-dom\"] if self.settings.os in [\"Linux\", \"FreeBSD\"]: self.cpp_info.components[\"ftxui-component\"].system_libs.append(\"pthread\") # TODO: to remove in conan v2 once cmake_find_package* generators removed self.cpp_info.components[\"ftxui-dom\"].names[\"cmake_find_package\"] = \"dom\" self.cpp_info.components[\"ftxui-dom\"].names[\"cmake_find_package_multi\"] = \"dom\" self.cpp_info.components[\"ftxui-screen\"].names[\"cmake_find_package\"] = \"screen\" self.cpp_info.components[\"ftxui-screen\"].names[\"cmake_find_package_multi\"] = \"screen\" self.cpp_info.components[\"ftxui-component\"].names[\"cmake_find_package\"] = \"component\" self.cpp_info.components[\"ftxui-component\"].names[\"cmake_find_package_multi\"] = \"component\""},"title":"conanfile.py文件"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/debian/":{"data":{"":"","debian-和-ubuntu-软件包非官方#Debian 和 Ubuntu 软件包（非官方）":"这些发行版提供了预构建的软件包。通过以下命令安装：\nsudo apt install libftxui-dev 可用的软件包包括：\nftxui-doc（文档） ftxui-examples（示例） libftxui-component\u003c版本号\u003e libftxui-dev（开发文件） libftxui-dom\u003c版本号\u003e libftxui-screen\u003c版本号\u003e 安装完成后，您可以在 CMake 项目中使用它，只需在 CMakeLists.txt 中添加以下内容：\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) Note\n这是一个非官方软件包。这意味着它不是由 FTXUI 团队维护，而是由社区维护。"},"title":"Debian/Ubuntu"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/manual/":{"data":{"":"","从源码构建官方方式#从源码构建（官方方式）":"使用 CMake 克隆并构建项目：\ngit clone https://github.com/ArthurSonzogni/FTXUI.git cd FTXUI cmake -S . -B build -DFTXUI_ENABLE_INSTALL=ON -D cmake --build build -j sudo cmake --install build Note\n注意：上述命令中的 -D 参数似乎为笔误，通常不需要单独使用 -D 参数。 正确的用法应为 -D\u003c变量\u003e=\u003c值\u003e 格式，如 -DFTXUI_BUILD_EXAMPLES=ON。\n安装完成后，您可以在 CMake 项目中使用它，只需在 CMakeLists.txt 中添加以下内容：\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component )"},"title":"手动安装"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/nix/":{"data":{"":"Note\nFTXUI 作者对 Nix 了解有限。本页面内容主要由 AI 生成。如果您有任何改进建议，请提交 PR。","nix-flake#Nix Flake":"FTXUI 提供了 flake.nix，包含软件包和开发环境。","作为依赖使用#作为依赖使用":"将 FTXUI 添加到您的 flake 输入中：\n{ inputs.ftxui.url = \"github:ArthurSonzogni/FTXUI\"; } 然后在输出中引用 ftxui.packages..ftxui。","构建库#构建库":"nix build github:ArthurSonzogni/FTXUI 构建结果可通过 result 链接访问。"},"title":"Nix"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/opensuse/":{"data":{"":"","opensuse-软件包非官方#openSUSE 软件包（非官方）":"FTXUI 似乎可从 devel:libraries:c_c++ 仓库获取。\nsudo zypper addrepo https://download.opensuse.org/repositories/devel:libraries:c_c++/openSUSE_Leap_$releasever/devel:libraries:c_c++.repo sudo zypper install ftxui 详情请参阅 https://build.opensuse.org/package/show/devel:libraries:c_c++/ftxui。\nNote\n这是一个非官方软件包。这意味着它不是由 FTXUI 团队维护，而是由社区维护。\nNote\nFTXUI 作者对 openSUSE 了解有限。本页面内容主要由 AI 生成。如果您有任何改进建议，请提交 PR。"},"title":"openSUSE"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/vcpkg/":{"data":{"":"","vcpkg-软件包#Vcpkg 软件包":"FTXUI 可在 Vcpkg 注册表 中获取。\n要使用它，您可以在 vcpkg.json 中添加以下内容：\n{ \"name\": \"your-project\", \"version-string\": \"0.1.0\", \"dependencies\": [ { \"name\": \"ftxui\", \"version\u003e=\": \"6.1.9\" } ] }","使用-vcpkg-安装-ftxui#使用 Vcpkg 安装 FTXUI":"vcpkg install --triplet x64-linux # 或 x64-windows / arm64-osx 等","配置构建系统#配置构建系统":"如果您使用 CMake，可以在 CMakeLists.txt 中使用以下配置：\nCMakeLists.txt\ncmake_minimum_required(VERSION 3.15) project(my_project) # 确保在配置时传递 vcpkg 工具链文件 find_package(ftxui CONFIG REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) main.cpp\n#include #include #include int main() { using namespace ftxui; auto screen = ScreenInteractive::TerminalOutput(); auto button = Button(\"点击我\", [] { std::cout \u003c\u003c \"已点击！\\n\"; }); screen.Loop(button); } 配置和构建项目\ncmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake cmake --build build ./build/main"},"title":"Vcpkg"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/xmake/":{"data":{"":"","xmake-软件包非官方#XMake 软件包（非官方）":"FTXUI 可在 xmake-repo 中获取。\n示例 xmake.lua 代码片段：\nadd_requires(\"ftxui\", {system = false}) target(\"demo\") set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"ftxui\") 更多选项请参阅 XMake 文档。\nNote\n这是一个非官方软件包。这意味着它不是由 FTXUI 团队维护，而是由社区维护。\nNote\nFTXUI 作者对 XMake 了解有限。本页面内容主要由 AI 生成。如果您有任何改进建议，请提交 PR。"},"title":"XMake"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/todo_list/":{"data":{"":"Conan 页面 Conan页面\n添加关于如何使用 Conan 构建脚本的说明。\n如果您了解相关流程，请考虑向 Conan Center 添加一个\"官方\"构建脚本。这可以是一个 GitHub Action，用于在发布新版本时自动更新 Conan Center。"},"title":"待办事项"},"/docs/paper-lily%E4%B8%AD%E6%96%87%E7%A4%BE%E5%8C%BA/":{"data":{"":"本文档介绍了一些纸百合中文社区的相关信息","qq群#QQ群":"在QQ群，我们可以自由的交流剧情，讨论如何通关、剧情细节，当然，目前我们已经讨论得差不多了，所以大概率要等到第二章发布才会有当初的盛况\n站长的大型群\r另一个大型群"},"title":"Paper Lily中文社区"},"/docs/paper-lily%E4%B8%AD%E6%96%87%E7%A4%BE%E5%8C%BA/qq%E7%BE%A4%E7%BE%A4%E8%A7%84/":{"data":{"":"2025年7月31日第十四次修订","第一条制定依据#第一条——制定依据":"本规定的制定，遵守《中华人民共和国宪法》以及相关法律法规。","第七条限制宣传#第七条——限制宣传":"在未经过群主或管理员允许的情况下，发布以盈利为目的广告、与群聊讨论内容无关的文件、文本、网址等且造成五名以上群成员明确表示反感的，一律踢出群聊并拉入黑名单。","第三条处罚方式#第三条——处罚方式":"根据违反的规则不同、造成影响的程度不同等因素，将对违反规定者做出以下几种中一个或多个的惩罚：\n一分钟到一个月不等的禁言 解除管理员身份 口头教育 警告 严重警告 踢出群聊 踢出群聊并拉入黑名单 举报至QQ官方 举报至国家有关部门 其中，踢出群聊的处罚措施允许成员加回，用于群聊等级的清空","第九条不服教导#第九条——不服教导":"违反规定后，在管理员或群主教导下表示不服并拒不认错的，应当加重处罚。","第二条规定适用范围#第二条——规定适用范围":"凡是加入本群者，均代表认同此规定且愿意遵守这一规定，任何群员不得以任何理由违反群规定，否则将受到相应的处罚。","第五条刷屏内容#第五条——刷屏内容":"同一人使用大量无用、重复的信息连续无间断的发送，或者使用特殊技术手段使得图片等内容占据很长一段空间的，一律予以一个小时以上禁言，屡教不改者，当加重处罚。","第八条管理员的废除和增加处罚#第八条——管理员的废除和增加处罚":"管理员因为个人情感等因素不按照规定给予群成员处罚或对应违规行为处理不妥当的，应调整对于事件的处理结果并给予口头警告，两次以上的，应撤去管理员身份。\n管理员违反群聊规定的，应撤去管理员身份并接受在普通处罚的基础上加重一级的处罚。\n管理员在处理群内事务时，对他人恶语相向，使用明显拥有侮辱性、攻击性的词汇时，应当撤去管理员身份；阴阳怪气、态度恶劣的，将规劝其改正态度，再次出现此类情况时，将撤去管理员身份。","第六条破坏和谐#第六条——破坏和谐":"进行地域歧视、种族歧视或进行恶意的人身攻击、嘲讽等不利于群内团结的行为的，一律予以一天以上禁言，严重或屡教不改者，当加重处罚。","第十一条预处理措施#第十一条——预处理措施":"在遇到可能或确定存在违规的行为并且群聊内较为混乱的情况下，管理员或群主可以临时设置全体当事人一个小时的禁言，在此期间内，所有在线的管理员与群主一同判断是否违规或应当适用那种处罚措施，在商讨完毕后方可进行调整。","第十条主动认错#第十条——主动认错":"违反规定后，在管理员、群主或其他群成员劝说下主动认错、道歉的，应当减轻处罚，未被教导主动道歉的，将减轻两级，可以以此减到无处罚状态。","第四条不适宜内容的处理#第四条——不适宜内容的处理":"在群内发布明确违反国家法律法规规定的内容（包括但不限于涉及黄、赌毒；非法公开户籍信息；辱骂烈士）的，一律踢出本群并拉入黑名单，同时举报至国家相关机关。\n交流时明显谈及时事政治相关的敏感话题并且引起多于二十五条消息参与讨论的，予以一天以上禁言，屡教不改者，当加重处罚。\n由于界定难度，相关内容是否不宜发出将由群主与管理员共同判断，目前明确不允许的是：散播政治谣言、分裂国家言论和未经核实的重大事件","管理须知处罚如何加重#管理须知：处罚如何加重":"2025.2.16第一编\n对于标记了“屡教不改者，当加重处罚”或“严重屡教不改者，当加重处罚”的条目和满足本规定第十条或第十一条规定的，加重或减轻的依据为如下列表的顺序：\n禁言一分钟（或以上）\n禁言五分钟（或以上）\n禁言一小时（或以上）\n禁言十二小时（或以上）\n禁言一天（或以上）\n禁言十天（或以上）\n禁言一个月（29天23小时59分钟）\n踢出群聊并拉入黑名单\n初犯时采用触犯的规定中明确的方式和时长进行处罚，下一次违规则以原条目处罚的下一条处置，以此类推。额外的加重意为在此基础上再向下一条使用，减轻则反之，加重和减轻是可叠加的。\n每次进行禁言处置，应在当前条以上，下一条以下进行选择，超出范围将视为管理员失职。\n对于同时违反多项规定的，将采用累计的方式，统计应适用的禁言的时长和，当起始时间相加超过一个月（29天23小时59分钟）则整合为踢出群聊并拉入黑名单并执行。","群主工作报告相关#群主工作报告相关":"群主会在每天早些时分公开有关前一日的工作情况包括群聊、频道管理等活动的报告，报告公布只会在前一天没有工作任务的情况下才会取消，报告内容将传至群主工作报告相册"},"title":"QQ群群规（总编）"},"/moments/":{"data":{"":"一些日常内容，由于不想一直发朋友圈影响朋友，所以会在这里分享，网站已经搞定评论区功能了，可以发评论了哦\n最新动态板块：\n2025年10月的内容\r历史板块与介绍：\n暂无"},"title":"动态"},"/moments/2025-10/":{"data":{"":"","2025101-1852#2025/10/1 18:52":"刚把这个文件建好写了个日期，一个蜘蛛突然闪进我的视野里了，还挺大的，赶紧拿杀虫剂喷死了（本来打算用纸包住丢出家门的，但它跑的太快了没抓住），目前被丢进了我喝奶茶剩下的杯子里（说实话我该给它拍个遗照的，这种体型的蜘蛛在我的家里只出现过这么一次）","2025101-2128#2025/10/1 21:28":"I’m a robot.","20251012-200#2025/10/12 2:00":"算了一下时间，我好像过不了1024了，到时候只能发个预制文章了\n最近在考虑转C#，C++的图形化开发太难了….（不过我也打算把win32文档整理整理放到我这个网站上，倒也不急着转）","20251012-338#2025/10/12 3:38":"配个vimrc，烦死我了，就几个插件，以前的东西全都乱了\n（注：本条内容其实是在测试git插件）","20251012-351#2025/10/12 3:51":"好了这个Vim我终于是配好了","20251018-1502#2025/10/18 15:02":"哎不是，这个网站我花了那么长时间布置好了，结果这几天找PLC2的时候突然看到了另一个网站模板（显然我更喜欢这个新的），我真得哭了，为什么没早点遇到","20251018-2216#2025/10/18 22:16":"很奇怪啊，我给Vim装了个差错插件，结果就开始卡了，换了个插件，还是卡，然后删插件，依旧卡，各种折腾甚至都把新增配置全部删了还是卡….\n我现在把Vim卸载了，我要重装一遍","2025102-233#2025/10/2 2:33":"没睡，和那个烂游戏杠上了（指《I’m not a robot》），我就不信我过不了了\n博客写不完了，就这样吧，明天再写","20251025-1723#2025/10/25 17:23":"哎呀没赶上1024…","2025103-1410#2025/10/3 14:10":"跟朋友约着出去咯，先洗个澡再说","2025103-1421#2025/10/3 14:21":"忘记发昨天做的土豆饼了","2025103-1422#2025/10/3 14:22":"我突然发现这样写在一个文件里没法逐条评论，似乎每一条都单独占一页然后再提供一个放到一起的版本似乎更好，但这样我或许就得自己搞一个自动化的工具了，否则这样发内容真的很累","2025103-1829#2025/10/3 18:29":"额看完731了，不过我没看懂，剧情有点乱\n哦对了，它甚至真的带一些喜剧元素，里面有一段非常欢快的配乐，不是很喜欢这一点","2025103-235#2025/10/3 2:35":"博客写完咯，要睡觉啦\n之后的日子倒是可以考虑写写网站搭建教程的博客，不过嘛，先让我休息几天","2025105-1620#2025/10/5 16:20":"继续做饭，今天烤个牛奶（指鸡蛋+白砂糖+淀粉+牛奶然后塑性烤熟）","2025106-1424#2025/10/6 14:24":"中秋节快乐~（中cia快llo～（∠·ω\u003c）⌒☆）","2025106-255#2025/10/6 2:55":"熬到现在，外面突然下雨了🤔","2025106合并#2025/10/6[合并]":"东西还挺多，合起来搞了，省的写时间了\n中秋了哦\n我怎么那么平均\n神人班长给我点的外卖，我快笑死了，这玩意还被我爸看到了\n自己炒的土豆片，说实话，这是这几天做的菜最像样的一个了，起码看起来"},"title":"2025年10月"},"/test/":{"data":{"":"公式测试","1-行内公式测试#1. 行内公式测试":"勾股定理：a2+b2=c2 a^2 + b^2 = c^2 a2+b2=c2 二次方程求根：x=−b±b2−4ac2a x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} x=2a−b±b2−4ac​​ 欧拉恒等式：eiπ+1=0 e^{i\\pi} + 1 = 0 eiπ+1=0","2-独立公式测试#2. 独立公式测试":"二次方程解： x=−b±b2−4ac2a\rx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\rx=2a−b±b2−4ac​​高斯积分： ∫−∞∞e−x2dx=π\r\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}\r∫−∞∞​e−x2dx=π​矩阵行列式： ∣abcd∣=ad−bc\r\\begin{vmatrix}\ra \u0026 b \\\\\rc \u0026 d\r\\end{vmatrix} = ad - bc\r​ac​bd​​=ad−bc极限定义： lim⁡x→0sin⁡xx=1\r\\lim_{x \\to 0} \\frac{\\sin x}{x} = 1\rx→0lim​xsinx​=1傅里叶变换： f^(ξ)=∫−∞∞f(x)e−2πixξdx\r\\hat{f}(\\xi) = \\int_{-\\infty}^{\\infty} f(x) e^{-2\\pi i x \\xi} dx\rf^​(ξ)=∫−∞∞​f(x)e−2πixξdx麦克斯韦方程组（微分形式）： ∇⋅E=ρε0∇⋅B=0∇×E=−∂B∂t∇×B=μ0J+μ0ε0∂E∂t\r\\begin{aligned}\r\\nabla \\cdot \\mathbf{E} \u0026= \\frac{\\rho}{\\varepsilon_0} \\\\\r\\nabla \\cdot \\mathbf{B} \u0026= 0 \\\\\r\\nabla \\times \\mathbf{E} \u0026= -\\frac{\\partial \\mathbf{B}}{\\partial t} \\\\\r\\nabla \\times \\mathbf{B} \u0026= \\mu_0 \\mathbf{J} + \\mu_0 \\varepsilon_0 \\frac{\\partial \\mathbf{E}}{\\partial t}\r\\end{aligned}\r∇⋅E∇⋅B∇×E∇×B​=ε0​ρ​=0=−∂t∂B​=μ0​J+μ0​ε0​∂t∂E​​","3-复杂公式测试#3. 复杂公式测试":"黎曼ζ函数： ζ(s)=∑n=1∞1ns=∏p prime11−p−s\r\\zeta(s) = \\sum_{n=1}^{\\infty} \\frac{1}{n^s} = \\prod_{p \\text{ prime}} \\frac{1}{1 - p^{-s}}\rζ(s)=n=1∑∞​ns1​=p prime∏​1−p−s1​薛定谔方程： iℏ∂∂tΨ=H^Ψ\ri\\hbar \\frac{\\partial}{\\partial t} \\Psi = \\hat{H} \\Psi\riℏ∂t∂​Ψ=H^Ψ 我要借这个测试页面放点东西\nhello,你好"},"title":"_index"}}