{"/blog/":{"data":{"小狄同学呀の博客#小狄同学呀の博客":"小狄同学呀の博客平时会从自己的CSDN、稀土掘金搬一些文章，但应该不会有网站独家博客\nB站：小狄同学呀\nGithub：xiaoditx\nACfun：小狄同学呀\nCSDN、稀土掘金：小狄同学呀"},"title":"_index"},"/blog/%E7%AE%97%E6%B3%95%E7%9C%9F%E9%A2%98gesp202503%E5%9B%9B%E7%BA%A7%E8%8D%92%E5%9C%B0%E5%BC%80%E5%9E%A6%E6%B4%9B%E8%B0%B7b4263/":{"data":{"1分析题目#1.分析题目":"题目说，上下左右四个方向相邻的格子均不存在杂物的荒地才可以开垦，用这个思路想似乎是很难的，但换一个思路或许会容易些，我们假设下面这片$3×3$的荒地：\n...\r.#.\r... 此时中心出现杂物，由于可开垦的荒地上下左右均不能有杂物，因此这一个杂物影响了它上下左右的荒地，我们用!表示无杂物但不可开垦的荒地：\n.!.\r!#!\r.!. 也就是说，我们判断荒地是否不可开垦的思路转换为了找杂物，下面的，就是代码内容了。","2数据读入和初步处理#2.数据读入和初步处理":"","3当前可开垦的数目统计#3.当前可开垦的数目统计":"我们这里的思路是：既然只能除掉一个，那我们就先算一算不除掉能开垦多少，再找找除掉后能够空出地盘最多的杂物，由此，就需要先统计当前可开垦数目：\nint ans=0;//初始化一个为0的ans变量，用于存储最后输出 //下面的循环，读imap数组，数“0”的个数 for(int c=0;c\u003cn;c++){ for(int vc=0;vc\u003cm;vc++){ //标准的循环遍历 if(imap[vc][c]==0){//当前格子为0 ans++;//ans用来记录可开垦格子数，0为可开垦，记录为+1 } } } 显然，当前的状态是好判断的，只要为0，就说明可开垦，这是我们前面量化的数值，那么只要发现0就给ans变量加上一就行，循环一次后，imap中0的数量就存到ans里了。","4最优解查找#4.最优解查找":"这是我们就只差找到移除的最优解了，这里最简单的方法就是枚举object了，但我那个同学貌似是把记录的位置依次变成.然后分析可开垦数，多少有些低效了（也许我理解错他的意思了？总之这个方法很慢），实际上这个东西只要按照偏移读取就好。\n当一个杂物被移走的时候，按照定义，周围的格子数值都应该减1，其所在的位置则是变为正数然后减一，则我们可以知道只要其所在的格子是-1时，移走可开垦；只有其周围格子为1时，一走可开垦，由此，得出以下代码：\nint area,best=0;//两个变量来算杂物去除后变为可开垦的荒地数 for(int c=0;c\u003crecord_c;c++){ area=0;//area只是临时变量，每次循环初始化为0 //事实上，这里写int area;似乎更好 for(int vc=0;vc\u003c4;vc++){//四次偏移 int tx=px[vc]+object[c][0],ty=py[vc]+object[c][1];//计算XY if((tx\u003e=0) //边界检测，同前 \u0026\u0026 (tx\u003cm) \u0026\u0026 (ty\u003e=0) \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]==1){//如果为1，则证明只被当前杂物影响，移除该杂物就能开垦了 area++;//可开垦荒地数+1 } } } if(imap[object[c][0]][object[c][1]]==-1){//看看这个杂物有没有在别的杂物的影响范围内 area++;//不在的话再加一 } if(best\u003carea)best=area; if(best==5)break;//最大值是五，不可能在大了（自身+四个偏移），直接break节省时间 } 通过所谓“打擂台”的方式选出最优方案，由于自身加上偏移也就最多五个点，因此当best为5时就可以break了，毕竟已经没用方案能够更优了，这么做可以节省时间，在竞赛中，即使不这么做也能AC，仅仅几行就能做的简单优化也依旧是必须的，毕竟C++的观念就是效率至上。","5输出#5.输出":"由于最优解只看-1和1，这些可开垦荒地都是相对未移除杂物时新增的，直接将ans和best简单的相加即可的到最后结果\nans+=best;//ans加上挪出杂物腾出来的空间 std::cout\u003c\u003cans;//输出答案","一开始之前#一.开始之前":"一.开始之前同学去考了GESP，回来给我说他有一题TLE了，顺手把题目写给我了，当时看完有点思路，用易语言写了一下，结果越写越乱就放弃了，这周上课有些无聊，闲着也是闲着，干脆又把这题拾起来做了，回家试了试又改了改，顺利AC。\n原题是这样的：\n小杨有一大片荒地，可以表示为一个 n 行 m 列的网格图。\r小杨想要开垦这块荒地，但荒地中一些位置存在杂物，对于一块不存在杂物的荒地，该荒地可以开垦当且仅当其上下左右四个方向相邻的格子均不存在杂物。\r小杨可以选择至多一个位置，清除该位置的杂物，移除杂物后该位置变为荒地。小杨想知道在清除至多一个位置的杂物的情况下，最多能够开垦多少块荒地。 输入输出什么的直接看洛谷吧，我就不一一粘过来了：洛谷B4263","三解析#三.解析":"","二代码#二.代码":"虽然我是写出来了，但我毕竟不是专业学算法的，所以我也不知道什么时间复杂度空间复杂度的，更不知道我用的算法叫什么，我只知道我AC了，每次大抵是在7-25ms通过测试点（如下）\n下面是我的代码，这个是带注释的版本，但大概也会被我某些地方原因不明的写法迷惑住，如果看不懂可以直接看解析，会有几乎逐行的解读：\n#include #include int main(){ int m,n,record_c=0;//长宽与杂物数记录变量 char tmp;//其实想用string的来着 int px[4]={0,0,1,-1},py[4]={1,-1,0,0};//杂物的不可开垦偏移 std::cin\u003e\u003en\u003e\u003em;//读入长宽(处于设计原因，被逼无奈反着读了) int imap[m][n];//创建地图数组（二维） int object[m*n][2];//杂物坐标记录数组 memset(imap,0,sizeof(imap));//初始化地图为0（即默认无杂物可开垦） for(int c=0;c\u003cn;c++){//循环读入内容 for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;//暂时读入tmp if(tmp=='#'){//判断是否为#（杂物） imap[vc][c]=-1-imap[vc][c];//是杂物则以负数记录叠加 object[record_c][0]=vc;//记录杂物位置，减少后期工作量，节约时间 object[record_c][1]=c; record_c++;//把记录的变量+1 for(int dev_c=0;dev_c\u003c4;dev_c++){//四次计算偏移后的坐标并判断 int tx=px[dev_c]+vc,ty=py[dev_c]+c;//偏移后的X、Y /*边界判断，防止操作数组时超界 实际上，如果你觉得if严重影响执行效率，可以考虑定制化的边界判断，先操作边界再操作内部 这样会有更高的效率，但同样意味着你需要写更多的代码 */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) //这两行是对X的判断 \u0026\u0026 (ty\u003e=0) //下面两行是对Y的判断 \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){//对于“是否为杂物”进行判断 imap[tx][ty]++;//\u003e-1不为杂物，以++方式计录影响 }else{//\u003c=-1的情况 imap[tx][ty]--; } } } } } } //读入完成，感受人机缩进的力量吧 //（实则如果看的不舒服你完全可以用goto解决一下，但是不推荐） //下面是调试时使用的代码，在注释里保留了一下 // for(int c=0;c","写地图#写地图":"for(int c=0;c\u003cn;c++){//循环读入内容 for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;//暂时读入tmp if(tmp=='#'){//判断是否为#（杂物） imap[vc][c]=-1-imap[vc][c];//是杂物则以负数记录叠加 object[record_c][0]=vc;//记录杂物位置，减少后期工作量，节约时间 object[record_c][1]=c; record_c++;//把记录的变量+1 for(int dev_c=0;dev_c\u003c4;dev_c++){//四次计算偏移后的坐标并判断 int tx=px[dev_c]+vc,ty=py[dev_c]+c;//偏移后的X、Y /*边界判断，防止操作数组时超界 实际上，如果你觉得if严重影响执行效率，可以考虑定制化的边界判断，先操作边界再操作内部 这样会有更高的效率，但同样意味着你需要写更多的代码 */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) //这两行是对X的判断 \u0026\u0026 (ty\u003e=0) //下面两行是对Y的判断 \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){//对于“是否为杂物”进行判断 imap[tx][ty]++;//\u003e-1不为杂物，以++方式计录影响 }else{//\u003c=-1的情况 imap[tx][ty]--; } } } } } } （请不要在意我诸如c、dev_c之类的奇怪的变量名，我只是想写出c++这样的语句）\n我们使用一个很简单的循环逐个字符的读入，由于我们已经将地图初始化为了可开垦，所以督读到.大抵可以直接丢弃，只有#对我们才是重要的，我们将其记录入imap和object\n记录入imap的操作是这样的：-1-当前格内容，如果原本是0，那么现在就是-1，原本是1，现在就是-2，可以回看量化每个位置的信息那段，看看是不是对上了。\n写入完毕后，做四次循环，分别对应px和py数组的四次偏移，依次计算影响：非杂物块加上一，杂物块减去一。\n计算偏移时需要注意一点，偏移后的结果有几率超出数组范围，这个时候就不应该对这个不存在的坐标操作了，所以要加个if对于是否超界进行判断。","准备地图#准备“地图”":"想要解题，肯定得先接住题目给的数据，连数据都接不好还怎么分析，于是先写下接收前两个数据的代码，顺手为后面的事做准备：\n#include #include int main(){ int m,n,record_c=0;//长宽与杂物数记录变量 char tmp;//其实想用string的来着 int px[4]={0,0,1,-1},py[4]={1,-1,0,0};//杂物的不可开垦偏移 std::cin\u003e\u003en\u003e\u003em;//读入长宽(处于设计原因，被逼无奈反着读了) int imap[m][n];//创建地图数组（二维） int object[m*n][2];//杂物坐标记录数组 memset(imap,0,sizeof(imap));//初始化地图为0（即默认无杂物可开垦） } 这里用到了两个头文件，iostream和cstring，一个几乎是必需品，一个则是初始化数组用的。\n这里可能有人会说：诶？using namespace std怎么被你吞了？\n实际上，只要你勤加std::就可以不写这句话，这样做当然是有好处的，虽然在算法竞赛里不容易体现出来，不过我毕竟是个侧重应用的人（毕竟一上来就学的易语言），所以一直注重少用using的习惯，有关这个东西，大家可以搜一下“命名空间污染”自行了解。\n这里定义了整型变量m、n、record_c分别负责：接受输入n、接受输入m、存储杂物数量（这里是由于写的瑕疵，m和n用反了，结果发现不好改，最后只能做出用m接n这种举动了）；一个char型的变量tmp，也就是接受后面.和#输入的变量。\n代码中的px和py实际上是“偏移数组”，实际使用中，去一个数字，对于一个点$A$，将其X坐标+px[n]，其Y坐标+py[n]，可以得到一个偏移的点，本代码的偏移对应正的上左下右。\n定义玩这些变量后，我们可以开始读入了，读入m和n，这两个数就可以得知正片土地的大小，可以帮助我们定义一个恰到好处的数组作为我们的“地图”（我这个人非常喜欢恰到好处，即使有各种风险，不过毕竟是易语言写多了的，似乎也合理）\nint imap[m][n]，这是创建了一个二维数组，imap就是地图的意思（本来写的是map，但是同学说这貌似是个保留字，就改成imap了），这样我们就可以直接用X和Y操作点了。\nobject是什么呢？这里其实是用它存储杂物的位置信息的，考虑到杂物可能有很多，终归感觉还是定义为$m×s$比较好，这也是个二维数组，只不过是一个类似结构体数组的东西（实则每次存都是object[n][0]存X、object[n][1]存Y，完全可以写成结构体，但我懒，而且我喜欢数组，嘻嘻）\n最后一步，给imap数组初始化为0，至于为什么是0，请移步下一段。","四后记#四.后记":"还是忍不住想给大家分享一下这份我手写的原稿代码，虽然有一些细节上的瑕疵，但总体还是完整的 经过这次的解题，我意识到有一种写题方法是极优的，当你写完了代码运行起来却事与愿违时，不妨想想如何用自然语言来描述你的算法，这样的方式相比对着代码抓头发等容易发现思想上的纰漏，各位搞算法的可以尝试一下。\n有些困了，脑子也不好用了，可能迷迷糊糊的写了一些原因不明的话，先睡了，等睡醒再改改吧","量化每个位置的信息#量化每个位置的信息":"对于一个格子，它可以是荒地，可以是杂物，可以是被杂物影响的荒地，也有可能是在杂物影响范围内的杂物，需要注意的是：一个荒地有可能同时被两个甚至更多杂物影响。\n注意看下面的例子：\n.....\r.#.#.\r..... 这个例子中，两个#中间的.，即使在一边的杂物被去除后，仍然处在另一个杂物的影响之内，仍无法开垦，那么我们就认为，这次移除对于这单个点来说是无效的。\n那我们该怎么记录这个点在几个杂物的影响范围内呢？我们有一个量化策略，使用0表示可开垦，1表示一个杂物影响，2表示两个，最多可到4。\n同样的道理，对于放置杂物的格子，如果拿掉了，这一格也有可能无法开垦，我们同样要记录，这里我们使用-1表示杂物，-2表示被在一个杂物影响范围内的杂物，以此类推（这样设定是为了后面记录方便，这个我们姑且不谈）"},"title":"算法真题：GESP202503四级——荒地开垦（洛谷B4263）"},"/blog/vscode%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99g++%E5%8D%B4%E5%AE%8C%E7%BE%8E%E7%BC%96%E8%AF%91api%E8%B0%83%E7%94%A8%E9%94%99%E5%9B%A0%E5%88%86%E6%9E%90/":{"data":{"":"前一段时间写了个小软件，想给它加个读写配置项功能，刚学几天C++的我上网查了半天资料，找到两个Windows的API分别是读ini的GetPrivateProfileString和写ini的WritePrivateProfileString，根据网上的教程，我写出了下面这三行：\nLPTSTR lpPath = new char[MAX_PATH]; strcpy(lpPath, \".\\\\config.ini\"); ::WritePrivateProfileString(\"config\", \"t\", \"120\", lpPath); 刚刚写完，VScode安的插件瞬间爆红，然后给出了这样的报错： 但是我确定我是完全按照教程走的，所以到底是哪里的问题呢？\n于是我尝试编译，结果非常惊人，g++没有任何报错的编译成功并且在当前目录新建了config.ini并写入了指定内容\n这有些奇怪，还是查查官方文档吧\n上MSDN，查WritePrivatePeofileString，却并没有查到，只查到了WritePrivatePeofileStringA和WritePrivatePeofileStringW（末尾都多了个字母）这两个函数\n没办法了，只好点进一个看看，我选择了WritePrivatePeofileStringA，诶，这个参数的类型好像不对，跟着教程写的是LPTSTR，但这里面写的是LPCSTR\n向下划，我在例子板块的下方看到了一串提示\nwinbase.h 标头将 WritePrivateProfileString 定义为一个别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将中性编码别名与不中性编码的代码混合使用可能会导致编译或运行时错误不匹配。 有关详细信息，请参阅函数原型的 约定。\n也就是说，WritePrivatePeofileString不是这个API的原名，它只是根据条件进行选择的\n回到VScode，按住Ctrl并单击WritePrivatePeofileString，看到了Windows.h中的内容：\n#ifdef UNICODE #define WritePrivatePeofileString WritePrivatePeofileStringW #else #define WritePrivatePeofileString WritePrivatePeofileStringA #endif VScode显示，上方是亮着的，证明VScode的环境下有UNICODE这个宏\n这下破案了，由于VScode有UNICODE宏而g++没有，所以插件检查时是按照WritePrivatePeofileStringW检查的，此时插件认为需要使用unicode，路径需要使用wchar_t也就是宽字符存储，g++编译时，按照WritePrivatePeofileStringA，此时g++认为要用ANSI，路径使用char也就是普通字符存储，于是我们使用的char的代码在g++下正常而没有通过VScode的插件检查\n因此，我们的书写是正确的，但是由于VScode的环境与g++不同，被插件当作了错误，此时我们应当指明我们要使用WritePrivatePeofileStringA函数：\nchar* lpPath = new char[MAX_PATH]; strcpy(lpPath, \".\\\\config.ini\"); ::WritePrivateProfileStringA(\"LiMing\", \"Sex\", \"Man\", lpPath); delete[] lpPath; 到这里就结束了，烦人的提醒终于消失不见了\n另附：LPxxxSTR数据类型的具体含义\n核心基础类型:\nCHAR: 表示一个 ANSI (8-bit) 字符 (char)。 WCHAR: 表示一个 宽字符 (Unicode, 通常是 16-bit UTF-16) (wchar_t)。 TCHAR: 自适应字符类型。根据项目设置（是否定义了 _UNICODE 宏）编译为 CHAR 或 WCHAR。用于编写既可编译为 ANSI 也可编译为 Unicode 的代码。 字符串指针类型:\nLPSTR: Long Pointer to STRing。指向以 NULL 结尾的 ANSI 字符串 (CHAR*)。 typedef CHAR* LPSTR; LPWSTR: Long Pointer to Wide STRing。指向以 NULL 结尾的 Unicode (UTF-16) 字符串 (WCHAR*)。 typedef WCHAR* LPWSTR; LPTSTR: Long Pointer to TCHAR STRing。指向以 NULL 结尾的 自适应字符 (TCHAR*) 字符串。根据 _UNICODE 宏定义，编译时等同于 LPSTR (ANSI) 或 LPWSTR (Unicode)。 typedef TCHAR* LPTSTR; 常量字符串指针类型:\nLPCSTR: Long Pointer to Constant STRing。指向以 NULL 结尾的 常量 ANSI 字符串 (const CHAR*)。 typedef const CHAR* LPCSTR; LPCWSTR: Long Pointer to Constant Wide STRing。指向以 NULL 结尾的 常量 Unicode (UTF-16) 字符串 (const WCHAR*)。 typedef const WCHAR* LPCWSTR; LPCTSTR: Long Pointer to Constant TCHAR STRing。指向以 NULL 结尾的 常量自适应字符 (const TCHAR*) 字符串。根据 _UNICODE 宏定义，编译时等同于 LPCSTR (ANSI) 或 LPCWSTR (Unicode)。 typedef const TCHAR* LPCTSTR; 关键区别总结表：\n类型 字符宽度 常量性 (const) 基础类型等价 (ANSI Build) 基础类型等价 (Unicode Build) 描述 LPSTR ANSI (8-bit) 非 const char* char* 指向 ANSI 字符串的指针 LPCSTR ANSI (8-bit) const const char* const char* 指向 只读 ANSI 字符串的指针 LPWSTR Unicode (16-bit) 非 const wchar_t* wchar_t* 指向 Unicode (UTF-16) 字符串的指针 LPCWSTR Unicode (16-bit) const const wchar_t* const wchar_t* 指向 只读 Unicode (UTF-16) 字符串的指针 LPTSTR 自适应 非 const char* (LPSTR) wchar_t* (LPWSTR) 指向自适应字符串的指针 (TCHAR*) LPCTSTR 自适应 const const char* (LPCSTR) const wchar_t* (LPCWSTR) 指向 只读 自适应字符串的指针 (const TCHAR*) 重要说明:\nLP 前缀: “Long Pointer” 是一个历史遗留物，在现代 32/64 位系统中，所有指针都是 “long”，可以简单地把 LP 理解为 “Pointer to”。 C 后缀: 表示 const，即指针指向的内容是只读的，不能通过这个指针修改字符串内容。 T 中缀: 表示类型是 TCHAR，它会根据项目字符集设置自适应。这是为了编写同时支持 ANSI 和 Unicode 构建的代码。 W 后缀: 表示 “Wide”，即 Unicode (UTF-16)。 STR 后缀: 表示 “String” (以 NULL 结尾的字符数组)。 现代 Windows 开发实践: 强烈推荐始终使用 Unicode 构建项目 (在 Visual Studio 项目属性中设置 “字符集” 为 “使用 Unicode 字符集”)。这定义了 _UNICODE 宏。 在 Unicode 构建下： TCHAR = WCHAR LPTSTR = LPWSTR LPCTSTR = LPCWSTR 直接使用 LPCWSTR/LPWSTR 或 LPCWSTR/LPWSTR 的别名 std::wstring (C++) 通常更清晰，避免 TCHAR 系列的歧义，除非你明确需要维护同时支持 ANSI/Unicode 的旧代码库。 ANSI (LPSTR/LPCSTR) API 函数在内部通常只是将字符串转换为 Unicode 然后调用对应的 Unicode 版本函数，存在性能开销和潜在的字符集转换问题。优先使用显式的 Unicode (W) 版本 API。 兼容性: TCHAR 系列主要是为了兼容旧的 Windows 9x 系统（主要使用 ANSI）和现代 NT 系统（原生 Unicode）。现代开发（Windows 2000 及以后）应首选 Unicode。 简单记忆:\n看 W -\u003e Unicode。 看 C -\u003e const (不能修改字符串内容)。 看 T -\u003e 自适应，根据项目设置变 ANSI 或 Unicode。 没有 W 也没有 T -\u003e ANSI。 没有 C -\u003e 字符串内容可修改 (非常量)。 有 C -\u003e 字符串内容只读 (常量)。 使用建议:\n新项目：始终开启 Unicode 构建 (_UNICODE defined)。优先使用 LPCWSTR (输入参数) 和 LPWSTR (输出参数)，或者在 C++ 中使用 const wchar_t* 和 std::wstring。 维护旧项目/需要 ANSI 兼容：使用 LPCTSTR (输入) 和 LPTSTR (输出) 或对应的 TCHAR 基础类型，并确保正确处理 _UNICODE 宏定义。 与 Windows API 交互时，注意 API 函数通常有 A (ANSI) 和 W (Wide/Unicode) 两个版本（如 MessageBoxA 和 MessageBoxW）。使用通用宏 MessageBox 会根据 _UNICODE 自动选择正确的版本。传递的字符串指针类型也必须与之匹配（LPCSTR 对应 A 版本，LPCWSTR 对应 W 版本，LPCTSTR 对应通用宏）。"},"title":"VScode插件报错，g++却完美编译？API调用错因分析"},"/daily/":{"data":{"动态#动态":"动态一些日常内容，由于不想一直发朋友圈影响朋友，所以会在这里分享，网站已经搞定评论区功能了，可以发评论了哦"},"title":"_index"},"/docs/":{"data":{"":"这里是所有我参与编写的文档，其中包含项目说明、语法标准、文档翻译等内容，可以查看通过下方选项点击跳转\nBeepMusic开发者支持\rDCC语法与使用说明\rFTXUI文档简中翻译\rPaper Lily简中社区\r研究性学习报告"},"title":"文档汇总"},"/docs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E4%B8%8E%E9%80%89%E7%94%A8/":{"data":{"":"研究性学习综合报告编写：xiaoditx\n校对：马赫阳","1-c语言的诞生#1. C语言的诞生":"1972年，贝尔实验室的丹尼斯·麦卡利斯泰尔·里奇在开发UNIX操作系统时创造了C语言。这是一种与汇编相比更加贴近自然语言的语言，与汇编语言相比具有更强的可读性。\n下面是一段经典的输出Hello World的代码，这几乎是每个学习C语言开发的人所经历的共同的第一课。\n#include int main() { printf(\"Hello, World!\\n\"); return 0; } 这五行内容，完成了一个工作：在控制台上输出一串文本\n有人可能觉得这是一项简单的事情，认为C语言仅此而已，并没有什么伟大的意义，那这就大错特错了，我们来看一眼汇编语言的相同功能的实现吧：\ndata segment ;数据段 string db 'Hello,World!$' data ends code segment ;代码段 assume cs:code,ds:data start: mov ax,data ;获取段基址 mov ds,ax ;将段基址送入寄存器 mov dx,offset string mov ah,9 int 21h mov ah,4ch int 21h code ends end start 想要写出这么一串汇编代码，起码需要知道的知识有：寄存器的概念、代码段是什么、数据段是什么、基址是什么、汇编的诸多语法，多数的汇编语言教材写过五十多页依然需要外部软件辅助否则不能在软件层面上看到一点效果，C语言明显的就好多了\n对于C语言的那几行，大多数教程几乎不超过一千字：什么是头文件，什么是主函数，这些概念都很简单，讲讲就能明白\n因此C语言的有点就是如下所示的几条：\n从软件层面而非硬件层面出发，降低学习成本 原生支持大量操作，简化书写，便于阅读 当然，缺点也是有的，当我们使用gcc -S -masm=intel m.c -o m.s命令编译程序时，可以看到编译器将C代码翻译成了这样的内容：\n总共是三十行整，那么我们这里用通常的写法写出等效的汇编代码：（输出内容多了个词但是不影响）\n纯汇编的版本只用了十五行，也就是说，编译器多写了一倍，只是实现了相同的效果，事实上，这种差异在编译后期更加明显，通常的gcc编译程序在链接阶段需要连接一些库文件，最终成品有时比纯汇编大了几十倍都有可能。\n这便是C语言的缺点所在，使用结果上的“多写”换来了过程上的“少写”，究其原因还是因为模板化，以这里的输出为例，我们要输出的内容是文本，使用了printf函数，但这个函数也能输出整数、浮点数等，为了保证普适性，编译器不得不都把适配其他数据类型的代码也写进了编译后的文件，但实际上有的功能我们并不会用到。\ntips：笔者其实对C没什么好感，抛开内存泄漏的问题，过程语言本身就不是那么方便，有时用C++写软件不得不用上C的语法，说实话，真是够麻烦的（听说目前的GCC编译器还是用C++写的，挺好笑的）","1-易语言#1. 易语言":"编程语言一直发展，延伸到了中国，2000年，一款中文编程语言横空出世，采用表格编程，同样为解释运行，使用简单的中文进行软件开发，这就是易语言：\n.如果（用户输入==\"你好\"）\r输出框.显示（\"你好，世界！\"）\r.否则\r输出框.显示（\"无法识别\"） 与其他编程语言不同，易语言的第一课直接就是窗口的开发，软件开发周期短、中文学习编程难度低，一瞬间吸引了很多人前来\n下面是一张易语言的代码编写页面的截图：\n易语言优点如下：\n降低英语门槛 简化开发，加速开发效率 强大的官方组件，涵盖各方面内容 缺点也是有的：\n仅限于Windows平台 缺乏开源生态 仅支持三十二位编译，运行效率不足","1简洁的语法#1.简洁的语法":"1989年，吉多·范罗苏姆设计的Python将代码可读性推向极致，通过使用极其接近自然语言的语法，python的上手难度大大减小，大量编程初学者纷纷涌来学习\n下面是一个python输出Hello World的示例程序：\nprint(\"Hello World\") 仅仅一行，python便可以完成输出，这就体现出了它的一大特色：简洁，python对于在它先前的语言一些冗长的内容进行了化简，使得开发者得以聚焦于真正的算法而非功能实现。","2-c新生#2. C++新生":"C语言确实很强大，但这并不意味着人们就已经满足于C语言的开发效率，C语言仍然有些不尽如人意的地方：C语言是一种过程语言，代码复用率不够，因为自身设计问题，容易出现危险的类型转换与各种错误，同时有很高的内存泄漏风险，开发过程中，C语言的报错机制并不完善且仅在万行代码内能保证稳定的运行\n因此，在1983年，C++出现了，丹麦的本贾尼·斯特劳斯特卢普教授在C语言基础上增加类等概念，创造了所谓“支持面向对象编程”的C++，这种语言的内存泄漏率明显降低，对百万行级别的大项目也做了支持\nC++的出现无疑是里程碑式的，随着它的出现，多态、封装、对象、继承、命名空间、虚函数、模板等概念迅速流行，也使得之后的语言或多或少受其影响（如Java），将语言的抽象能力视为重中之重\n下面是c++的一些特性展示：\nclass Person { public: virtual void SenRen_BanKa() = 0; }; class DiYongJie : public Person { public: std::string play = \"YuZu soft!\" void SenRen_BanKa() override { std::cout \u003c\u003c \"Ciallo!\" \u003c\u003c std::endl; } }; 虽然增添了很多概念，但C++与C语言仍是强关联的，对于C语言的代码，C++基本上都能兼容（但是老的头文件肯定是要替换掉的），两者语言上实际上很相似：\n#include using namespace std; int main(){ cout\u003c\u003c\"Hello World\"; return 0; } 这种保留与进化并存使得C++快速成功，大型软件开发因此成为可能，至今仍广泛应用于游戏引擎、操作系统等高性能领域。","2-文言wenyan-lang#2. 文言（Wenyan-lang）":"中文编程在易语言之后兴起了一段时间，在2019年又兴起了一款名为文言的编程语言\n顾名思义，文言，就是使用文言文来编写程序，这使得其几乎变为了一种艺术形式而非编程工具：\n吾有一數。曰三。名之曰「甲」。\r為是「甲」遍。\r吾有一言。曰「「問天地好在。」」。書之。\r云云。 文言编程语言属于一种实验性的语言，用于传播文言文化与计算机文化，与chicken语言、///、glass语言、Piet语言等同样，属于是一种半艺术品，这标志着编程语言的高度发展，使得人们开始考虑探索具有一定的创造性、艺术性的分支\ntips：易语言是笔者接触的第一款编程语言，这绝对是个“新手友好型语言”，因为实在是太方便了，图形化界面下就可以完成窗口设计，以至于所有教程的第一课都是从窗口开始讲的，正因如此我才在之后觉得其它语言的GUI创建极为麻烦","2强大的标准库#2.强大的标准库":"将Python与C++相比，一个不争的事实是，C++的int型变量只能存储-2,147,483,648~2,147,483,647之间的内容，即使是最长的long long型变量，都只能表示-9,223,372,036,854,775,808~9,223,372,036,854,775,807的内容，而python的int变量却无任何限制，可以存储任意大小的数据而不溢出。\n上面说到的差异，我们带入实际开发中，对比一下C++和python的高精计算就能明白，算法平台洛谷上有一道题目：求1到n的阶乘之和，我们来看看python的答案：\nn=int(input()) ans=0#最终答案存储 rec=1#阶乘累加的变量 for i in range(1,n+1): rec*=i ans+=rec print(ans) 几行就搞定了，这是个很简单的题目，对吧？\n可是洛谷上标的难度还是相对不小的，为什么呢？下面来看C++代码就能明白了：\n#include #include using namespace std; struct bigint { int len, nm[1000]; // 使用结构体模拟大整数 bigint() { // 无参数的初始化 len = 0; // 初始长度为0 memset(nm, 0, sizeof(nm)); // 初始化为0 } bigint(int num) { // 用int初始化 memset(nm, 0, sizeof(nm)); len = 0; do { nm[len++] = num % 10; num /= 10; } while (num); } int operator[](int idx) const { // 返回对应位的值 return nm[idx]; } void process() { // 处理进位 int carry = 0; for (int i = 0; i \u003c 1000; ++i) { nm[i] += carry; carry = nm[i] / 10; nm[i] %= 10; } zero_processing(); } void zero_processing() { // 重置长度 len = 0; for (int i = 999; i \u003e= 0; --i) { if (nm[i] != 0) { len = i + 1; break; } } if (len == 0) len = 1; // 处理全0的情况 } void print() { // 输出 for (int i = len - 1; i \u003e= 0; --i) cout \u003c\u003c nm[i]; } }; bigint operator+(const bigint\u0026 a, const bigint\u0026 b) { bigint c; for (int i = 0; i \u003c max(a.len, b.len); ++i) c.nm[i] = a[i] + b[i]; c.process(); return c; } bigint operator*(const bigint\u0026 a, int b) { bigint c; for (int i = 0; i \u003c a.len; ++i) c.nm[i] = a[i] * b; c.process(); return c; } int main() { int n; cin \u003e\u003e n; bigint ans(0), tmp(1); for (int i = 1; i \u003c= n; ++i) { tmp = tmp * i; ans = ans + tmp; } ans.print(); return 0; } C++写这一题是异常的长，这就是因为这一题数据计算结果会很长，C++需要使用模拟算法来防止结果溢出，而python本身就有一套模拟机制，无需用户自行编写。","3-特点对比#3. 特点对比":"特性 C C++ 编程范式 过程式 多范式 内存管理 手动 手动+智能指针 标准库大小 精简 庞大 命名空间管理 缺乏 完善 头文件包含机制 原始 改进 应用场景 嵌入式系统 大型商业软件 tips：由于C++在保留了大量C风格的操作的同时加入了优秀便捷的标准库，有时C++甚至被算法界戏称为\"C with STL\"","python的优势#python的优势":"从定义上讲，python是个解释型语言，具有和Java一样的灵活性和高可移植性，而作为一个脚本语言，python又更擅长于数据计算等自动化工作，因此被广泛应用于大语言模型、网络爬虫中。\npython的优点如下：\n标准库功能强大，操作简洁 开源社区持续维护 第三方库丰富 解释型语言调试省时 tips：近几年有人把python喷得一无是处，认为解释型语言运行效率奇低，我只能说各有各的好处，就比如说python可以在信息技术必修一就讲解TK这个窗口库，而C++还要自己在MSDN中摸爬滚打找文档（亲身经历）","一编程语言的诞生#一.编程语言的诞生":"人类是懒惰的，自古便是如此，东汉时期，一种名为提花机的东西被广泛运用，这种物件最早可以追溯到商代，它与它所处的时代几乎是格格不入的，是它的功能：\n花本式提花机出现于东汉，又称花楼。它用线制花本贮存提花程序，再用衢线牵引经丝开口。花本是提花机上贮存纹样信息的一套程序，它由代表经线的脚子线和代表纬线的耳子线根据纹样要求编织而成。\n借助客观物件记录程序以节省精力，提花机，在东汉之时，悄然埋下了一颗超前于时代的种子，随着丝绸之路被打通，提花机流入欧洲，在一代代工人、物理学家、数学家手下，逐渐生根发芽，长成了名为\"计算机技术“的参天大树。","七中文互联网的探索#七.中文互联网的探索":"","三汇编语言程序员们对自然语言的第一次追逐#三.汇编语言：程序员们对自然语言的第一次追逐":"既然机器语言那么难写，那该怎么办呢？程序员们想了个办法：既然直接跟机器\"聊天\"有些困难，那我找个翻译不就好了？于是汇编语言便诞生了。\n百度百科这么定义汇编语言：\n汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。\n简单来说，汇编语言就像是一个万能的翻译官，这位\"翻译官\"制定了一种语言，当你需要和任意一个机器\"对话\"时，只要找到这位\"翻译官\"，对着他说出它制定的那套语言，他就可以根据情况用不同的表述转述给机器\n举个例子，A机器规定0000是加法运算，B机器规定1010是加法运算，此时，汇编语言规定了加法运算就是+,那么我们写程序时只要写+就行了，汇编语言针对A机器，会传述给它0000，而对于B机器则是1010\n正因汇编语言这种“因人而异”的翻译，在一定程度上解决了机器语言对机器的强依赖性问题，同时，通过诸如把0000变到+的操作，使得编写程序更加直观、更好记忆（1 0000 2好记好写还是1+2更加方便呢？这是很明显的吧）\n因此，汇编语言有时也被称作助记符，也就是辅助记忆的文本的意思，参照如下定义：\n助记符（mnemonic）是便于人们记忆、并能描述指令功能和指令操作数的符号，助记符是表明指令功能的英语单词或其缩写。\n汇编的引入使得记忆不再枯燥且难以理解，比如有MOV、ADD、CALL等命令，只要稍微有些英语基础就可以很好的理解，也就能比二进制更加快速的记住了。\n考虑到不同设计的机器之间有一些不可忽视的不同，汇编也衍生出了不同的版本，诸如IBM PC汇编、ARM汇编、GNU ASM、MASM、NASM等等，这里不去展开。\n这里引用一篇文章中对汇编语言的评价：\n汇编语言的出现，让程序员们从繁琐的二进制编程中解放出来，能够更加专注于程序的逻辑和功能实现，为计算机软件的发展奠定了重要基础\n总的来说，汇编语言就是让人达到\"知其然而不知其所以然\"的状态，着对于计算机技术的学习在大多数时候实际上是个好的状态，因为这样就可以摆脱繁琐的底层原理，当想用计算机解决某个问题时，就能去直接想使用怎么样的算法，而不是先看看机器的底层架构是如何的。\ntips：笔者非常喜欢汇编语言，它贴近底层，是打破计算机科学底层大门的钥匙，这是极具挑战性的语言，也是最能学到软件运行原理的语言","九选择建议#九.选择建议":"我们研究得出，编程语言各有所长，语言选取，应当针对自己的需求合理搭配，考虑开发效率与应用场景，下面有一些推荐的搭配方案\n底层开发\n推荐：C/Rust/少量汇编 场景：操作系统、嵌入式系统 优点：贴近底层，可以编译为多种形态 快速开发\n推荐：Python/JavaScript/少量shell/易语言 场景：Web应用、数据分析 优点：现成函数，高效开发 跨平台需求\n推荐：Java/Kotlin/QT框架 场景：企业级应用、移动开发 优点：跨平台，好移植 学术研究\n推荐：Python/Julia 场景：科学计算、机器学习 优点：简化代码，不让写代码成为累赘 兴趣驱动\n尝试：文言/易语言 价值：理解编程本质，培养计算思维 选取编程语言是，以下内容是关键考量维度：\n项目性能要求：高性能需求坚决不找高级语言，专业计算尽量不找低级语言 团队技术栈现状：根据团队成员的技能决定 社区生态成熟度：社区是开发的支柱，Rust社区就是典型的案例，良好成熟的社区是总能在各处帮助到每一位开发者 个人学习曲线：根据个人的学习计划选择","二第一代编程语言机器语言#二.第一代编程语言——机器语言":"人类和机器第一次”交流\"，借助的，是机器语言，这是一种只由单纯的0与1构成的\"语言\"，这便是定义上的第一代计算机语言了\n零和一的世界，是计算机的最底层的“本质”，因此足够基础，足够复杂，书写效率也相对较低，下面有一小段机器语言代码，大家可以感受一下\n二进制表示： 10001011 01000101 00000100 01011011 10001001 11000011 十六进制表示： 8b 45 04 5b 89 c3 可以明显看出，零和一的混搭使得代码内容难以辨认，因此人类也很难凭借所谓肌肉记忆之类的东西快速识别。\n实际上，上面的一大串内容，甚至不足以支撑一个简单的加法运算，假如现在我们不小心写错了一个字符：\n错误的： 10001011 01000101 00000100 01011011 10001101 11000011 正确的： 10001011 01000101 00000100 01011011 10001001 11000011 有人可以做到一眼看出哪个是错的吗？大概是没有的。机器语言实现加法最起码需要三行内容，三行之内，纠错难度都尚且如此之高，实际使用用于软件开发时困难可想而知。\n这就引出了机器语言的优点与弊病：\n优点如下\n最接近底层，运行足够快 机器可以直接识别运行，无需辅助的程序 不会出现多余无用的内容（程序体积小） 缺点如下：\n记忆难度大 直面底层，学习难度大 对于机器的依赖性强，一种机器一种结构，难以移植 只有0、1，容易写错且纠错困难 不禁想到了王爽在《汇编语言》中此般描述：\n书写和阅读机器码程序不是一件简单的工作，要记住所有抽象的二进制码。上面只是一个非常简单的小程序就暴露了机器码的灰色难懂和不易查错。写如此小的一个程序尚且如此，实际上一个有用的程序至少要有几十行机器码，那么，情况将怎么样呢？","五java实现跨平台梦想#五.Java：实现跨平台梦想":"高级语言诞生一段时间后，互联网蓬勃发展，但当时仅仅依赖着HTML这种标记语言来显示静态页面，所以当时访问互联网实质上就是浏览在线的word文档，这大大限制了互联网的潜能，人们很快注意到了这一点，都在寻找一种让网站动起来的手段，但早期语言对设备的要求很专一，电脑软件是坚决不能再单片机等硬件上运行的，所以人们探究的方向就变成了拥有一种技术去开发具有跨平台传播能力的软件\n在这种背景下，Sun公司推出了Java语言，伴随着\"Write Once, Run Anywhere\"的革命性理念，也就是“一次开发，多平台运行”，一经问世便迅速成功，1996年1月，Sun公司发布了Java的第一个开发工具包（JDK 1.0），标志着Java成为一种独立的开发工具。仅仅八个月后，就有约8.3万个网页应用了Java技术来制作\n下面是java的代码：\npublic class Main { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 实际上，java依旧保留了C/C++的很多思想，因为它本身是由Sun公司研发的Oak语言发展来的，而Oak语言，就是Sun公司为了开发单片机程序而制作的简化的C++\n由于Java在设计之初就是为了开发消费类家用电子产品软件，因此对于“可靠性”做了很多优化，因此，Java拥有如下几个有点：\n由C/C++演进，易上手，语法更简洁 移取了指针这一概念，硬件对于开发人员几乎完全黑盒，保证了软件安全性的同时还降低了学习成本 具有高可移植性 这些优点使得Java在企业级应用开发中占据主导地位，Android开发的基础语言之一，但为了可移植而带来的性能损耗也使其不适合高性能计算场景。\ntips：Java以罗嗦著称，是许多程序员调侃的点，说实话，我对Java早期的印象就是“把C++的类单独拉出来了”","八总体总结发展规律#八.总体总结：发展规律":"根据上面的几个例子，我们可以看出语言的变化特点：\n抽象层级提升\n编程语言不断的向着“抽象”发展，代码复用率逐渐提高，使得开发效率得以提高\n演进方式 ：机器指令 → 符号化 → 结构化 → 面向对象 → 函数式编程\n效率平衡演进\n开发人员们更乐意讨论开发和使用孰轻孰重\n演进方式 ：执行效率优先 → 开发效率优先 → 两者动态平衡\n领域专业化\n各个领域出现了专门性的语言，典型的如Windows系统下的.rc文件、Inno Setup的专门编写安装包的语言\n演进方式 ：通用语言 → 领域特定语言（DSL）\n语法简约化 演进方式 ：冗余语法 → 简洁表达 → 自然语言逼近（第五代编程语言探索方向）","六python简洁哲学的胜利#六.Python：简洁哲学的胜利":"","十一再版随笔#十一.再版随笔":"语言这个东西本身就是充满争议的，没有绝对的谁对谁错谁好谁坏，就像php被诸多程序员以“世界上最好的语言”来反讽，但终归还是广泛使用的，管它是什么语言，只要适合自己就是好语言。\n前一段时间看了个笑话，是C++和Python的对话，下面大致的记录一下\nC++问Python“你叫什么名字”，Python不回答，C++认为是自己不够礼貌，于是开始介绍自己，结果在说自己名字时卡壳了，因为出现了栈错误，它只能一边报错一边离开，等到C++走远了，Python这才大喊：“Python！”\n这笑话是想讲C++不好写，时不时就出错崩溃，而Python反应很慢，可能C++几百行代码都跑完了它还在入口，这个笑话做得很好的一点就是，同时阐明了C++和Python的缺点，也就是说，传达出了没有完美的语言这一概念","十后记#十.后记":"这个主题是我很久以前便想要开始研究的，借此次研究性学习得以实现，自是无比兴奋的，因而忙前忙后做了许多事情，虽然也确实添了些乱。\n作为文档的编写者，我就不如组长那般有如此身后的专业素养，和转于一个研究方向的钻劲了，只好接着自己学的不精的知识与自诩尚可的文学水平，苟且写下了这些最终呈现的文字，终究是有些惶恐，担心写下的内容存在瑕疵，如果各位读者能够发现文章中的错误，无论大小，万望可以在GitHub上的Issue中提交。","参考文献#参考文献":"川合秀实《三十天自制操作系统》| 人民邮电出版社 编程语言发展简史 作为程序员必须知道的编程语言编年史 王爽《汇编语言》| 清华大学出版社 百度百科-汇编语言 百度百科-助记符 Deep Learning - Ian Goodfellow、Yoshua Bengio、Aaron Courville 黑马程序员《网页设计与制作项目教程》（第2版） | 人民邮电出版社 从机器到智能：汇编语言的前世今生与未来 洛谷-P1009-阶乘之和 Java 张毅刚、赵光权、刘旺《单片机原理及应用》第三版 | 高等教育出版社 郭卫斌、罗勇军《算法竞赛入门到进阶》 | 清华大学出版社 MSDN-Microsoft Learn C++、C 和汇编程序\\C++语法参考 C++ reference 汪楚奇《深入浅出程序设计竞赛》 | 高等教育出版社 郁红英、王磊、武磊、李春强《计算机操作系统》（第三版） | 清华大学出版社","四高级语言的黎明cc的革命#四.高级语言的黎明：C/C++的革命":"","声明#声明":"文中“机器语言”板块中，机器语言代码由汇编代码通过Online x86 and x64 Intel Instruction Assembler实现，不确定是否存在转换问题，因此不具参考价值，只用于辅助理解机器语言的不便捷性。","序言#〇.序言":"计算机技术离不了各种编程语言，因此编程语言的发展可以在侧面上反应计算机技术的发展，编程语言的每一次演进都能见证着时代对于计算机技术的需求，可以说，编程语言的发展史，就是计算机技术的发展史。\n本研究性学习报告将从\"编程语言\"的历史着手，分析各个时代下不同语言的特征，试图窥见计算机技术的发展历程，同时，也想借此分析出究竟如何选择适合自己的编程语言。\n本文的基本结构如下：\n编程语言的史前雏形 机器语言与汇编语言 高级语言的演进路径 现代编程语言的多维发展 编程语言的发展规律与选择建议","研究性学习综合报告#研究性学习综合报告":""},"title":"_index"},"/docs/beepmusic/":{"data":{"beepmusic#BeepMusic":"BeepMusicV 2.1.2.0 终端版本（其实只有终端版，嘻嘻）\n跳转到开发者帮助","功能介绍#功能介绍":"一款可以将简谱转换为频率和时长的软件，转换结果可供Beep函数使用，使蜂鸣器实现奏乐效果","开发者帮助#开发者帮助":"HELPS文件夹下是项目帮助，有些教程文档（我怕我自己忘了怎么写了放进去的），其中Introduce.md会介绍项目的整体结构、各个文件的功能","播放帮助#播放帮助":"对于连续播放短声音困难的硬件，建议使用耳机将蜂鸣器转为电脑内音，经过测试，通常的设备在播放「千本桜」（t=180）时，即使使用耳机，仍然会有声音是无法放出的，因此可以采用t=45;参数播放，录制结果后对结果加速4.2倍左右","示例#示例":"《call of silence》\n参考Call of Silence简谱，基本遵循原谱内容，在后半部分和前面的细节部分做了一定的调整\n下面是标准的速度版本：\nt=72; -6_ 3_ 3. 3_ -7. -6__ 1-. -6_ 3_ 3. 3_ 7. +1__ 3-. 6_ +3_ +3. +3_ 7. +1__ 5-. 5_ 3__ 5-. +2_ +1__ +2.. +1__. 6-. 0--- 3_ 2_ 2_ 1_ 1_ 5_ 1 -7_ 1-. 3_ 2_ 2_ 1_ 1_ 3_ 2 3_ 1-. 3_ 2_ 2_ 1_ 1_ 5_ 5_ 5_ -7_ 1-. -6_ 1_ 2 2_ 1_ 2_ 3_ 2_ 2 1. 0 0_ +1_ 7_ 3__ 6. 0_ +1_. 7_ 3__ 1. 0_ +1_ 7_ 3__ 6 6__ 7 +2__ +1. 0_ +1_ 7 3__ 6_. 0_ +1_ 7_ 3__ 1_- 0_ +1_ 7_ +1__ +2 +3_ +3_. +1_ 7- 对于外放，蜂鸣器可能会吞掉一些声音，t=45;可能更合适","简谱表示规则#简谱表示规则":"基本音符：1(do), 2(re), 3(mi), 4(fa), 5(sol), 6(la), 7(si), 0(休止符)\n前缀：调整音高，+升高八度，-降低八度（可叠加，如++5）\n后缀：\n用于调整单个音的时值\n_：减时线（每增加一个，时值减半）\n-：增时线（每增加一个，时值加倍）\n.：附点（时值增加50%，最多两个）\n~：延音线（连接相同音高的连续音符使之合并）\n速度设置：t=x;（x拍/分钟，默认60），此值为BPM值，简谱一般会提供，不提供的也有参考信息进行查询，一些专业软件也提供检测功能","自行编译方式#自行编译方式":"法一：运行根目录下的build.bat文件，该文件会在release目录下生成两个可执行文件，分别是64位和32位，前者需要安装有g++，后者需要安装有i686-w64-mingw32-g++，如果没有前者，编译不进行，没有后者，则只编译64位版本 法二：运行MakeExe.bat，生成调试版 法三：使用编辑器打开build.bat，把不想要的位数版本删掉（在文档下方，已用注释分割出）","软件操作#软件操作":"初始输出如下：\n===============================================\rC++ 简谱转Beep播放器 (增强版)\r===============================================\r当前曲谱: t=120; 1 2 3 4 5 6 7 #1 +1\r音符解析结果:\r=============================================\r记谱 频率(Hz) 时长(ms) 类型\r------------------------------------------\r1 261 500 音符\r2 293 500 音符\r3 329 500 音符\r4 349 500 音符\r5 392 500 音符\r6 440 500 音符\r7 493 500 音符\r#1 277 500 音符 (升半音)\r+1 523 500 音符\r=============================================\r控制选项:\r[P] 播放音乐 [H] 帮助文本\r[I] 自定义曲谱 [Q] 退出程序\r请选择: 其中\n按下P，播放当前乐谱 按下H，可查看帮助文本 按下I，可输入自定义曲谱 按下Q，退出软件 按下I后，如果是误触，可以输入return（大小写不敏感）来退出录入状态，原本的曲谱可以保留\n软件初次启动时会注册Ctrl+Alt+Shift+S的热键，乐曲播放时可使用此热键停止\n默认设置下，按下P会看到这样的输出：\n请选择: 播放中... (按任意键停止) Play: 1 =\u003e Freq: 261 Hz, Duration: 500ms Play: 2 =\u003e Freq: 293 Hz, Duration: 500ms Play: 3 =\u003e Freq: 329 Hz, Duration: 500ms Play: 4 =\u003e Freq: 349 Hz, Duration: 500ms Play: 5 =\u003e Freq: 392 Hz, Duration: 500ms Play: 6 =\u003e Freq: 440 Hz, Duration: 500ms Play: 7 =\u003e Freq: 493 Hz, Duration: 500ms Play: #1 =\u003e Freq: 277 Hz, Duration: 500ms Play: +1 =\u003e Freq: 523 Hz, Duration: 500ms 按任意键以继续... play表示发出声响的音符，后面跟着音符的原文是便于查找，Freq标记声音频率，Duration标记持续时间\n特殊的，如下\n0\rRest: 0 =\u003e Duration: 1000ms 对于休止符，输出Rest，Freq参数会被省略"},"title":"_index"},"/docs/beepmusic/%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/":{"data":{"1标准方案原生cout#1.标准方案（原生cout）":"1.标准方案（原生cout）使用\\033[开头m结尾，中间包裹参数\n属性代码 功能 属性代码 功能 属性代码 功能 0 重置所有属性 30 黑色 40 黑色 1 高亮/加粗 31 红色 41 红色 2 暗淡 32 绿色 42 绿色 4 下划线 33 黄色 43 黄色 5 闪烁 34 蓝色 44 蓝色 7 反转 35 品红 45 品红 8 隐藏 36 青色 46 青色","2y_print#2.y_print":"256色输出的简化包装，项目中未采用此方案，在function.cpp中予以保留，可以在其他改版中使用但不建议PR中包含此内容（虽然我知道根本不会有人给这个项目交PR🤓）\ny_print(“hello”,10); 0 = 黑色 8 = 灰色 1 = 蓝色 9 = 淡蓝色 2 = 绿色 10 = 淡绿色 3 = 浅绿色 11 = 淡浅绿色 4 = 红色 12 = 淡红色 5 = 紫色 13 = 淡紫色 6 = 黄色 14 = 淡黄色 7 = 白色 15 = 亮白色"},"title":"彩色输出"},"/docs/beepmusic/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/":{"data":{"ini结构说明#ini结构说明":"还没写","项目结构介绍#项目结构介绍":"项目结构介绍结构与文件功能\nroot/ ├── .vscode/ vscode配置文件 │ ├── setting.json │ └── tasks.json ├── head/ │ ├── function.h 封装部分常用的函数（的声明部分） │ └── mainhead.h 头文件（提供大部分cpp）+函数声明（提供main.cpp） ├── HELPS/ │ ├── Color_Print.md 彩色输出帮助 │ ├── Hot_Key.md 热键帮助 │ ├── RC_help.md resources.rc文件的一些帮助内容 │ └── README.md 项目介绍 ├── Icons/ │ ├── favicon.ico 同上级目录的icon.ico，仅名称不同 │ ├── ori.jpg 软件图标原图 │ └── result.png 软件图标透明图 ├── release/ 编译结果（使用build.bat的） │ ├── installer/ 用于放置安装包相关内容 │ │ ├── install_win_64.exe 安装包（编译结果） │ │ └── installer_creator.iss 源码（模板） │ ├── BeepMusic_release_win_x64.exe │ └── BeepMusic_release_win_x86.exe ├── src_c/ │ ├── config.cpp 配置文件读写 │ ├── function.cpp 封装功能函数的定义，简化开发（如彩色输出） │ ├── mods.cpp 菜单栏选项对应激活的函数 │ ├── play_core.cpp 存放核心解析、演奏函数 │ ├── test.cpp 测试文件（保留做纪念也可随时启用进行测试） │ └── UI.cpp UI显示（其实就是输出看起来像是UI的东西） ├── tools/ │ └── XD开发工具-T1 │ ├── 开发工具.exe 热键查询+鼠标查询工具（之前用易语言写的小玩意） │ ├── 源码.e 程序源码，遵守本仓库协议开源 │ ├── iext.fnr 支持库文件 │ └── krnln.fnr 支持库文件 ├── 备忘.txt 更新备忘录，记录需要的功能等 ├── BeepMusic_alpha.exe 开发调试版本的编译结果 ├── build.bat 编译最终版本用的批处理，该批处理会同时编译resources.rc ├── icon.ico 软件图标 ├── LICENSE 开源协议 ├── main.cpp 主函数放置的文件，编译在此处进行 ├── MakeExe.bat 生成调试版用的批处理，不使用VScode的开发者可以借此编译 ├── README.md 本项目的readme └── resources.rc 资源文件，放置图标信息、软件信息"},"title":"文件结构"},"/docs/beepmusic/%E7%83%AD%E9%94%AE%E6%B3%A8%E5%86%8C/":{"data":{"热键注册帮助#热键注册帮助":"热键注册帮助微软键代码查询：Virtual-Key 代码\n键代码查询工具：本地路径./tools/XD开发工具-T1，仅支持10进制查询"},"title":"热键注册"},"/docs/beepmusic/rc%E6%96%87%E4%BB%B6%E5%B8%AE%E5%8A%A9/":{"data":{"":"rc文件帮助在 Windows 资源文件 (.rc) 中，这些关键字用于定义可执行文件的版本信息结构，以下是详细解释：","rc文件帮助#rc文件帮助":"","信息块解析#信息块解析":"BLOCK \"StringFileInfo\"\n作用：包含所有语言特定的字符串信息 结构： BLOCK \"StringFileInfo\"\rBEGIN\rBLOCK \"\" // 如 \"040904B0\"\rBEGIN\rVALUE \"Key\", \"Value\" // 实际显示的版本信息\rEND\rEND BLOCK \"VarFileInfo\"\n作用：定义文件的翻译信息（语言和代码页） 结构： BLOCK \"VarFileInfo\"\rBEGIN\rVALUE \"Translation\", , END 示例：VALUE \"Translation\", 0x0804, 1200 表示简体中文 Unicode","关键概念说明#关键概念说明":"部分 功能 典型值 文件属性区 定义二进制特性 FILEFLAGSMASK 有效标志位掩码 VS_FFI_FILEFLAGSMASK FILEFLAGS 实际版本标志 0x0L (正式版) FILEOS 目标操作系统 VOS_NT_WINDOWS32 FILETYPE 文件类型 VFT_APP (应用程序) FILESUBTYPE 文件子类型 VFT2_UNKNOWN 字符串信息区 用户可见信息 StringFileInfo 多语言字符串容器 语言标识 “080404B0” (简体中文) 变量信息区 语言配置 VarFileInfo 语言定义容器 Translation 默认语言设置 0x0804, 1200","工作流程#工作流程":"系统先读取 VarFileInfo 确定默认语言 在 StringFileInfo 中查找匹配的 LangID+CodePage 块 显示对应语言的字符串信息 文件属性区 (FILEOS等) 提供系统级元数据 ⚠️ 注意：当修改语言时，必须同步更新：\nStringFileInfo 中的语言块 ID (如 080404B0) VarFileInfo 中的 Translation 值 实际字符串内容（如需本地化） Windows 资源文件(.rc文件) 关于资源文件","核心结构解析#核心结构解析":"FILEFLAGSMASK\n作用：指定哪些位在 FILEFLAGS 字段中是有效的 值：通常设置为 VS_FFI_FILEFLAGSMASK（预定义值 0x3FL） 含义：表示只检查 FILEFLAGS 的低 6 位 FILEFLAGS\n作用：描述文件属性标志 常用值： 0x0L：正式版 VS_FF_DEBUG (0x1L)：调试版本 VS_FF_PRERELEASE (0x2L)：预发布版 VS_FF_PATCHED (0x4L)：已修补版本 VS_FF_PRIVATEBUILD (0x8L)：私有构建 示例：0x0L 表示标准发布版本 FILEOS\n作用：指定文件支持的操作系统 常用值： VOS_NT_WINDOWS32：Windows NT 32 位系统 VOS__WINDOWS32：通用 Windows 32 位 VOS_DOS_WINDOWS16：Windows 3.x 16 位 FILETYPE\n作用：定义文件类型 常用值： VFT_APP：应用程序 (EXE) VFT_DLL：动态链接库 VFT_DRV：设备驱动 VFT_FONT：字体文件 VFT_VXD：虚拟设备驱动 FILESUBTYPE\n作用：当 FILETYPE 需要细分时指定子类型 对 VFT_APP：必须设为 VFT2_UNKNOWN（无子类型） 对 VFT_DRV：可指定打印机/键盘等子类型 对 VFT_FONT：可指定矢量/位图字体"},"title":"rc文件帮助"},"/docs/dcc-script/":{"data":{"dcc-script#DCC script":"DCC scriptDCC是一个脚本语言，设计理念是“高效开发”，吸取了部分C++思想，并学习了易语言的思想，制定了当前语法\n实际上，DCC是为了简化我的纯文字游戏开发而制作的，因此，其尤为适合制作纯文字游戏，尤其是控制台输出的交互模式\n基础语法\r高级语法"},"title":"_index"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/":{"data":{"基础语法#基础语法":"基础语法下面将介绍DCC的基本语法和思想，使用基础语法，你几乎可以使用DCC的所有功能来编写纯DCC程序，可以编写出简单的控制台程序、模块文件\n函数调用\r特殊函数\r数据类型\r敏感性\r常量\r数值/逻辑运算符\r注释\r优先级\r缩进"},"title":"_index"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%BC%98%E5%85%88%E7%BA%A7/":{"data":{"改变优先级#改变优先级":"改变优先级DCC改变符号优先级，对于函数调用，在一个参数的位置，可以使用（）或()包裹一个语句，这个语句的执行结果会成为这个参数位的值，括号的包裹内，一定是函数名+参数（参数可空）的形式\n例子：\n；普通语句\r输出 “1”\r；嵌套语句\r输出 （转到文本 (取整 3-2)）"},"title":"优先级"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/":{"data":{"函数调用#函数调用":"函数调用DCC是借助函数实现功能的脚本语言，因此几乎所有功能都需要借助函数实现，函数的调用形式如下：\n函数名 [参数1][,参数2][,参数3][,......] 参数是可省略的，但针对指定个参数的函数，对应数目的逗号需要要保留，下面列出来的几个语句都是合法的：\n输出 ,\r输出 \"你好\",\r输出 \"你好\",1 函数名支持使用一切Unicode字符定义，因此可以包含多种语言"},"title":"函数调用"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%B8%B8%E9%87%8F/":{"data":{"常量#常量":"常量DCC拥有系统常量和自定义常量，使用时需使用#进行表达，如下面的示例：\n#asm\r#iostream\r#cpp\r#换行符\r#逻辑型 实际使用效果：\n定义变量 #大数,20"},"title":"常量"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%8F%E6%84%9F%E6%80%A7/":{"data":{"敏感性#敏感性":"敏感性DCC对大小写敏感但对符号不敏感，例如，Get和GET对于DCC而言是两个函数，但[]和【】甚至【]对于DCC是同一个符号，下面以引号为例：\n；合法的引号：\r“你好”\r\"你好\"\r“你好\"\r\"你好”\r”你好“\r“你好“\r”你好”\r”你好\"\r\"你好“"},"title":"敏感性"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E5%80%BC%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/":{"data":{"数值逻辑运算符#数值/逻辑运算符":"数值/逻辑运算符DCC支持运算符号如下：\n*\r×\r/\r÷\r%\r+\r-\r！\r!\r\u0026\r^\r\u0026\u0026\r||\r^^\r**\r~\r\u003e\u003e\r\u003c\u003c\r|\rand\ror\rnot\r且\r或\r非"},"title":"数值、逻辑运算符"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/":{"data":{"数据类型#数据类型":"数据类型DCC原生支持数据类型包括整数型、小数型、双精度小数型、逻辑型、文本型、大数等数据类型，对于常数的表达，DCC也有相应的符号来描述常数的数据类型\n对于数字，直接写出即可，是否小数会根据前后的代码智能判断，对于文本型，使用全角或半脚引号包裹（参见敏感性章节的示例），对于真、假、true、FALSE（不区分大小写）这四个关键字，则认为是逻辑型数据（布尔型）"},"title":"数据类型"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%B3%A8%E9%87%8A/":{"data":{"注释#注释":"注释DCC使用全角或半角的分号来书写注释，如下：\n；注释\r;注释 出现这种注释标记，从标记后面一直到这一行的结束都是注释内容，内容不会生效也不会编译进程序\n有时，为了灵活的嵌套，DCC还会支持收尾包裹式的注释，使用@或/**/标记首尾，从第一个标记到下一个标记之间的内容都是注释，@符号（仅限@）在文本常量中出现不会被视为注释的标记\n“这是文本@这还是文本”@这里是注释@\"这里不是注释\"\r“你好，@这里是文本，不会成为注释@，你好”\r输出@注释@ （转到文本 3@这也是注释@）\r/*这种注释和C语言的性质相同*/ 上面这两种注释是支持多行的"},"title":"注释"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/":{"data":{"特殊函数#特殊函数":"特殊函数DCC拥有一些特殊函数会特殊高亮，这些函数在编译中会被特殊处理，也是DCC的功能核心，这些功能即使不引入库也可以照常使用，而这些函数名也就成为了DCC的保留字，不允许其他任何库用作函数名\n函数名 类型 功能 如果 流程控制 判断参数是真还是假 如果结束 流程控制 标志如果彻底结束 否则 流程控制 如果的参数为假进入该分支 if 流程控制 同上“如果”，下面的英文中文都是对应的，不再做解释 else 流程控制 --- endif 流程控制 --- 计次循环 流程控制 循环开始，指定循环次数并给出变量记录 记次循环尾 流程控制 标记计次循环结束 跳出循环 流程控制 跳出当前循环，代码跳转到循环尾后 到循环尾 流程控制 到达循环尾前，进入下一次循环或者完成循环 条件循环 流程控制 根据条件决定是否循环 for 流程控制 --- endfor 流程控制 --- break 流程控制 --- continue 流程控制 --- while 流程控制 --- 定义函数 函数操作 定义一个函数 结束函数定义 函数操作 完成函数定义 def 函数操作 --- enddef 函数操作 --- 创建板块 作用域 创建一个板块，独立于整个文件 结束创建板块 作用域 结束板块的创建，示意内容全部写完 creatd 作用域 --- endcd 作用域 --- 包裹体 作用域 暂定的功能，实际功效待定 包裹体尾 作用域 暂定的功能，实际功效待定 block 作用域 --- endblock 作用域 ---"},"title":"特殊函数"},"/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E7%BC%A9%E8%BF%9B/":{"data":{"缩进#缩进":"缩进DCC借助缩进理解语义\n对于纯DCC代码，不会存在缩进，缩进只在嵌套中存在（见下一节）\n下面是存DCC代码示例：\n打开剧情\r如果 （转为文本 （输入））=10\r输出 \"ciallo\"\r如果结束\r展示剧情 10"},"title":"缩进"},"/docs/dcc-script/2.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/":{"data":{"高级语法#高级语法":"高级语法DCC拥有一些高级语法，这些语法会使得DCC拥有更强的互联能力，变得高度可扩展"},"title":"_index"},"/docs/dcc-script/2.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/%E5%B5%8C%E5%A5%97/":{"data":{"":"嵌套","c嵌套#C++嵌套":"使用+++可以包裹C++代码，这三个字符单独占一行，不允许注释\n前语句\r+++\r#include\rint main(){\rstd::cout\u003c\u003c\"hello word\";\r}\r+++\r后语局 C++代码在文件任意位置定义即可在全局中调用","json嵌套#JSON嵌套":"DCC通过一定方式是可以嵌套JSON的，因此高亮需要对JSON语法进行支持，JSON内嵌时，相对前行和后行会有缩进，具体缩进多少不会严格规定，如：\n前语句\r{\r\"name\": \"Tom\"\r}\r后语句 嵌套的JSON代码需要使用JSON语法进行高亮","嵌套#嵌套":""},"title":"嵌套"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/":{"data":{"":"翻译版本：2025/8/27","支持的平台#支持的平台":"Linux MacOS Windows WebAssembly","特性#特性":"函数式风格。灵感来源于 1 和 React 无依赖 跨平台 简洁优雅的语法（个人观点） 键盘和鼠标导航 支持 UTF8 和 全角字符 (→ 测试) 支持动画效果。演示 1, 演示 2 支持绘图功能。演示 通过示例和教程学习 支持多种构建系统和软件包 良好的工程实践：文档、测试、模糊测试、性能测试、自动化 CI、自动化打包等","示例#示例":"#include #include #include int main() { using namespace ftxui; // 创建包含三个文本元素的简单文档 Element document = hbox({ text(\"左侧\") | border, text(\"中间\") | border | flex, text(\"右侧\") | border, }); // 创建宽度全屏、高度自适应文档的屏幕 auto screen = Screen::Create( Dimension::Full(), // 宽度 Dimension::Fit(document) // 高度 ); // 将文档渲染到屏幕上 Render(screen, document); // 将屏幕输出到控制台 screen.Print(); } 预期输出：\n┌────┐┌────────────────────────────────────┐┌─────┐ │左侧││中间 ││右侧 │ └────┘└────────────────────────────────────┘└─────┘","简介#简介":"FTXUI 是一个简单、跨平台的 C++ 库，用于构建终端用户界面！"},"title":"_index"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/cpp20-modules/":{"data":{"":"此功能仍处于开发阶段，API 可能在未来的版本中发生变更。\n我们需要您的贡献来帮助改进 FTXUI 中 C++20 模块的兼容性和可用性。\n如果您遇到任何问题或有建议，请提交 Issue。\nFTXUI 实验性地支持 C++20 模块，以减少编译时间并改善代码组织。每个头文件都有一个对应的模块。\n使用 FTXUI_BUILD_MODULES 选项来构建 FTXUI 项目本身以提供 C++20 模块，例如使用 CMake 和 Ninja：\ncmake \\ -DCMAKE_GENERATOR=Ninja \\ -DFTXUI_BUILD_MODULES=ON \\ .. ninja 要使用模块，您需要兼容 C++20 的编译器、CMake 3.20 或更高版本，并使用兼容的生成器（如 Ninja）。\n注意，Makefile 生成器不支持模块。\n然后，在您自己的代码中，您可以正常使用这些模块：\nimport ftxui; int main() { auto screen = ftxui::ScreenInteractive::TerminalOutput(); auto button = ftxui::Button(\"点我\", screen.QuitClosure()); screen.Loop(button); return 0; } 注意，ftxui 是一个便捷模块，它简单地聚合了所有模块：\nexport import ftxui.component; export import ftxui.dom; export import ftxui.screen; export import ftxui.util; 您也可以根据需要仅导入特定的模块。\n要使用 CMake 正确查找和链接模块，请使用 target_link_libraries 来获取正确的编译器、链接器等标志。\ntarget_link_libraries(my_executable #...其他依赖... PRIVATE ftxui::modules )","模块列表#模块列表":"这些模块直接对应于相应的头文件，或是一组相关的头文件以提供更便捷的接口。以下是可用的模块：\nftxui ftxui.component ftxui.component.Animation ftxui.component.CapturedMouse ftxui.component.Component ftxui.component.ComponentBase ftxui.component.ComponentOptions ftxui.component.Event ftxui.component.Loop ftxui.component.Mouse ftxui.component.Receiver ftxui.component.ScreenInteractive ftxui.component.Task ftxui.dom ftxui.dom.Canvas ftxui.dom.Deprecated ftxui.dom.Direction ftxui.dom.Elements ftxui.dom.FlexboxConfig ftxui.dom.LinearGradient ftxui.dom.Node ftxui.dom.Requirement ftxui.dom.Selection ftxui.dom.Table ftxui.screen ftxui.screen.Box ftxui.screen.Color ftxui.screen.ColorInfo ftxui.screen.Deprecated ftxui.screen.Image ftxui.screen.Pixel ftxui.screen.Screen ftxui.screen.String ftxui.screen.Terminal ftxui.util ftxui.util.AutoReset ftxui.util.Ref"},"title":"C++20 模块"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/examples/":{"data":{"":"button.cpp\rbutton_animated.cpp\rbutton_in_frame.cpp\rbutton_style.cpp\rcanvas_animated.cpp\rcheckbox.cpp\rcheckbox_in_frame.cpp\rcollapsible.cpp\rcomposition.cpp\rcustom_loop.cpp\rdropdown.cpp\rdropdown_custom.cpp\rflexbox_gallery.cpp\rfocus.cpp\rfocus_cursor.cpp\rgallery.cpp\rhomescreen.cpp\rinput.cpp\rinput_in_frame.cpp\rinput_style.cpp\rlinear_gradient_gallery.cpp\rmaybe.cpp\rmenu.cpp\rmenu2.cpp\rmenu_entries.cpp\rmenu_entries_animated.cpp\rmenu_in_frame.cpp\rmenu_in_frame_horizontal.cpp\rmenu_multiple.cpp\rmenu_style.cpp\rmenu_underline_animated_gallery.cpp\rmodal_dialog.cpp\rmodal_dialog_custom.cpp\rnested_screen.cpp\rprint_key_press.cpp\rradiobox.cpp\rradiobox_in_frame.cpp\rrenderer.cpp\rresizable_split.cpp\rscrollbar.cpp\rselection.cpp\rslider.cpp\rslider_direction.cpp\rslider_rgb.cpp\rtab_horizontal.cpp\rtab_vertical.cpp\rtextarea.cpp\rtoggle.cpp\rwindow.cpp\rwith_restored_io.cpp\rborder.cpp\rborder_colored.cpp\rborder_style.cpp\rcanvas.cpp\rcolor_gallery.cpp\rcolor_info_palette256.cpp\rcolor_truecolor_HSV.cpp\rcolor_truecolor_RGB.cpp\rdbox.cpp\rgauge.cpp\rgauge_direction.cpp\rgraph.cpp\rgridbox.cpp\rhflow.cpp\rhtml_like.cpp\rlinear_gradient.cpp\rpackage_manager.cpp\rparagraph.cpp\rseparator.cpp\rseparator_style.cpp\rsize.cpp\rspinner.cpp\rstyle_blink.cpp\rstyle_bold.cpp\rstyle_color.cpp\rstyle_dim.cpp\rstyle_gallery.cpp\rstyle_hyperlink.cpp\rstyle_inverted.cpp\rstyle_italic.cpp\rstyle_strikethrough.cpp\rstyle_underlined.cpp\rstyle_underlined_double.cpp\rtable.cpp\rvbox_hbox.cpp\rvflow.cpp"},"title":"示例文件"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/ftxui/":{"data":{"ftxui#ftxui":"ftxui\nFTXUI 分为三个模块，每个模块都构建在前一个模块之上：\nftxui/screen - 底层渲染 ftxui/dom - 布局与组合 ftxui/component - 用户交互","ftxuicomponent#ftxui/component":"增加：\nftxui::Component：有状态的交互式组件。 内置组件：Checkbox、Input、Menu、Button。 支持键盘/光标输入和组合。 适用于交互式应用程序。\n–\u003e跳转至文档\n模块可以独立使用，也可以组合使用：screen → dom → component。","ftxuidom#ftxui/dom":"提供：\nftxui::Element：用于布局和用户界面的树形结构。 可组合和响应式的元素。 Render() 函数，用于绘制到 Screen 上。 适用于结构化和样式化的用户界面。\n–\u003e跳转至文档","ftxuiscreen#ftxui/screen":"定义：\nftxui::Screen：一个包含样式化字符的二维网格。 ftxui::Pixel：渲染的基本单位。 辅助工具，如 ftxui::Color 和 Dimension。 用于直接终端绘制和样式设置。\n–\u003e跳转至文档"},"title":"_index"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/ftxui/component/":{"data":{"":"ftxui::component 模块定义了产生交互式组件的逻辑，这些组件能够响应用户事件（键盘、鼠标等）。\nexamples 章节提供了一系列示例。\nftxui::ScreenInteractive 定义了渲染组件的主循环。\nftxui::Component 是指向 ftxui::ComponentBase 的共享指针。后者定义了：\nftxui::ComponentBase::Render()：如何渲染界面。 ftxui::ComponentBase::OnEvent()：如何响应事件。 ftxui::ComponentBase::Add()：在两个组件之间构建父子关系。组件树用于定义如何使用键盘进行导航。 ftxui::Element 用于渲染单个帧。\nftxui::Component 用于渲染动态用户界面，生成多个帧，并在事件发生时更新其状态。\n多个组件的图库。（演示）\n所有预定义的组件可在 “ftxui/dom/component.hpp” 中找到。\n\\include ftxui/component/component.hpp","component-catchevent#事件捕获":"由 \\ref ftxui/component/component.hpp 中的 ftxui::CatchEvent() 生成。此组件装饰其他组件，在底层组件之前捕获事件。\n示例：\nauto screen = ScreenInteractive::TerminalOutput(); auto renderer = Renderer([] { return text(\"我的界面\"); }); auto component = CatchEvent(renderer, [\u0026](Event event) { if (event == Event::Character('q')) { screen.ExitLoopClosure()(); return true; } return false; }); screen.Loop(component); ftxui::CatchEvent 也可以用作装饰器：\ncomponent = component | CatchEvent(handler_1) | CatchEvent(handler_2) | CatchEvent(handler_3) ;","component-checkbox#复选框":"此组件定义一个复选框。它是一个可以打开/关闭的单个条目。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Checkbox() 生成。\n@htmlonly\n@endhtmlonly","component-collapsible#可折叠组件":"对于用户可切换显示/隐藏的视觉元素非常有用。本质上是 ftxui::Checkbox() 和 ftxui::Maybe() 组件的组合。\nauto collapsible = Collapsible(\"显示更多\", inner_element);","component-container#容器":"","component-dropdown#下拉菜单":"下拉菜单是一个组件，打开时显示一个元素列表供用户选择。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Dropdown() 生成。","component-force-redraw#强制帧重绘":"通常，ftxui::ScreenInteractive::Loop() 负责在处理完新的事件组（例如键盘、鼠标、窗口调整大小等）后绘制新帧。但是，您可能希望响应FTXUI未知的任意事件。为此，您必须通过线程使用 ftxui::ScreenInteractive::PostEvent（这是线程安全的）发布事件。您需要发布 ftxui::Event::Custom 事件。\n示例：\nscreen-\u003ePostEvent(Event::Custom); 如果不需要处理新事件，可以使用：\nscreen-\u003eRequestAnimationFrame();","component-horizontal#水平容器":"由 “ftxui/component/component.hpp” 中的 ftxui::Container::Horizontal() 生成。它水平显示组件列表并处理键盘/鼠标导航。","component-maybe#条件显示组件":"由 \\ref ftxui/component/component.hpp 中的 ftxui::Maybe() 生成。此组件可用于通过布尔值或谓词显示/隐藏任何其他组件。\n使用布尔值的示例：\nbool show = true; auto component = Renderer([]{ return \"Hello World!\"; }); auto maybe_component = Maybe(component, \u0026show) 使用谓词的示例：\nauto component = Renderer([]{ return \"Hello World!\"; }); auto maybe_component = Maybe(component, [\u0026] { return time \u003e 10; }) 通常，ftxui::Maybe 也可以用作装饰器：\ncomponent = component | Maybe(\u0026a_boolean) | Maybe([\u0026] { return time \u003e 10; }) ;","component-radiobox#单选按钮":"单选框组件。这是一个条目列表，其中一项可以被选中。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Radiobox() 生成。\n@htmlonly\n@endhtmlonly","component-renderer#渲染器":"由 \\ref ftxui/component/component.hpp 中的 ftxui::Renderer() 生成。此组件通过使用不同的函数来渲染界面，从而装饰另一个组件。\n示例：\nauto inner = [...] auto renderer = Renderer(inner, [\u0026] { return inner-\u003eRender() | border }); ftxui::Renderer 也支持组件装饰器模式：\nauto component = [...] component = component | Renderer([](Element e) { return e | border)) | Renderer(bold) 作为简写形式，您还可以将组件与元素装饰器组合：\nauto component = [...] component = component | border | bold;","component-resizable-split#可调整分割":"定义两个子组件之间的水平或垂直分隔。分隔线的位置可通过鼠标调整和控制。有四种可能的分隔方式：\nftxui::ResizableSplitLeft() ftxui::ResizableSplitRight() ftxui::ResizableSplitTop() ftxui::ResizableSplitBottom() 来自 “ftxui/component/component.hpp” 示例：\n@htmlonly\n@endhtmlonly","component-slider#滑块":"表示一个滑块对象，它由一个带有分箱中间间隔的范围组成。可以通过 ftxui::Slider() 创建。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Slider() 生成。","component-tab#标签页容器":"由 “ftxui/component/component.hpp” 中的 ftxui::Container::Tab() 生成。它接收一个组件列表并只显示其中一个。这对于实现标签栏非常有用。\n垂直：\n水平：","component-toggle#切换按钮":"一种特殊类型的菜单。条目水平显示。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Toggle() 生成。\n@htmlonly\n@endhtmlonly","component-vertical#垂直容器":"由 “ftxui/component/component.hpp” 中的 ftxui::Container::Vertical() 生成。它垂直显示组件列表并处理键盘/鼠标导航。","菜单-component-menu#菜单 （component-menu）":"定义一个菜单对象。它包含一个条目列表，其中一项被选中。\n示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Menu() 生成。\n@htmlonly\n@endhtmlonly","输入框componentinput#输入框（component::input）":"示例：\n由 “ftxui/component/component.hpp” 中的 ftxui::Input() 生成。\n@htmlonly\n@endhtmlonly","过滤输入#过滤输入":"可以使用 ftxui::CatchEvent 过滤输入组件接收的字符。\nstd::string phone_number; Component input = Input(\u0026phone_number, \"电话号码\"); // 过滤非数字字符。 input |= CatchEvent([\u0026](Event event) { return event.is_character() \u0026\u0026 !std::isdigit(event.character()[0]); }); // 过滤超过10个字符后的输入。 input |= CatchEvent([\u0026](Event event) { return event.is_character() \u0026\u0026 phone_number.size() \u003e= 10; });"},"title":"component（组件模块）"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/ftxui/dom/":{"data":{"dom-border#边框":"在元素周围添加边框。\n代码：\nborder(text(\"元素\")) 终端输出：\n┌──────┐ │元素 │ └──────┘ Note\n您可以使用管道操作符实现相同的行为。\n代码：\ntext(\"元素\") | border 边框还有多种样式，如下所示：\nnamespace ftxui { Element border(Element); Element borderLight(Element); Element borderHeavy(Element); Element borderDouble(Element); Element borderRounded(Element); Element borderEmpty(Element); Decorator borderStyled(BorderStyle); Decorator borderWith(Pixel); }","dom-canvas#画布":"参见 API auto c = Canvas(100, 100); c.DrawPointLine(10, 10, 80, 10, Color::Red); auto element = canvas(c); 可以在 ftxui::Canvas 上使用盲文、方块或简单字符进行绘制：\n简单示例：\n复杂示例：","dom-colors#颜色":"大多数终端控制台可以显示彩色文本和彩色背景。FTXUI 支持所有调色板：\nDecorator color(Color); Decorator bgcolor(Color); 颜色图库：","dom-colors-palette-16#16色调色板":"大多数终端支持以下颜色：\n默认色\n黑色\n深灰色\n浅灰色\n白色\n蓝色\n亮蓝色\n青色\n亮青色\n绿色\n亮绿色\n洋红色\n亮洋红色\n红色\n亮红色\n黄色\n亮黄色\n使用管道操作符应用上述颜色的示例：\ntext(\"蓝色前景\") | color(Color::Blue); text(\"蓝色背景\") | bgcolor(Color::Blue); text(\"黑底白字\") | color(Color::Black) | bgcolor(Color::White);","dom-colors-palette-256#256色调色板":"支持256色的终端。 @htmlonly\n@endhtmlonly\ntext(\"亮粉色\") | color(Color::HotPink);","dom-colors-true-color#真彩色":"支持真彩色的终端，您可以直接使用24位RGB色彩空间：\n使用以下构造函数指定颜色的RGB或HSV值：\n有两个构造函数：\nftxui::Color::RGB(uint8_t red, uint8_t green, uint8_t blue); ftxui::Color::HSV(uint8_t hue, uint8_t saturation, uint8_t value); @htmlonly\n@endhtmlonly","dom-gauge#进度条":"这是一个表示进度比例的视觉元素。\n代码：\nborder(gauge(0.5)) 终端输出：\n┌────────────────────────────────────────────────────────────────────────────┐ │██████████████████████████████████████ │ └────────────────────────────────────────────────────────────────────────────┘ 进度条可以多种方向显示，如下所示：\nnamespace { Element gauge(float ratio); Element gaugeLeft(float ratio); Element gaugeRight(float ratio); Element gaugeUp(float ratio); Element gaugeDown(float ratio); Element gaugeDirection(float ratio, GaugeDirection); }","dom-graph#图表":"@htmlonly\n@endhtmlonly\n参见：\nElement graph(GraphFunction);","dom-layout#布局":"使元素能够以以下方式排列：\n使用 ftxui::hbox 水平排列 使用 ftxui::vbox 垂直排列 使用 ftxui::gridbox 在网格中排列 使用 ftxui::flexbox 沿一个方向环绕排列。 使用 ftxui::hbox、ftxui::vbox 和 ftxui::filler 的示例。\n使用 ftxui::gridbox 的示例：\n使用 flexbox 的示例：\n查看此示例及相关的演示。\n元素也可以使用 ftxui::flex 装饰器变得灵活。\n代码：\nhbox({ text(\"左\") | border , text(\"中\") | border | flex, text(\"右\") | border, }); 终端输出：\n┌──┐┌─────────────────────────────────────────────────────┐┌───┐ │左││中 ││右│ └──┘└─────────────────────────────────────────────────────┘└───┘ 代码：\nhbox({ text(\"左\") | border , text(\"中\") | border | flex, text(\"右\") | border | flex, }); 终端输出：\n┌──┐┌───────────────────────────────┐┌───────────────────────────────┐ │左││中 ││右 │ └──┘└───────────────────────────────┘└───────────────────────────────┘","dom-linear-gradient#线性渐变":"FTXUI 支持线性渐变。可应用于前景或背景。\nDecorator color(const LinearGradient\u0026); Decorator bgcolor(const LinearGradient\u0026); ftxui::LinearGradient 由角度（度）和颜色停止点列表定义。\nauto gradient = LinearGradient() .Angle(45) .AddStop(0.0, Color::Red) .AddStop(0.5, Color::Green) .AddStop(1.0, Color::Blue); 您也可以使用简化的构造函数：\nLinearGradient(Color::Red, Color::Blue); LinearGradient(45, Color::Red, Color::Blue); 参见演示。","dom-paragraph#段落":"类似于 ftxui::text，但会根据容器的宽度将单个单词沿多行换行。\n示例代码：\nparagraph(\"一段很长的文本\") 更详细的示例请参阅详细示例。段落还包括许多其他变体，如下所示：\nnamespace ftxui { Element paragraph(std::string text); Element paragraphAlignLeft(std::string text); Element paragraphAlignRight(std::string text); Element paragraphAlignCenter(std::string text); Element paragraphAlignJustify(std::string text); }","dom-separator#分隔符":"显示垂直/水平线，以视觉上将容器的内容分成两部分。\n代码：\nborder( hbox({ text(\"左\"), separator(), text(\"右\") }) ) 终端输出：\n┌──┬──┐ │左│右│ └──┴──┘ 分隔符有多种样式，如下所示：\nnamespace ftxui { Element separator(void); Element separatorLight(); Element separatorHeavy(); Element separatorDouble(); Element separatorEmpty(); Element separatorStyled(BorderStyle); Element separator(Pixel); Element separatorCharacter(std::string); Element separatorHSelector(float left, float right, Color background, Color foreground); Element separatorVSelector(float up, float down, Color background, Color foreground); }","dom-style#样式":"除了彩色文本和彩色背景外，许多终端还支持文本效果，例如：bold（粗体）、italic（斜体）、dim（暗淡）、underlined（下划线）、inverted（反色）、blink（闪烁）。\nElement bold(Element); Element italic(Element); Element dim(Element); Element inverted(Element); Element underlined(Element); Element underlinedDouble(Element); Element strikethrough(Element); Element blink(Element); Decorator color(Color); Decorator bgcolor(Color); Decorator colorgrad(LinearGradient); Decorator bgcolorgrad(LinearGradient); 示例\n要使用这些效果，只需用所需的效果包装您的元素：\nunderlined(bold(text(\"此文本为粗体并带下划线\"))) 或者，使用管道操作符将其链接到您的元素：\ntext(\"此文本为粗体\") | bold | underlined","dom-table#表格":"能够轻松地将数据格式化为整洁的表格状视觉形式。\n代码示例：","dom-text#文本":"此模块定义了一组层次化的 ftxui::Element（元素）。元素管理布局，并且可以响应终端尺寸变化。请注意以下使用此模块创建简单布局并运用多个操作符的示例：\n@subpage module-dom-examples 章节提供了一系列示例。\n示例：\nnamespace ftxui { ... // 定义文档 Element document = vbox({ text(\"窗口\") | bold | color(Color::Blue), gauge(0.5) text(\"页脚\") }); // 通过调用 `ftxui::border` 装饰器函数添加边框。 document = border(document); // 使用管道操作符添加另一个边框。 document = document | border. // 使用 |= 操作符添加另一个边框。 document |= border ... } 元素列表\n所有元素均已包含，可通过引入相应的头文件访问：\n#include \\include{strip} “ftxui/dom/elements.hpp”\n文本最简单的控件。它显示文本。\ntext(\"我是一段文本\"); 我是一段文本。","dom-vtext#垂直文本":"与 ftxui::text 相同，但垂直显示。\n代码：\nvtext(\"你好\"); 终端输出：\n你 好","dom-window#窗口":"ftxui::window 是一个带有额外标题的 ftxui::border。要在元素周围添加窗口，请将其包装并指定一个字符串作为标题。 代码：\nwindow(\"窗口\", text(\"元素\")) 终端输出：\n┌窗口─┐ │元素 │ └─────┘"},"title":"dom（布局模块）"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/ftxui/screen/":{"data":{"ftxuicolor#ftxui::Color":"The @ref ftxui::Color class is used to define foreground and background colors for each @ref ftxui::Pixel.\nIt supports various color spaces and predefined palettes. FTXUI will dynamically fallback to the closest available color in the terminal if the requested color is not supported by the terminal.\nColor Spaces\nDefault: ftxui::Color::Default (terminal’s default color) 16-color palette Demo: ftxui::Color::Black, ftxui::Color::Red, … 256-color palette Demo: ftxui::Color::Chartreuse1, ftxui::Color::DarkViolet, … True color (24bit) [Demo](https://arthursonzogni.github.io/FTXUI/examples/?file=dom/color_truecolor_HSV: ftxui::Color::RGB(uint8_t red, uint8_t green, uint8_t blue) ftxui::Color::HSV(uint8_t h, uint8_t s, uint8_t v). Note\nYou can query the terminal capability using @ref ftxui::Terminal::ColorSupport();\nThis can manually be set using @ref ftxui::Terminal::SetColorSupport().","ftxuidimension#ftxui::Dimension":"The @ref ftxui::Dimension utility controls screen sizing:\nDimension::Full() — use full terminal width or height Dimension::Fit(element) — size to fit the rendered @ref ftxui::Element Dimension::Fixed(n) — use exactly n columns or rows These values are to be passed to ftxui::Screen::Create().\n@ref ftxui::Screen::Create() provides two overloads:\nScreen::Create(Dimension) sets both width and height to the same kind of dimension Screen::Create(Dimension width, Dimension height) allows distinct control per axis auto screen = ftxui::Screen::Create( ftxui::Dimension::Full(), // width ftxui::Dimension::Fixed(10) // height ); Once created, render an element and display the result:\nftxui::Render(screen, element); screen.Print();","ftxuipixel#ftxui::Pixel":"Each cell in the screen grid is a @ref ftxui::Pixel, which holds:\nUnicode codepoint. character @ref ftxui::Color: foreground_color background_color Booleans: blink bold dim italic inverted (swap foreground and background colors) underlined underlined_double strikethrough auto screen = ftxui::Screen::Create( ftxui::Dimension::Fixed(5), ftxui::Dimension::Fixed(5), ); auto\u0026 pixel = screen.PixelAt(3, 3); pixel.character = U'X'; pixel.bold = true; pixel.foreground_color = ftxui::Color::Red; pixel.background_color = ftxui::Color::RGB(0, 255, 0); screen.Print(); Note\nPixelAt(x, y) performs bounds checking and returns a reference to the pixel at the specified coordinate. If out-of-bounds, a dummy pixel reference is returned.\nEach cell in the screen is a @ref ftxui::Pixel. You can modify them using:\nauto\u0026 pixel = screen.PixelAt(x, y); pixel.character = U'X'; pixel.bold = true; pixel.foreground_color = Color::Red;","ftxuiscreen#ftxui::Screen":"The ftxui::screen module is the low-level foundation. It can be used standalone, but it is primarily designed to be used together by ftxui::dom and ftxui::component modules.\nIt provides a @ref ftxui::Screen.\nftxui::ScreenThe @ref ftxui::Screen class represents a 2D grid of styled characters that can be rendered to a terminal.\nIt provides methods to create a screen, access pixels, and render elements.\nYou can access the individual cells (@ref ftxui::Pixel) of the screen using the @ref ftxui::Screen::PixelAt method, which returns a reference to the pixel at the specified coordinates.\nExample\n#include #include void main() { auto screen = ftxui::Screen::Create( ftxui::Dimension::Full(), // Use full terminal width ftxui::Dimension::Fixed(10) // Fixed height of 10 rows ); // Access a specific pixel at (10, 5) auto\u0026 pixel = screen.PixelAt(10, 5); // Set properties of the pixel. pixel.character = U'X'; pixel.foreground_color = ftxui::Color::Red; pixel.background_color = ftxui::Color::RGB(0, 255, 0); pixel.bold = true; // Set bold style screen.Print(); // Print the screen to the terminal } Note\nIf the coordinates are out of bounds, a dummy pixel is returned.\nThe screen can be printed to the terminal using @ref ftxui::Screen::Print() or converted to a std::string with @ref ftxui::Screen::ToString().\nPrint() auto screen = ...; screen.Print(); ToString() auto screen = ...; std::cout \u003c\u003c screen.ToString(); Note that you can reset the cursor position to the top-left corner of the screen after printing by calling @ref ftxui::Screen::ResetCursorPosition().\nExample\nauto screen = ...; while(true) { // Drawing operations: ... // Print the screen to the terminal. Then reset the cursor position and the // screen content. std::cout \u003c\u003c screen.ToString(); std::cout \u003c\u003c screen.ResetCursorPosition(/*clear=*/true); std::cout \u003c\u003c std::flush; // Sleep for a short duration to control the refresh rate. std::this_thread::sleep_for(std::chrono::milliseconds(100)); }"},"title":"screen"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/getting-started/":{"data":{"":"","入门模板#入门模板":"要获取完整可运行的项目，请克隆官方入门仓库：\ngit clone https://github.com/ArthurSonzogni/ftxui-starter 按照该仓库 README.md 中的构建说明进行操作。","安装-ftxui#安装 FTXUI":"要在您的项目中配置FTXUI，请遵循安装指南，该指南提供了针对多种构建系统和包管理器的说明。","最小示例#最小示例":"将以下代码保存为 main.cpp：\n#include #include #include int main() { using namespace ftxui; Element document = hbox({ text(\"左侧\") | border, text(\"中间\") | border | flex, text(\"右侧\") | border, }); auto screen = Screen::Create(Dimension::Full(), Dimension::Fit(document)); Render(screen, document); screen.Print(); } 使用您喜欢的构建系统进行构建和运行。\n如果不确定如何操作，请从安装页面描述的其中一种方法开始。\n预期输出：\n┌────┐┌────────────────────────────────────┐┌─────┐ │左侧││中间 ││右侧 │ └────┘└────────────────────────────────────┘└─────┘"},"title":"开始使用"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/":{"data":{"":"","后续步骤#后续步骤":"安装 FTXUI 后：\n开始使用：编写并运行您的第一个程序 示例：了解 FTXUI 的功能 模块说明： DOM 组件 屏幕","支持的安装方式#支持的安装方式":"CMake Bazel Vcpkg Conan 手动安装 Nix Debian/Ubuntu Arch Linux openSUSE XMake","概述#概述":"FTXUI 可通过多种构建系统和包管理器集成到您的项目中。\n本页面是可用集成方法的入口指南。","贡献指南#贡献指南":"如果您使用其他构建系统或包管理器，欢迎贡献安装指南。\n您也可以在 GitHub issue tracker 中提交功能请求。"},"title":"安装指南"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/arch/":{"data":{"":"FTXUI 已在 AUR（Arch 用户仓库）中打包。使用 AUR helper安装：\nyay -S ftxui 您也可以手动从 https://aur.archlinux.org/packages/ftxui 下载 PKGBUILD。\n安装完成后，您可以在 CMake 项目中使用它，只需在 CMakeLists.txt 中添加以下内容：\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) Note\n这是一个非官方软件包。这意味着它不是由 FTXUI 团队维护，而是由社区维护。软件包维护者似乎会积极更新 至最新版本。感谢维护者的工作！"},"title":"Arch Linux"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/bazel/":{"data":{"":"FTXUI 可通过 Bazel 和 Bzlmod（Bazel 模块）集成到您的项目中。\n该库已注册到 Bazel 中央注册表\nMODULE.bazel\nbazel_dep(name = \"ftxui\", version = \"6.1.9\") BUILD.bazel\ncc_binary( name = \"main\", srcs = [\"main.cpp\"], deps = [ \"@ftxui//:component\", \"@ftxui//:dom\", \"@ftxui//:screen\", ], )","入门项目#入门项目":"您可以使用官方的 Bazel 入门项目来获得一个最小的可用设置：\nftxui-bazel (starter)"},"title":"Bazel"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/cmake/":{"data":{"":"本页面介绍如何使用 CMake 集成 FTXUI。","使用-fetchcontent#使用 FetchContent":"此方法在配置时下载 FTXUI，不需要系统级安装。\ninclude(FetchContent) FetchContent_Declare(ftxui GIT_REPOSITORY https://github.com/ArthurSonzogni/FTXUI GIT_TAG v6.1.9 # 替换为版本号、标签或提交哈希 ) FetchContent_MakeAvailable(ftxui) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) 这种方法确保可重现的构建和便捷的依赖管理。","使用-find_package#使用 find_package":"如果 FTXUI 已通过系统级安装或包管理器（如 vcpkg 或 Conan）安装，可以使用：\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) 确保包在您的 CMAKE_PREFIX_PATH 中可见。","使用-git-子模块#使用 Git 子模块":"您也可以将 FTXUI 添加为 Git 子模块，将其保留在您的代码库中：\ngit submodule add https://github.com/ArthurSonzogni/FTXUI external/ftxui git submodule update --init --recursive 当克隆已包含 FTXUI 作为子模块的代码库时，请确保使用以下命令获取子模块：\ngit clone --recurse-submodules # 或者，如果已经克隆： git submodule update --init --recursive 然后在您的 CMakeLists.txt 中：\nadd_subdirectory(external/ftxui) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) 如果您希望将 FTXUI 打包到自己的代码库中，这种方法很适用。","可选的-cmake-标志#可选的 CMake 标志":"FTXUI 支持以下 CMake 选项：\n选项 描述 默认值 FTXUI_BUILD_EXAMPLES 构建捆绑的示例 OFF FTXUI_BUILD_DOCS 构建文档 OFF FTXUI_BUILD_TESTS 启用测试 OFF FTXUI_ENABLE_INSTALL 生成安装目标 ON FTXUI_MICROSOFT_TERMINAL_FALLBACK 改进 Windows 兼容性 ON/OFF 启用选项的方法：\ncmake -DFTXUI_BUILD_EXAMPLES=ON ..","集成方法#集成方法":"","验证集成#验证集成":"要确认设置正常工作，请构建并运行一个最小示例。 如果需要完整模板，请参阅：ftxui-starter"},"title":"CMake"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/conan/":{"data":{"":"FTXUI 可以通过 Conan 包管理器方便地获取和集成到您的项目中。","前置条件#前置条件":"首先，确保您的系统已安装 Conan。如果尚未安装，可以使用 pip 安装：\npip install conan Conan 通常与 CMake 协同工作，因此您也需要安装 CMake：\nWindowsWindows (Chocolatey)Linux (Ubuntu/Debian)MacOS 访问 CMake 官网 下载 Windows 安装程序 运行安装程序，确保勾选 “Add CMake to the system PATH” 选项 choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System' sudo apt-get update sudo apt-get install cmake 这里推荐Homebrew安装，如果没有，请先安装它：\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 获取CMake\nbrew install cmake 当你确保拥有了Conan和CMake后，创建一个项目目录，例如ftxui-demo：\nmkdir C:\\ftxui-demo cd C:\\ftxui-demo","安装依赖并构建#安装依赖并构建":"完成后，我们运行以下命令安装 FTXUI 及其依赖项：\nconan install . --output-folder=build --build=missing 这将从 Conan 的远程仓库下载并安装 ftxui/6.0.2 及其所有依赖项。\n当安装结束后，可以尝试在项目目录下创建一个 demo.cpp 文件进行测试：\n#include #include #include int main() { using namespace ftxui; auto document = hbox({ text(\" Hello \"), text(\"FTXUI \") | bold | color(Color::Red), text(\" world! \") }); auto screen = Screen::Create(Dimension::Full(), Dimension::Fit(document)); Render(screen, document); std::cout \u003c\u003c screen.ToString() \u003c\u003c std::endl; return 0; } 如果测试顺利，我们就可以在项目目录下创建一个 CMakeLists.txt 文件了：\ncmake_minimum_required(VERSION 3.20) project(ftxui-demo) # 设置C++标准 set(CMAKE_CXX_STANDARD 20) # 查找通过Conan安装的FTXUI包 find_package(ftxui CONFIG REQUIRED) # 创建可执行文件 add_executable(demo demo.cpp) # 将可执行文件链接到FTXUI库 target_link_libraries(demo PRIVATE ftxui::component)","配置#配置":"确保环境无误后，创建 Conan 配置文件conanfile.txt，此文件用于声明项目依赖。FTXUI 的社区维护包可在Conan Center 找到。\nNote\n这是一个非官方构建脚本。这意味着它不是由 FTXUI 团队维护，而是由社区维护。软件包维护者似乎会积极更新 至最新版本。感谢维护者的工作！\n⚠️ 如果您了解相关流程，请考虑向 Conan Center 添加一个\"官方构建脚本。 这可以是一个 GitHub Action，在发布新版本时自动更新 Conan Center。 [requires] ftxui/6.0.2 [generators] CMakeDeps CMakeToolchain [layout] cmake_layout"},"title":"Conan"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/debian/":{"data":{"":"","debian-和-ubuntu-软件包非官方#Debian 和 Ubuntu 软件包（非官方）":"这些发行版提供了预构建的软件包。通过以下命令安装：\nsudo apt install libftxui-dev 可用的软件包包括：\nftxui-doc（文档） ftxui-examples（示例） libftxui-component\u003c版本号\u003e libftxui-dev（开发文件） libftxui-dom\u003c版本号\u003e libftxui-screen\u003c版本号\u003e 安装完成后，您可以在 CMake 项目中使用它，只需在 CMakeLists.txt 中添加以下内容：\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) Note\n这是一个非官方软件包。这意味着它不是由 FTXUI 团队维护，而是由社区维护。"},"title":"Debian/Ubuntu"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/manual/":{"data":{"":"","从源码构建官方方式#从源码构建（官方方式）":"使用 CMake 克隆并构建项目：\ngit clone https://github.com/ArthurSonzogni/FTXUI.git cd FTXUI cmake -S . -B build -DFTXUI_ENABLE_INSTALL=ON -D cmake --build build -j sudo cmake --install build Note\n注意：上述命令中的 -D 参数似乎为笔误，通常不需要单独使用 -D 参数。 正确的用法应为 -D\u003c变量\u003e=\u003c值\u003e 格式，如 -DFTXUI_BUILD_EXAMPLES=ON。\n安装完成后，您可以在 CMake 项目中使用它，只需在 CMakeLists.txt 中添加以下内容：\nfind_package(ftxui REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component )"},"title":"手动安装"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/nix/":{"data":{"":"Note\nFTXUI 作者对 Nix 了解有限。本页面内容主要由 AI 生成。如果您有任何改进建议，请提交 PR。","nix-flake#Nix Flake":"FTXUI 提供了 flake.nix，包含软件包和开发环境。","作为依赖使用#作为依赖使用":"将 FTXUI 添加到您的 flake 输入中：\n{ inputs.ftxui.url = \"github:ArthurSonzogni/FTXUI\"; } 然后在输出中引用 ftxui.packages..ftxui。","构建库#构建库":"nix build github:ArthurSonzogni/FTXUI 构建结果可通过 result 链接访问。"},"title":"Nix"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/opensuse/":{"data":{"":"","opensuse-软件包非官方#openSUSE 软件包（非官方）":"FTXUI 似乎可从 devel:libraries:c_c++ 仓库获取。\nsudo zypper addrepo https://download.opensuse.org/repositories/devel:libraries:c_c++/openSUSE_Leap_$releasever/devel:libraries:c_c++.repo sudo zypper install ftxui 详情请参阅 https://build.opensuse.org/package/show/devel:libraries:c_c++/ftxui。\nNote\n这是一个非官方软件包。这意味着它不是由 FTXUI 团队维护，而是由社区维护。\nNote\nFTXUI 作者对 openSUSE 了解有限。本页面内容主要由 AI 生成。如果您有任何改进建议，请提交 PR。"},"title":"openSUSE"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/vcpkg/":{"data":{"":"","vcpkg-软件包#Vcpkg 软件包":"FTXUI 可在 Vcpkg 注册表 中获取。\n要使用它，您可以在 vcpkg.json 中添加以下内容：\n{ \"name\": \"your-project\", \"version-string\": \"0.1.0\", \"dependencies\": [ { \"name\": \"ftxui\", \"version\u003e=\": \"6.1.9\" } ] }","使用-vcpkg-安装-ftxui#使用 Vcpkg 安装 FTXUI":"vcpkg install --triplet x64-linux # 或 x64-windows / arm64-osx 等","配置构建系统#配置构建系统":"如果您使用 CMake，可以在 CMakeLists.txt 中使用以下配置：\nCMakeLists.txt\ncmake_minimum_required(VERSION 3.15) project(my_project) # 确保在配置时传递 vcpkg 工具链文件 find_package(ftxui CONFIG REQUIRED) add_executable(main main.cpp) target_link_libraries(main PRIVATE ftxui::screen PRIVATE ftxui::dom PRIVATE ftxui::component ) main.cpp\n#include #include #include int main() { using namespace ftxui; auto screen = ScreenInteractive::TerminalOutput(); auto button = Button(\"点击我\", [] { std::cout \u003c\u003c \"已点击！\\n\"; }); screen.Loop(button); } 配置和构建项目\ncmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake cmake --build build ./build/main"},"title":"Vcpkg"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/installation/xmake/":{"data":{"":"","xmake-软件包非官方#XMake 软件包（非官方）":"FTXUI 可在 xmake-repo 中获取。\n示例 xmake.lua 代码片段：\nadd_requires(\"ftxui\", {system = false}) target(\"demo\") set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"ftxui\") 更多选项请参阅 XMake 文档。\nNote\n这是一个非官方软件包。这意味着它不是由 FTXUI 团队维护，而是由社区维护。\nNote\nFTXUI 作者对 XMake 了解有限。本页面内容主要由 AI 生成。如果您有任何改进建议，请提交 PR。"},"title":"XMake"},"/docs/ftxui%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/todo_list/":{"data":{"":"Conan 页面 Conan页面\n添加关于如何使用 Conan 构建脚本的说明。\n如果您了解相关流程，请考虑向 Conan Center 添加一个\"官方\"构建脚本。这可以是一个 GitHub Action，用于在发布新版本时自动更新 Conan Center。"},"title":"待办事项"},"/docs/paper-lily%E4%B8%AD%E6%96%87%E7%A4%BE%E5%8C%BA/":{"data":{"":"中文社区本文档介绍了一些纸百合中文社区的相关信息","qq群#QQ群":"在QQ群，我们可以自由的交流剧情，讨论如何通关、剧情细节，当然，目前我们已经讨论得差不多了，所以大概率要等到第二章发布才会有当初的盛况\n站长的大型群\r另一个大型群","中文社区#中文社区":""},"title":"_index"},"/docs/paper-lily%E4%B8%AD%E6%96%87%E7%A4%BE%E5%8C%BA/qq%E7%BE%A4%E7%BE%A4%E8%A7%84/":{"data":{"":"2025年7月31日第十四次修订","第一条制定依据#第一条——制定依据":"本规定的制定，遵守《中华人民共和国宪法》以及相关法律法规。","第七条限制宣传#第七条——限制宣传":"在未经过群主或管理员允许的情况下，发布以盈利为目的广告、与群聊讨论内容无关的文件、文本、网址等且造成五名以上群成员明确表示反感的，一律踢出群聊并拉入黑名单。","第三条处罚方式#第三条——处罚方式":"根据违反的规则不同、造成影响的程度不同等因素，将对违反规定者做出以下几种中一个或多个的惩罚：\n一分钟到一个月不等的禁言 解除管理员身份 口头教育 警告 严重警告 踢出群聊 踢出群聊并拉入黑名单 举报至QQ官方 举报至国家有关部门 其中，踢出群聊的处罚措施允许成员加回，用于群聊等级的清空","第九条不服教导#第九条——不服教导":"违反规定后，在管理员或群主教导下表示不服并拒不认错的，应当加重处罚。","第二条规定适用范围#第二条——规定适用范围":"凡是加入本群者，均代表认同此规定且愿意遵守这一规定，任何群员不得以任何理由违反群规定，否则将受到相应的处罚。","第五条刷屏内容#第五条——刷屏内容":"同一人使用大量无用、重复的信息连续无间断的发送，或者使用特殊技术手段使得图片等内容占据很长一段空间的，一律予以一个小时以上禁言，屡教不改者，当加重处罚。","第八条管理员的废除和增加处罚#第八条——管理员的废除和增加处罚":"管理员因为个人情感等因素不按照规定给予群成员处罚或对应违规行为处理不妥当的，应调整对于事件的处理结果并给予口头警告，两次以上的，应撤去管理员身份。\n管理员违反群聊规定的，应撤去管理员身份并接受在普通处罚的基础上加重一级的处罚。\n管理员在处理群内事务时，对他人恶语相向，使用明显拥有侮辱性、攻击性的词汇时，应当撤去管理员身份；阴阳怪气、态度恶劣的，将规劝其改正态度，再次出现此类情况时，将撤去管理员身份。","第六条破坏和谐#第六条——破坏和谐":"进行地域歧视、种族歧视或进行恶意的人身攻击、嘲讽等不利于群内团结的行为的，一律予以一天以上禁言，严重或屡教不改者，当加重处罚。","第十一条预处理措施#第十一条——预处理措施":"在遇到可能或确定存在违规的行为并且群聊内较为混乱的情况下，管理员或群主可以临时设置全体当事人一个小时的禁言，在此期间内，所有在线的管理员与群主一同判断是否违规或应当适用那种处罚措施，在商讨完毕后方可进行调整。","第十条主动认错#第十条——主动认错":"违反规定后，在管理员、群主或其他群成员劝说下主动认错、道歉的，应当减轻处罚，未被教导主动道歉的，将减轻两级，可以以此减到无处罚状态。","第四条不适宜内容的处理#第四条——不适宜内容的处理":"在群内发布明确违反国家法律法规规定的内容（包括但不限于涉及黄、赌毒；非法公开户籍信息；辱骂烈士）的，一律踢出本群并拉入黑名单，同时举报至国家相关机关。\n交流时明显谈及时事政治相关的敏感话题并且引起多于二十五条消息参与讨论的，予以一天以上禁言，屡教不改者，当加重处罚。\n由于界定难度，相关内容是否不宜发出将由群主与管理员共同判断，目前明确不允许的是：散播政治谣言、分裂国家言论和未经核实的重大事件","管理须知处罚如何加重#管理须知：处罚如何加重":"2025.2.16第一编\n对于标记了“屡教不改者，当加重处罚”或“严重屡教不改者，当加重处罚”的条目和满足本规定第十条或第十一条规定的，加重或减轻的依据为如下列表的顺序：\n禁言一分钟（或以上）\n禁言五分钟（或以上）\n禁言一小时（或以上）\n禁言十二小时（或以上）\n禁言一天（或以上）\n禁言十天（或以上）\n禁言一个月（29天23小时59分钟）\n踢出群聊并拉入黑名单\n初犯时采用触犯的规定中明确的方式和时长进行处罚，下一次违规则以原条目处罚的下一条处置，以此类推。额外的加重意为在此基础上再向下一条使用，减轻则反之，加重和减轻是可叠加的。\n每次进行禁言处置，应在当前条以上，下一条以下进行选择，超出范围将视为管理员失职。\n对于同时违反多项规定的，将采用累计的方式，统计应适用的禁言的时长和，当起始时间相加超过一个月（29天23小时59分钟）则整合为踢出群聊并拉入黑名单并执行。","群主工作报告相关#群主工作报告相关":"群主会在每天早些时分公开有关前一日的工作情况包括群聊、频道管理等活动的报告，报告公布只会在前一天没有工作任务的情况下才会取消，报告内容将传至群主工作报告相册"},"title":"QQ群群规（总编）"}}