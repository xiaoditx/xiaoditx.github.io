{"/ja/about/":{"data":{"":"Note\n本ページはAI技術による翻訳を使用しています。内容は参考までにご覧ください。\nこれは私の個人サイトです。Hextraを使って構築しました。オープンソース作者の貢献に感謝します。"},"title":"About"},"/ja/blog/":{"data":{"":"Note\n本ページはAI技術による翻訳を使用しています。内容は参考までにご覧ください。\n普段は自分のCSDNや稀土掘金（Jue Jin）から記事をいくつか転載しますが、このウェブサイト限定のブログ記事はおそらくないでしょう。\nB站：小狄同学呀\nGithub：xiaoditx\nACfun：小狄同学呀\nCSDN、稀土掘金：小狄同学呀"},"title":"小狄同学さんのブログ"},"/ja/blog/2025-08-26_%E7%AE%97%E6%B3%95%E7%9C%9F%E9%A2%98gesp202503%E5%9B%9B%E7%BA%A7%E8%8D%92%E5%9C%B0%E5%BC%80%E5%9E%A6%E6%B4%9B%E8%B0%B7b4263/":{"data":{"1-問題の分析#1. 問題の分析":"問題によると、荒地の区画は上下左右の四方向に隣接するマスにいずれも雑物が存在しない場合にのみ開墾できます。このように考えるのは難しそうですが、視点を変えると簡単かもしれません。次の$3×3$の荒地を想定してみましょう。\n...\r.#.\r... ここで中心に雑物が出現します。開墾可能な荒地は四方に雑物があってはならないため、この一つの雑物が影響を及ぼすのはその上下左右の荒地です。雑物がなくても開墾できない荒地を!で表すと以下のようになります。\n.!.\r!#!\r.!. つまり、荒地が開墾不能かどうかを判断する思路が、雑物を見つけることに転換しました。以下が、コードの内容です。","2-データ読み込みと予備処理#2. データ読み込みと予備処理":"","3-現在開墾可能な数の統計#3. 現在開墾可能な数の統計":"ここでの私たちの考え方は次のとおりです：除去できるのは1つだけなので、まず除去なしでどれだけ開墾できるかを計算し、その後、除去することで最も多くの土地を解放できる雑物を見つけます。このため、まず現在開墾可能な数を数える必要があります。\nint ans=0;// 最終出力用に0で初期化したans変数 // 以下のループはimap配列を読み、\"0\"の数を数える for(int c=0;c\u003cn;c++){ for(int vc=0;vc\u003cm;vc++){ // 標準的なループ走査 if(imap[vc][c]==0){// 現在のセルが0 ans++;// ansは開墾可能セル数を記録、0は開墾可能、+1記録 } } } 明らかに、現在の状態は判断しやすいです。0であれば開墾可能であることを意味します。これは私たちが前に定量化した値です。だから0を見つけるたびにans変数に1を加算します。1回ループした後、imap内の0の数がansに保存されます。","4-最適解の検索#4. 最適解の検索":"ここで必要なのは、最適な除去解を見つけることだけです。ここで最も簡単な方法はobjectを列挙することです。しかし、私の同学は記録された位置を一つずつ’.‘に変えてから開墾可能数を分析していたようで、多少非効率的です（多分彼の意図を誤解した？とにかくこの方法は遅い）。実際、オフセットに従って読み取るだけで済みます。\n雑物が除去されると、定義によれば、周囲のセルの値はすべて1減少するはずです。その自身の位置は正の数になり、その後1減少します。したがって、自身のセルが-1の場合にのみ、除去により開墾可能になることがわかります。周囲のセルが1の場合にのみ、除去により開墾可能になります。由此 (これにより)、以下のコードが得られます。\nint area,best=0;// 雑物除去後に開墾可能になる荒地数を計算する2つの変数 for(int c=0;c\u003crecord_c;c++){ area=0;// areaは一時的なので、ループ毎に0で初期化 for(int vc=0;vc\u003c4;vc++){// 4回オフセット int tx=px[vc]+object[c][0],ty=py[vc]+object[c][1];// XYを計算 if((tx\u003e=0) // 境界チェック、前と同じ \u0026\u0026 (tx\u003cm) \u0026\u0026 (ty\u003e=0) \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]==1){// 1なら、現在の雑物の影響のみを受けており、除去すれば開墾可能になる area++;// 開墾可能荒地数 +1 } } } if(imap[object[c][0]][object[c][1]]==-1){// この雑物が他の雑物の影響範囲内にあるか確認 area++;// ない場合はさらに1加算 } if(best\u003carea)best=area; if(best==5)break;// 最大値は5（自身＋4方向のオフセット）、時間節約のため直接break } “打擂台” (競争) 方式を使用して最適解を選択します。自身とオフセットを合わせても最大5点なので、bestが5になれば、より良い解はないのでbreakできます。これで時間を節約できます。競技では、これをしなくてもACできますが、わずか数行の簡単な最適化も依然として必要です。結局のところ、C++の概念は効性最優先です。","5-出力#5. 出力":"最適解は-1と1のみを考慮するため、これらの開墾可能荒地はすべて除去前の状態に対して新たに追加されたものです。単純にansとbestを加算すれば最終結果が得られます。\nans+=best;// ansに雑物除去で解放されたスペースを加算 std::cout\u003c\u003cans;// 答えを出力","コード#コード":"私は書きましたが、専門的にアルゴリズムを学んでいるわけではないので、時間計算量や空間計算量についてよく知りませんし、使ったアルゴリズムが何と呼ばれるものかも知りません。ただACしたことだけは知っています。各テストケースは大抵7-25msくらいで通過したようです（下図参照）。\n以下は私のコードです。これはコメント付きのバージョンですが、それでも私の不可解な書き方で混乱させる箇所があるかもしれません。理解できなければ、解析部分を読んでください。ほぼ行ごとの解説があります。\n#include #include int main(){ int m,n,record_c=0;// 長さ、幅、雑物カウント記録変数 char tmp;// 実はstringを使いたかった int px[4]={0,0,1,-1},py[4]={1,-1,0,0};// 雑物による開墾不能オフセット std::cin\u003e\u003en\u003e\u003em;// 長さと幅を読み込み（設計上の理由で、逆に読む必要に迫られた） int imap[m][n];// マップ配列作成（2次元） int object[m*n][2];// 雑物座標記録配列 memset(imap,0,sizeof(imap));// マップを0で初期化（デフォルト：雑物なし、開墾可能） for(int c=0;c\u003cn;c++){// 内容読み込みループ for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;// tmpに仮読み込み if(tmp=='#'){// '#'（雑物）かどうか判定 imap[vc][c]=-1-imap[vc][c];// 雑物なら負数で記録（叠加：重ね合わせ/累積） object[record_c][0]=vc;// 雑物位置を記録、後続作業を減らし時間節約 object[record_c][1]=c; record_c++;// 記録変数を1増やす for(int dev_c=0;dev_c\u003c4;dev_c++){// 4回オフセット座標を計算し判定 int tx=px[dev_c]+vc,ty=py[dev_c]+c;// オフセット後のX、Y /* 配列操作時の境界外防止のための境界チェック 実際、ifが効率に深刻な影響を与えると思うなら、カスタムの境界チェックを検討すること、 まず境界を処理し、その後内部を処理する。これにより効率が上がるが、より多くのコードを書くことを意味する。 */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) // これら2行はXのチェック \u0026\u0026 (ty\u003e=0) // 次の2行はYのチェック \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){// 「雑物か否か」をチェック imap[tx][ty]++;// \u003e-1 は雑物でないので、++で影響を記録 }else{// \u003c=-1 の場合 imap[tx][ty]--; } } } } } } // 読み込み完了。機械圧縮の力を感じよ！ // （実際、読みづらいならgotoで解決もできるが、非推奨） // デバッグ時に使用したコード、コメント内に保持 // for(int c=0;c","マップの準備#「マップ」の準備":"問題を解くには、まず問題が提供するデータを受け取らなければなりません。データも満足に受け取れないのに、どう分析できましょうか。そこでまず、最初の2つのデータを受け取るコードを書き、ついでに後のための準備をします。\n#include #include int main(){ int m,n,record_c=0;// 長さ、幅、雑物カウント記録変数 char tmp;// 実はstringを使いたかった int px[4]={0,0,1,-1},py[4]={1,-1,0,0};// 雑物による開墾不能オフセット std::cin\u003e\u003en\u003e\u003em;// 長さと幅を読み込み（設計上の理由で、逆に読む必要に迫られた） int imap[m][n];// マップ配列作成（2次元） int object[m*n][2];// 雑物座標記録配列 memset(imap,0,sizeof(imap));// マップを0で初期化（デフォルト：雑物なし、開墾可能） } ここでは2つのヘッダー、iostreamとcstringを使用しています。1つはほとんど必須で、もう1つは配列の初期化用です。\nここでこう言う人もいるかもしれません：ねえ？ using namespace stdはどこに行ったの？\n実際、熱心にstd::を追加すれば、この行を書く必要はありません。これには利点があります。アルゴリズム競技ではなかなか反映されませんが、私はより応用重視です（結局最初に学んだのは易言語ですから）、usingを控えめに使う習慣を常に重視しています。これについては「名前空間汚染」を検索して自行で調べてください。\nここでは整数変数m、n、record_cを定義して、それぞれ：入力nの受け取り、入力mの受け取り、雑物数の保存（ここには不具合があり、mとnが逆に使われており、変更が難しく、最終的にmでnを受け取るような挙動をせざるを得なくなった）；char型変数tmp、後続の’.‘と’#‘の入力を受け取るための変数。\nコード内のpxとpyは実際には「オフセット配列」です。実際の使用では、数値nを取り、点$A$に対して、そのX座標+px[n]、Y座標+py[n]を加算することで、オフセットされた点を得ます。このコードのオフセットは、右、左、下、上に対応します。\nこれらの変数を定義した後、読み込みを開始できます。mとnを読み込む。これら2つの数値は土地全体の大きさを教えてくれ、私たちに「ちょうどいい」配列をマップとして定義するのに役立ちます（私はちょうどいいのがとても好きで、様々なリスクがあっても、結局易言語をたくさん書いてきたので、合理的に見えます）。\nint imap[m][n]は2次元配列を作成します。imapはマップの意味です（もともとはmapと書いていましたが、同学がそれは予約語のようだと言ったので、imapに変更しました）。これでXとYを使って直接点を操作できるようになります。\nobjectとは何ですか？これは雑物の位置情報を保存するために使用します。雑物がたくさんある可能性を考慮すると、$m*n$（m×n）で定義する方が良いと感じました。これも2次元配列ですが、構造体配列のようなものです（実際、毎回object[n][0]にXを、object[n][1]にYを保存します。構造体にすることもできましたが、面倒だし、配列が好きなので、嘻嘻）。\n最終ステップ、imap配列を0で初期化します。なぜ0なのかは、次のセクションに移動してください。","マップを書く#マップを書く":"for(int c=0;c\u003cn;c++){// 内容読み込みループ for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;// tmpに仮読み込み if(tmp=='#'){// '#'（雑物）かどうか判定 imap[vc][c]=-1-imap[vc][c];// 雑物なら負数で記録（叠加：重ね合わせ/累積） object[record_c][0]=vc;// 雑物位置を記録、後続作業を減らし時間節約 object[record_c][1]=c; record_c++;// 記録変数を1増やす for(int dev_c=0;dev_c\u003c4;dev_c++){// 4回オフセット座標を計算し判定 int tx=px[dev_c]+vc,ty=py[dev_c]+c;// オフセット後のX、Y /* 配列操作時の境界外防止のための境界チェック 実際、ifが効率に深刻な影響を与えると思うなら、カスタムの境界チェックを検討すること、 まず境界を処理し、その後内部を処理する。これにより効率が上がるが、より多くのコードを書くことを意味する。 */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) // これら2行はXのチェック \u0026\u0026 (ty\u003e=0) // 次の2行はYのチェック \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){// 「雑物か否か」をチェック imap[tx][ty]++;// \u003e-1 は雑物でないので、++で影響を記録 }else{// \u003c=-1 の場合 imap[tx][ty]--; } } } } } } （変数名がc、dev_cなど奇妙なものでも気にしないでください。c++のような文を書きたかっただけです）\n文字ごとに読み込む単純なループを使用します。マップを開墾可能で初期化しているので、’.‘を読み込んでも大抵は無視して構いません。’#‘だけが私たちにとって重要です。それをimapとobjectに記録します。\nimapに記録する操作は次のとおりです：-1 - 現在のセルの内容。元々0だった場合は、今は-1になります。元々1だった場合は、-2になります。前にの各位置の情報の定量化セクションを振り返って、一致するか確認できます。\n書き終えた後、4回ループし、pxとpy配列の4つのオフセットに対応し、影響を計算します：非雑物セルは1を加算し、雑物セルは1を減算します。\nオフセットを計算するときは、結果が配列の範囲を超える可能性があることに注意してください。この場合、この存在しない座標に対して操作を行うべきではないので、境界外かどうかをチェックするifを追加する必要があります。","各位置の情報の定量化#各位置の情報の定量化":"セルは、荒地、雑物、雑物の影響を受ける荒地、または他の雑物の影響範囲内にある雑物である可能性があります。注意：1つの荒地の区画が2つ以上の雑物から同時に影響を受ける可能性があります。\n次の例に注意してください。\n.....\r.#.#.\r..... この例では、2つの#の間の.は、たとえ一方の雑物が除去されても、依然としてもう一方の雑物の影響範囲内にあるため、依然として開墾できません。したがって、この除去はこの単一の点に対しては無効であると考えます。\nこの点がいくつの雑物の影響范围内にあるかをどのように記録すればよいでしょうか？私たちは定量化戦略を持っています：0で開墾可能を表し、1で1つの雑物の影響を受けることを表し、2で2つ、最大4までです。\n同様に、雑物を配置するセルについても、除去された場合、このセルも開墾できない可能性があるため、記録する必要があります。ここでは-1で雑物を表し、-2で他の1つの雑物の影響範囲内にある雑物を表し、以下同様とします（この設定は後で記録しやすくするためのもので、後で説明します）。","始める前に#始める前に":"Note\n本ページはAI技術による翻訳を使用しています。内容は参考までにご覧ください。\n始める前に同学がGESP試験を受け、戻ってきて、ある問題でTLE（時間切れ）になったと言いました。彼はさりげなくその問題を私に書き写してくれました。それを見て少し考えが浮かんだので、易言語で書いてみましたが、どんどん乱雑になって諦めました。今週、授業が少し退屈で、他にすることもなかったので、またこの問題を拾い上げました。家で試し、少し変更を加え、無事AC（受理）しました。\n元の問題は以下のようなものです：\n小楊は大きな荒地を持っており、n行m列のグリッドで表すことができる。\r小楊はこの荒地を開墾したいと考えている。しかし、荒地のいくつかの位置に雑物がある。雑物がない荒地の区画については、その上下左右の四方向に隣接するマスにいずれも雑物が存在しない場合にのみ、開墾することができる。\r小楊は最大1箇所の雑物を除去する位置を選ぶことができる。除去後、その位置は荒地となる。小楊は、最大1箇所の雑物を除去した場合に、最大で何枚の荒地を開墾できるかを知りたい。 入力と出力の形式については、Luoguで直接確認するのが良いでしょう: Luogu B4263。ここにはすべては貼りません。","後記#後記":"この手書きのコードの原稿を皆さんと共有したいです。細部にいくつかの欠点がありますが、全体的には完成しています。 この問題を解いた後、問題にアプローチする優れた方法があることに気づきました。コードを書いても思い通りに動かないときは、自然言語でアルゴリズムを説明する方法を考えてみてください。この方法は、コードを見つめて頭を抱えるよりも概念的な欠陥を見つけやすくします。アルゴリズムを扱う方は試してみてください。\n少し眠く、頭もよく回りません。朦朧としていて不可解なことを書いてしまったかもしれません。まず寝て、起きてから直します。","解析#解析":""},"title":"アルゴリズム問題: GESP202503 レベル4 — 荒地開墾 (Luogu B4263)"},"/ja/blog/2025-08-26_vscode%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99g++%E5%8D%B4%E5%AE%8C%E7%BE%8E%E7%BC%96%E8%AF%91api%E8%B0%83%E7%94%A8%E9%94%99%E5%9B%A0%E5%88%86%E6%9E%90/":{"data":{"":"Note\n本ページはAI技術による翻訳を使用しています。内容は参考までにご覧ください。\n少し前にある小さなソフトウェアを書き、それに設定読み書き機能を追加したくなりました。C++を学び始めて数日の私は、ネットでかなり調べ、INI読み込みのGetPrivateProfileStringとINI書き込みのWritePrivateProfileStringという2つのWindows APIを見つけました。ネットのチュートリアルに従い、以下の3行を書きました：\nLPTSTR lpPath = new char[MAX_PATH]; strcpy(lpPath, \".\\\\config.ini\"); ::WritePrivateProfileString(\"config\", \"t\", \"120\", lpPath); 書き終えた直後、VScodeのプラグインが即座に赤く警告を出し、次のようなエラーを表示しました： しかし、私はチュートリアル通りに正確に書いたと確信していました。どこが問題なのでしょうか？\nコンパイルを試みると、結果は驚くべきものでした：g++は一切エラーなくコンパイルに成功し、カレントディレクトリにconfig.iniを作成して指定内容を書き込みました。\nこれは奇妙です。公式ドキュメントを調べてみましょう。\nMSDNに行き、WritePrivateProfileStringを検索しましたが、見つかりませんでした。見つかったのはWritePrivateProfileStringAとWritePrivateProfileStringW（どちらも末尾に文字が一つ追加）だけでした。\n仕方ないので、一つクリックして確認しました。WritePrivateProfileStringAを選びました。ん？パラメータの型が違うようです。チュートリアルではLPTSTRを使っていましたが、ここではLPCSTRと書かれています。\n下にスクロールすると、Exampleセクションの下に注記がありました：\nwinbase.h ヘッダーは、UNICODE プリプロセッサ定数の定義に基づいて、この関数の ANSI バージョンと Unicode バージョンを自動的に選択するエイリアスとして WritePrivateProfileString を定義します。エンコード中立エイリアスとエンコード中立ではないコードを混在させると、コンパイル エラーまたはランタイム エラーの不一致が発生する可能性があります。詳細については、「関数プロトタイプの規約」を参照してください。\nつまり、WritePrivateProfileStringはAPIの本来の名前ではなく、条件に応じて選択されるものなのです。\nVScodeに戻り、Ctrlを押しながらWritePrivateProfileStringをクリックして、Windows.hの内容を確認しました：\n#ifdef UNICODE #define WritePrivateProfileString WritePrivateProfileStringW #else #define WritePrivateProfileString WritePrivateProfileStringA #endif VScodeでは上の条件が有効（強調表示）になっており、VScodeの環境ではUNICODEマクロが定義されていることを証明していました。\nこれで真相がわかりました！VScodeにはUNICODEマクロが定義されている一方、g++には定義されていなかったため、プラグインはコードをWritePrivateProfileStringWに対してチェックし、Unicodeとwchar_t（ワイド文字）で格納されたパスを要求しました。g++でコンパイルするときは、WritePrivateProfileStringAを使い、ANSIとchar（通常の文字）で格納されたパスを要求しました。その結果、私たちがcharを使ったコードはg++では正常に動作しましたが、VScodeプラグインのチェックには通りませんでした。\nしたがって、私たちのコードは正しかったのですが、環境の違いによりプラグインがエラーと判断したのです。この場合の解決策は、明示的にWritePrivateProfileStringA関数を使用することを指定することです：\nchar* lpPath = new char[MAX_PATH]; strcpy(lpPath, \".\\\\config.ini\"); ::WritePrivateProfileStringA(\"LiMing\", \"Sex\", \"Man\", lpPath); delete[] lpPath; これで完了です。煩わしい警告はついに消えました。\n付録： LPxxxSTRデータ型の具体的な意味\n核心的基本型:\nCHAR: ANSI (8ビット) 文字を表す (char)。 WCHAR: ワイド文字 (Unicode, 通常は16ビット UTF-16) を表す (wchar_t)。 TCHAR: 適応型文字タイプ。プロジェクト設定（_UNICODEマクロが定義されているかどうか）に基づいて、CHAR または WCHAR にコンパイルされる。ANSIとUnicodeのどちらにもコンパイル可能なコードを書くために使用される。 文字列ポインタ型:\nLPSTR: Long Pointer to STRing。NULL終端された ANSI 文字列を指す (CHAR*)。 typedef CHAR* LPSTR; LPWSTR: Long Pointer to Wide STRing。NULL終端された Unicode (UTF-16) 文字列を指す (WCHAR*)。 typedef WCHAR* LPWSTR; LPTSTR: Long Pointer to TCHAR STRing。NULL終端された 適応型文字 (TCHAR*) 文字列を指す。_UNICODEマクロ定義に依存し、コンパイル時にLPSTR (ANSI) または LPWSTR (Unicode) と等しくなる。 typedef TCHAR* LPTSTR; 定数文字列ポインタ型:\nLPCSTR: Long Pointer to Constant STRing。NULL終端された 定数ANSI 文字列を指す (const CHAR*)。 typedef const CHAR* LPCSTR; LPCWSTR: Long Pointer to Constant Wide STRing。NULL終端された 定数Unicode (UTF-16) 文字列を指す (const WCHAR*)。 typedef const WCHAR* LPCWSTR; LPCTSTR: Long Pointer to Constant TCHAR STRing。NULL終端された 定数適応型文字 (const TCHAR*) 文字列を指す。_UNICODEマクロ定義に依存し、コンパイル時にLPCSTR (ANSI) または LPCWSTR (Unicode) と等しくなる。 typedef const TCHAR* LPCTSTR; 主な違いのまとめ表：\n型 文字幅 Const性 基本型相当 (ANSIビルド) 基本型相当 (Unicodeビルド) 説明 LPSTR ANSI (8-bit) 非 const char* char* ANSI文字列へのポインタ LPCSTR ANSI (8-bit) const const char* const char* 読み取り専用 ANSI文字列へのポインタ LPWSTR Unicode (16-bit) 非 const wchar_t* wchar_t* Unicode (UTF-16) 文字列へのポインタ LPCWSTR Unicode (16-bit) const const wchar_t* const wchar_t* 読み取り専用 Unicode (UTF-16) 文字列へのポインタ LPTSTR 適応型 非 const char* (LPSTR) wchar_t* (LPWSTR) 適応型文字列 (TCHAR*) へのポインタ LPCTSTR 適応型 const const char* (LPCSTR) const wchar_t* (LPCWSTR) 読み取り専用 適応型文字列 (const TCHAR*) へのポインタ 重要な注意点:\nLP 接頭辞: “Long Pointer” は歴史的な名残。現代の32/64ビットシステムでは、全てのポインタが “long” です。LPは単に “Pointer to” と考えて差し支えありません。 C 接尾辞: const を意味する。指し示す内容は読み取り専用。このポインタを通して文字列を変更することはできない。 T 接中辞: 型が TCHAR であることを意味し、プロジェクトの文字セット設定に基づいて適応する。ANSIとUnicodeの両方のビルドをサポートするコードを書くためのもの。 W 接尾辞: “Wide”、つまりUnicode (UTF-16) を意味する。 STR 接尾辞: “String” (NULL終端文字配列) を意味する。 現代のWindows開発における実践: 常にUnicodeビルドを使用することを強く推奨 (Visual Studio のプロジェクトプロパティで「文字セット」を「Unicode 文字セットを使用する」に設定)。これは _UNICODE マクロを定義する。 Unicodeビルドでは: TCHAR = WCHAR LPTSTR = LPWSTR LPCTSTR = LPCWSTR TCHARファミリーの曖昧さを避けるため、LPCWSTR/LPWSTR またはそのエイリアスである std::wstring (C++) を直接使用する方が、多くの場合明確である (ANSI/Unicodeの両方をサポートするレガシーコードベースを維持する明示的な必要性がない限り)。 ANSI (LPSTR/LPCSTR) API関数は、内部的には多くの場合、文字列をUnicodeに変換して対応するUnicode版関数を呼び出しており、パフォーマンスオーバーヘッドと潜在的な文字セット変換問題が存在する。明示的なUnicode (W) 版APIの使用を優先する。 互換性: TCHARファミリーは、主に古いWindows 9xシステム (主にANSIを使用) と現代のNTシステム (ネイティブUnicode) との互換性のために存在する。現代の開発 (Windows 2000以降) ではUnicodeを優先すべき。 簡単な覚え方:\nW があれば -\u003e Unicode。 C があれば -\u003e const (文字列内容は変更不可)。 T があれば -\u003e 適応型。プロジェクト設定に応じてANSIまたはUnicodeに変化。 W も T もなければ -\u003e ANSI。 C がなければ -\u003e 文字列内容は変更可能 (非定数)。 C があれば -\u003e 文字列内容は読み取り専用 (定数)。 使用上のアドバイス:\n新しいプロジェクト: 常にUnicodeビルドを有効にする (_UNICODE 定義)。LPCWSTR (入力パラメータ) と LPWSTR (出力パラメータ)、またはC++では const wchar_t* と std::wstring の使用を優先する。 旧プロジェクトの維持/ANSI互換性が必要: LPCTSTR (入力) と LPTSTR (出力)、または対応する TCHAR 基本型を使用し、_UNICODE マクロ定義の取り扱いを確実に行う。 Windows APIと相互作用する場合、API関数には通常A (ANSI) とW (Wide/Unicode) の2つのバージョンがあることに注意 (例: MessageBoxA と MessageBoxW)。汎用マクロ MessageBox は _UNICODE に基づいて自動的に正しいバージョンを選択する。渡される文字列ポインタ型もそれと一致しなければならない (LPCSTR はA版に、LPCWSTR はW版に、LPCTSTR は汎用マクロにそれぞれ対応)。"},"title":"VScodeプラグインはエラーを報告するのに、g++は完璧にコンパイル？API呼び出しの誤り原因分析"},"/ja/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/":{"data":{"1-問題の分析#1. 問題の分析":"問題によると、荒地の区画は上下左右の四方向に隣接するマスにいずれも雑物が存在しない場合にのみ開墾できます。このように考えるのは難しそうですが、視点を変えると簡単かもしれません。次の$3×3$の荒地を想定してみましょう。\n...\r.#.\r... ここで中心に雑物が出現します。開墾可能な荒地は四方に雑物があってはならないため、この一つの雑物が影響を及ぼすのはその上下左右の荒地です。雑物がなくても開墾できない荒地を!で表すと以下のようになります。\n.!.\r!#!\r.!. つまり、荒地が開墾不能かどうかを判断する思路が、雑物を見つけることに転換しました。以下が、コードの内容です。","2-データ読み込みと予備処理#2. データ読み込みと予備処理":"","3-現在開墾可能な数の統計#3. 現在開墾可能な数の統計":"ここでの私たちの考え方は次のとおりです：除去できるのは1つだけなので、まず除去なしでどれだけ開墾できるかを計算し、その後、除去することで最も多くの土地を解放できる雑物を見つけます。このため、まず現在開墾可能な数を数える必要があります。\nint ans=0;// 最終出力用に0で初期化したans変数 // 以下のループはimap配列を読み、\"0\"の数を数える for(int c=0;c\u003cn;c++){ for(int vc=0;vc\u003cm;vc++){ // 標準的なループ走査 if(imap[vc][c]==0){// 現在のセルが0 ans++;// ansは開墾可能セル数を記録、0は開墾可能、+1記録 } } } 明らかに、現在の状態は判断しやすいです。0であれば開墾可能であることを意味します。これは私たちが前に定量化した値です。だから0を見つけるたびにans変数に1を加算します。1回ループした後、imap内の0の数がansに保存されます。","4-最適解の検索#4. 最適解の検索":"ここで必要なのは、最適な除去解を見つけることだけです。ここで最も簡単な方法はobjectを列挙することです。しかし、私の同学は記録された位置を一つずつ’.‘に変えてから開墾可能数を分析していたようで、多少非効率的です（多分彼の意図を誤解した？とにかくこの方法は遅い）。実際、オフセットに従って読み取るだけで済みます。\n雑物が除去されると、定義によれば、周囲のセルの値はすべて1減少するはずです。その自身の位置は正の数になり、その後1減少します。したがって、自身のセルが-1の場合にのみ、除去により開墾可能になることがわかります。周囲のセルが1の場合にのみ、除去により開墾可能になります。由此 (これにより)、以下のコードが得られます。\nint area,best=0;// 雑物除去後に開墾可能になる荒地数を計算する2つの変数 for(int c=0;c\u003crecord_c;c++){ area=0;// areaは一時的なので、ループ毎に0で初期化 for(int vc=0;vc\u003c4;vc++){// 4回オフセット int tx=px[vc]+object[c][0],ty=py[vc]+object[c][1];// XYを計算 if((tx\u003e=0) // 境界チェック、前と同じ \u0026\u0026 (tx\u003cm) \u0026\u0026 (ty\u003e=0) \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]==1){// 1なら、現在の雑物の影響のみを受けており、除去すれば開墾可能になる area++;// 開墾可能荒地数 +1 } } } if(imap[object[c][0]][object[c][1]]==-1){// この雑物が他の雑物の影響範囲内にあるか確認 area++;// ない場合はさらに1加算 } if(best\u003carea)best=area; if(best==5)break;// 最大値は5（自身＋4方向のオフセット）、時間節約のため直接break } “打擂台” (競争) 方式を使用して最適解を選択します。自身とオフセットを合わせても最大5点なので、bestが5になれば、より良い解はないのでbreakできます。これで時間を節約できます。競技では、これをしなくてもACできますが、わずか数行の簡単な最適化も依然として必要です。結局のところ、C++の概念は効性最優先です。","5-出力#5. 出力":"最適解は-1と1のみを考慮するため、これらの開墾可能荒地はすべて除去前の状態に対して新たに追加されたものです。単純にansとbestを加算すれば最終結果が得られます。\nans+=best;// ansに雑物除去で解放されたスペースを加算 std::cout\u003c\u003cans;// 答えを出力","コード#コード":"私は書きましたが、専門的にアルゴリズムを学んでいるわけではないので、時間計算量や空間計算量についてよく知りませんし、使ったアルゴリズムが何と呼ばれるものかも知りません。ただACしたことだけは知っています。各テストケースは大抵7-25msくらいで通過したようです（下図参照）。\n以下は私のコードです。これはコメント付きのバージョンですが、それでも私の不可解な書き方で混乱させる箇所があるかもしれません。理解できなければ、解析部分を読んでください。ほぼ行ごとの解説があります。\n#include #include int main(){ int m,n,record_c=0;// 長さ、幅、雑物カウント記録変数 char tmp;// 実はstringを使いたかった int px[4]={0,0,1,-1},py[4]={1,-1,0,0};// 雑物による開墾不能オフセット std::cin\u003e\u003en\u003e\u003em;// 長さと幅を読み込み（設計上の理由で、逆に読む必要に迫られた） int imap[m][n];// マップ配列作成（2次元） int object[m*n][2];// 雑物座標記録配列 memset(imap,0,sizeof(imap));// マップを0で初期化（デフォルト：雑物なし、開墾可能） for(int c=0;c\u003cn;c++){// 内容読み込みループ for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;// tmpに仮読み込み if(tmp=='#'){// '#'（雑物）かどうか判定 imap[vc][c]=-1-imap[vc][c];// 雑物なら負数で記録（叠加：重ね合わせ/累積） object[record_c][0]=vc;// 雑物位置を記録、後続作業を減らし時間節約 object[record_c][1]=c; record_c++;// 記録変数を1増やす for(int dev_c=0;dev_c\u003c4;dev_c++){// 4回オフセット座標を計算し判定 int tx=px[dev_c]+vc,ty=py[dev_c]+c;// オフセット後のX、Y /* 配列操作時の境界外防止のための境界チェック 実際、ifが効率に深刻な影響を与えると思うなら、カスタムの境界チェックを検討すること、 まず境界を処理し、その後内部を処理する。これにより効率が上がるが、より多くのコードを書くことを意味する。 */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) // これら2行はXのチェック \u0026\u0026 (ty\u003e=0) // 次の2行はYのチェック \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){// 「雑物か否か」をチェック imap[tx][ty]++;// \u003e-1 は雑物でないので、++で影響を記録 }else{// \u003c=-1 の場合 imap[tx][ty]--; } } } } } } // 読み込み完了。機械圧縮の力を感じよ！ // （実際、読みづらいならgotoで解決もできるが、非推奨） // デバッグ時に使用したコード、コメント内に保持 // for(int c=0;c","マップの準備#「マップ」の準備":"問題を解くには、まず問題が提供するデータを受け取らなければなりません。データも満足に受け取れないのに、どう分析できましょうか。そこでまず、最初の2つのデータを受け取るコードを書き、ついでに後のための準備をします。\n#include #include int main(){ int m,n,record_c=0;// 長さ、幅、雑物カウント記録変数 char tmp;// 実はstringを使いたかった int px[4]={0,0,1,-1},py[4]={1,-1,0,0};// 雑物による開墾不能オフセット std::cin\u003e\u003en\u003e\u003em;// 長さと幅を読み込み（設計上の理由で、逆に読む必要に迫られた） int imap[m][n];// マップ配列作成（2次元） int object[m*n][2];// 雑物座標記録配列 memset(imap,0,sizeof(imap));// マップを0で初期化（デフォルト：雑物なし、開墾可能） } ここでは2つのヘッダー、iostreamとcstringを使用しています。1つはほとんど必須で、もう1つは配列の初期化用です。\nここでこう言う人もいるかもしれません：ねえ？ using namespace stdはどこに行ったの？\n実際、熱心にstd::を追加すれば、この行を書く必要はありません。これには利点があります。アルゴリズム競技ではなかなか反映されませんが、私はより応用重視です（結局最初に学んだのは易言語ですから）、usingを控えめに使う習慣を常に重視しています。これについては「名前空間汚染」を検索して自行で調べてください。\nここでは整数変数m、n、record_cを定義して、それぞれ：入力nの受け取り、入力mの受け取り、雑物数の保存（ここには不具合があり、mとnが逆に使われており、変更が難しく、最終的にmでnを受け取るような挙動をせざるを得なくなった）；char型変数tmp、後続の’.‘と’#‘の入力を受け取るための変数。\nコード内のpxとpyは実際には「オフセット配列」です。実際の使用では、数値nを取り、点$A$に対して、そのX座標+px[n]、Y座標+py[n]を加算することで、オフセットされた点を得ます。このコードのオフセットは、右、左、下、上に対応します。\nこれらの変数を定義した後、読み込みを開始できます。mとnを読み込む。これら2つの数値は土地全体の大きさを教えてくれ、私たちに「ちょうどいい」配列をマップとして定義するのに役立ちます（私はちょうどいいのがとても好きで、様々なリスクがあっても、結局易言語をたくさん書いてきたので、合理的に見えます）。\nint imap[m][n]は2次元配列を作成します。imapはマップの意味です（もともとはmapと書いていましたが、同学がそれは予約語のようだと言ったので、imapに変更しました）。これでXとYを使って直接点を操作できるようになります。\nobjectとは何ですか？これは雑物の位置情報を保存するために使用します。雑物がたくさんある可能性を考慮すると、$m*n$（m×n）で定義する方が良いと感じました。これも2次元配列ですが、構造体配列のようなものです（実際、毎回object[n][0]にXを、object[n][1]にYを保存します。構造体にすることもできましたが、面倒だし、配列が好きなので、嘻嘻）。\n最終ステップ、imap配列を0で初期化します。なぜ0なのかは、次のセクションに移動してください。","マップを書く#マップを書く":"for(int c=0;c\u003cn;c++){// 内容読み込みループ for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;// tmpに仮読み込み if(tmp=='#'){// '#'（雑物）かどうか判定 imap[vc][c]=-1-imap[vc][c];// 雑物なら負数で記録（叠加：重ね合わせ/累積） object[record_c][0]=vc;// 雑物位置を記録、後続作業を減らし時間節約 object[record_c][1]=c; record_c++;// 記録変数を1増やす for(int dev_c=0;dev_c\u003c4;dev_c++){// 4回オフセット座標を計算し判定 int tx=px[dev_c]+vc,ty=py[dev_c]+c;// オフセット後のX、Y /* 配列操作時の境界外防止のための境界チェック 実際、ifが効率に深刻な影響を与えると思うなら、カスタムの境界チェックを検討すること、 まず境界を処理し、その後内部を処理する。これにより効率が上がるが、より多くのコードを書くことを意味する。 */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) // これら2行はXのチェック \u0026\u0026 (ty\u003e=0) // 次の2行はYのチェック \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){// 「雑物か否か」をチェック imap[tx][ty]++;// \u003e-1 は雑物でないので、++で影響を記録 }else{// \u003c=-1 の場合 imap[tx][ty]--; } } } } } } （変数名がc、dev_cなど奇妙なものでも気にしないでください。c++のような文を書きたかっただけです）\n文字ごとに読み込む単純なループを使用します。マップを開墾可能で初期化しているので、’.‘を読み込んでも大抵は無視して構いません。’#‘だけが私たちにとって重要です。それをimapとobjectに記録します。\nimapに記録する操作は次のとおりです：-1 - 現在のセルの内容。元々0だった場合は、今は-1になります。元々1だった場合は、-2になります。前にの各位置の情報の定量化セクションを振り返って、一致するか確認できます。\n書き終えた後、4回ループし、pxとpy配列の4つのオフセットに対応し、影響を計算します：非雑物セルは1を加算し、雑物セルは1を減算します。\nオフセットを計算するときは、結果が配列の範囲を超える可能性があることに注意してください。この場合、この存在しない座標に対して操作を行うべきではないので、境界外かどうかをチェックするifを追加する必要があります。","各位置の情報の定量化#各位置の情報の定量化":"セルは、荒地、雑物、雑物の影響を受ける荒地、または他の雑物の影響範囲内にある雑物である可能性があります。注意：1つの荒地の区画が2つ以上の雑物から同時に影響を受ける可能性があります。\n次の例に注意してください。\n.....\r.#.#.\r..... この例では、2つの#の間の.は、たとえ一方の雑物が除去されても、依然としてもう一方の雑物の影響範囲内にあるため、依然として開墾できません。したがって、この除去はこの単一の点に対しては無効であると考えます。\nこの点がいくつの雑物の影響范围内にあるかをどのように記録すればよいでしょうか？私たちは定量化戦略を持っています：0で開墾可能を表し、1で1つの雑物の影響を受けることを表し、2で2つ、最大4までです。\n同様に、雑物を配置するセルについても、除去された場合、このセルも開墾できない可能性があるため、記録する必要があります。ここでは-1で雑物を表し、-2で他の1つの雑物の影響範囲内にある雑物を表し、以下同様とします（この設定は後で記録しやすくするためのもので、後で説明します）。","始める前に#始める前に":"Note\n本ページはAI技術による翻訳を使用しています。内容は参考までにご覧ください。\n始める前に同学がGESP試験を受け、戻ってきて、ある問題でTLE（時間切れ）になったと言いました。彼はさりげなくその問題を私に書き写してくれました。それを見て少し考えが浮かんだので、易言語で書いてみましたが、どんどん乱雑になって諦めました。今週、授業が少し退屈で、他にすることもなかったので、またこの問題を拾い上げました。家で試し、少し変更を加え、無事AC（受理）しました。\n元の問題は以下のようなものです：\n小楊は大きな荒地を持っており、n行m列のグリッドで表すことができる。\r小楊はこの荒地を開墾したいと考えている。しかし、荒地のいくつかの位置に雑物がある。雑物がない荒地の区画については、その上下左右の四方向に隣接するマスにいずれも雑物が存在しない場合にのみ、開墾することができる。\r小楊は最大1箇所の雑物を除去する位置を選ぶことができる。除去後、その位置は荒地となる。小楊は、最大1箇所の雑物を除去した場合に、最大で何枚の荒地を開墾できるかを知りたい。 入力と出力の形式については、Luoguで直接確認するのが良いでしょう: Luogu B4263。ここにはすべては貼りません。","後記#後記":"この手書きのコードの原稿を皆さんと共有したいです。細部にいくつかの欠点がありますが、全体的には完成しています。 この問題を解いた後、問題にアプローチする優れた方法があることに気づきました。コードを書いても思い通りに動かないときは、自然言語でアルゴリズムを説明する方法を考えてみてください。この方法は、コードを見つめて頭を抱えるよりも概念的な欠陥を見つけやすくします。アルゴリズムを扱う方は試してみてください。\n少し眠く、頭もよく回りません。朦朧としていて不可解なことを書いてしまったかもしれません。まず寝て、起きてから直します。","解析#解析":""},"title":"アルゴリズム問題: GESP202503 レベル4 — 荒地開墾 (Luogu B4263)"},"/ja/docs/":{"data":{"":"Note\n本ページはAI技術による翻訳を使用しています。内容は参考までにご覧ください。\nここには、私が作成に関わったすべてのドキュメント（プロジェクト説明、構文標準、ドキュメント翻訳など）がまとめられています。以下のオプションからクリックして移動できます。\nBeepMusic 開発者サポート\rDCC 構文と使用説明\r研究性学習報告書"},"title":"ドキュメント一覧"},"/ja/docs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E4%B8%8E%E9%80%89%E7%94%A8/":{"data":{"":"Note\n本ページはAI技術による翻訳を使用しています。内容は参考までにご覧ください。\n編著：xiaoditx\n校閲：馬赫陽","-序文#〇. 序文":"コンピュータ技術は様々なプログラミング言語なしには成り立ちません。したがって、プログラミング言語の発展は、コンピュータ技術の発展を側面から反映していると言えます。プログラミング言語の各進化は、時代のコンピュータ技術に対する要求を証言しており、プログラミング言語の発展史は、コンピュータ技術の発展史そのものだと言えるでしょう。\n本研究性学習報告書は、「プログラミング言語」の歴史から着手し、各時代における異なる言語の特徴を分析し、コンピュータ技術の発展過程を覗き見ようと試みます。同時に、どのようにして自分に適したプログラミング言語を選択するかを分析することも目的としています。\n本文の基本構成は以下の通りです：\nプログラミング言語の先史的な原型 機械語とアセンブリ言語 高級言語の進化経路 現代プログラミング言語の多次元的発展 プログラミング言語の発展法則と選択に関する提案","1-c言語の誕生#1. C言語の誕生":"1972年、ベル研究所のデニス・リッチー（Dennis MacAlistair Ritchie）がUNIXオペレーティングシステムの開発中にC言語を創造しました。これはアセンブリ言語と比べて自然言語により近い言語であり、アセンブリ言語よりも可読性に優れています。\n以下は、Hello Worldを出力する古典的なコードです。これはC言語開発を学ぶほぼ全員が経験する共通の第一歩です。\n#include int main() { printf(\"Hello, World!\\n\"); return 0; } この5行は、一つの仕事を完了します：コンソールにテキスト文字列を出力する。\nこれは簡単なことだと思う人もいるかもしれません。C言語はこれだけであり、大した意義はないと考えるなら、それは大きな間違いです。同じ機能をアセンブリ言語で実装したものを見てみましょう：\ndata segment ;データセグメント string db 'Hello,World!$' data ends code segment ;コードセグメント assume cs:code,ds:data start: mov ax,data ;セグメントベースアドレスを取得 mov ds,ax ;レジスタにセグメントベースアドレスを送入 mov dx,offset string mov ah,9 int 21h mov ah,4ch int 21h code ends end start このようなアセンブリコードを書くには、少なくとも以下の知識が必要です：レジスタの概念、コードセグメントとは何か、データセグメントとは何か、ベースアドレスとは何か、アセンブリの多くの構文。ほとんどのアセンブリ言語の教科書は50ページ以上を費やしても、外部ソフトウェアの助けがなければソフトウェアレベルで効果を少しも見ることができません。C言語は明らかにはるかに優れています。\nC言語のあの数行に対して、ほとんどのチュートリアルは千字を超えることはほとんどありません：ヘッダファイルとは何か、メイン関数とは何か、これらの概念は非常に簡単で、説明すれば理解できます。\nしたがって、C言語の利点は以下の通りです：\nハードウェアレベルではなくソフトウェアレベルから出発し、学習コストを削減 多数の操作をネイティブサポートし、記述を簡素化し、読みやすくする もちろん、欠点もあります。gcc -S -masm=intel m.c -o m.sコマンドを使ってプログラムをコンパイルすると、コンパイラがCコードを以下のような内容に翻訳しているのがわかります：\n合計30行です。では、通常の書き方で同等のアセンブリコードを書いてみましょう（出力内容に語が一つ追加されていますが要点には影響しません）：\n純粋なアセンブリのバージョンは15行しか使用していません。つまり、コンパイラは同じ効果を実現するために倍書いたことになります。実際、この差異はコンパイルの後期段階でより顕著になります。通常のGCCコンパイルプログラムはリンク段階でいくつかのライブラリファイルをリンクする必要があり、最終的な生成物は純粋なアセンブリよりも数十倍大きくなる可能性さえあります。\nこれがC言語の欠点です。過程における「少ない記述」と引き換えに、結果において「多い記述」を使用しています。その理由は結局のところテンプレート化にあります。ここでの出力を例にとると、出力したい内容はテキストであり、printf関数を使用します。しかし、この関数は整数や浮動小数点数なども出力できます。普遍性を確保するために、コンパイラは他のデータ型に適合するコードもコンパイル後のファイルに書き込まざるを得ませんが、実際には使用しない機能もあるでしょう。\ntips：筆者は実際のところCにはあまり好感を持っていません。メモリリークの問題はさておき、手続き型言語そのものがそれほど便利ではないからです。時々C++でソフトウェアを書くのにCの構文を使わざるを得なくなり、正直言って、本当に面倒です（現在のGCCコンパイラでさえまだC++で書かれていると聞きました、なかなかおかしいです）。","1-易语言easy-language#1. 易语言（Easy Language）":"プログラミング言語は発展を続け、中国にも及びました。2000年、中国語プログラミング言語が横空出世（突然現れ）ました。表計算プログラミングを採用し、同樣に解释运行（インタプリタ実行）され、簡単な中国語を使用してソフトウェア開発を行います。これが易语言です：\n.如果（もし）（用户输入（ユーザー入力）==\"你好（こんにちは）\"）\r输出框（出力ボックス）.显示（表示）（\"你好，世界！（こんにちは、世界！）\"）\r.否则（そうでなければ）\r输出框（出力ボックス）.显示（表示）（\"无法识别（認識できません）\"） 他のプログラミング言語とは異なり、易语言の第一课（最初のレッスン）は直接ウィンドウの開発です。软件开发周期（ソフトウェア開発サイクル）が短く、中文学习编程难度（中国語でプログラミングを学ぶ難易度）が低いため、一瞬间（一瞬）で多くの人々を引き付けました。\n以下は易语言のコード記述ページのスクリーンショットです：\n易语言の利点は以下の通りです：\n英語の壁を低くする 開発を简化（簡素化）し、開発效率（効率）を加速する 强力的な官方组件（強力な公式コンポーネント）、各方面の内容（あらゆる側面の内容）をカバー 欠点もあります：\nWindowsプラットフォームに限定される オープンソースエコシステムが欠如している 32ビット编译（コンパイル）のみサポートであり、运行效率（実行効率）が不足している","1-簡潔な構文#1. 簡潔な構文":"1989年、グイド・ヴァンロッサム（Guido van Rossum）によって設計されたPythonは、コードの可読性を極限まで推し進めました。自然言語に極めて近い構文を使用することで、Pythonの習得難易度は大幅に減少し、大量のプログラミング初心者が殺到して学びました。\n以下は、PythonでHello Worldを出力するサンプルプログラムです：\nprint(\"Hello World\") わずか一行で、Pythonは出力を完了できます。これはその大きな特色の一つを体现しています：簡潔さ。Pythonはそれ以前の言語のいくつかの冗長な内容を簡略化し、開発者が機能の実装ではなく本当のアルゴリズムに集中できるようにしました。","2-cの新生#2. C++の新生":"C言語は確かに強力ですが、それは人々がすでにC言語の開発効率に満足していたことを意味するわけではありません。C言語には依然としていくつか不尽意（不十分）な点がありました：C言語は手続き型言語であり、コードの再利用率が不十分です。自身の設計上の問題により、危険な型変換や様々なエラーが発生しやすく、メモリリークのリスクも高いです。開発過程では、C言語のエラー報告機制は完全ではなく、万行のコード内でしか安定した実行を保証できません。\nしたがって、1983年、C++が出現しました。デンマークのビャーネ・ストロヴストルップ（Bjarne Stroustrup）教授がC言語を基にクラスなどの概念を追加し、所謂「オブジェクト指向プログラミングをサポートする」C++を創造しました。この言語はメモリリーク率を著しく低下させ、百万行規模の大規模プロジェクトにも対応しました。\nC++の出現は間違いなく画期的な出来事でした。その出現に伴い、多態性、カプセル化、オブジェクト、継承、名前空間、仮想関数、テンプレートなどの概念が急速に流行し、後の言語（Javaなど）にも多かれ少なかれ影響を与え、言語の抽象化能力を最重要視するようになりました。\n以下はC++のいくつかの機能のデモンストレーションです：\nclass Person { public: virtual void SenRen_BanKa() = 0; }; class DiYongJie : public Person { public: std::string play = \"YuZu soft!\" void SenRen_BanKa() override { std::cout \u003c\u003c \"Ciallo!\" \u003c\u003c std::endl; } }; 多くの概念が追加されましたが、C++とC言語は依然として強く関連しています。C言語のコードについては、C++は基本的に互換性があります（ただし古いヘッダファイルは確実に置き換える必要があります）。両方の言語は実際非常に似ています：\n#include using namespace std; int main(){ cout\u003c\u003c\"Hello World\"; return 0; } この保持と進化の共存により、C++は急速に成功し、大規模ソフトウェア開発が可能になりました。今日でもゲームエンジン、オペレーティングシステムなどの高性能分野で広く応用されています。","2-強力な標準ライブラリ#2. 強力な標準ライブラリ":"PythonをC++と比較すると、争う事実は、C++のint型変数は-2,147,483,648～2,147,483,647の間の内容しか保存できず、最も長いlong long型変数でさえ、-9,223,372,036,854,775,808～9,223,372,036,854,775,807の内容しか表現できないのに対し、Pythonのint変数にはいかなる制限もなく、オーバーフローすることなく任意の大きさのデータを保存できることです。\n上記の差異を実際の開発に当てはめて、C++とPythonの高精度計算を比較すると理解できます。算法プラットフォーム洛谷には一道题目（一つの問題）があります：1からnまでの階乗の和を求めるものです。Pythonの解答を見てみましょう：\nn=int(input()) ans=0 #最終答案存储 (最終答えの保存) rec=1 #阶乘累加的变量 (階乗を累積する変数) for i in range(1,n+1): rec*=i ans+=rec print(ans) 数行で搞定（解決）しました。とても簡単な問題ですよね？\nしかし、洛谷で標示されている難易度は比較的高いままです。なぜでしょうか？以下のC++コードを見ればわかります：\n... (長いC++コードのため省略) ... C++でこの問題を書くのは異常に長いです。これは、この問題のデータ計算結果が非常に長くなるため、C++は結果のオーバーフローを防ぐためにシミュレーションアルゴリズムを使用する必要があるからです。一方、Pythonには元々シミュレーション機構が組み込まれており、ユーザーが自分で書く必要はありません。","2-文言wenyan-lang#2. 文言（Wenyan-lang）":"易语言の後、中国語プログラミングは一時的に興隆しました。2019年には、文言（Wenyan-lang）という名前のプログラミング言語が再び興りました。\n名前が示す通り、文言は文言文（古典中国語）を使用してプログラムを書くため、それはほとんど一種の芸術形態となり、プログラミングツールではなくなりました：\n吾有一數。曰三。名之曰「甲」。\r為是「甲」遍。\r吾有一言。曰「「問天地好在。」」。書之。\r云云。 文言プログラミング言語は一種の実験的な言語であり、文言文化とコンピュータ文化を传播（広める）ために使用されます。Chicken言語、///、Glass言語、Piet言語などと同様に、一種の半藝術品（セミアート作品）であり、これはプログラミング言語の高度な発展を示しており、人々がある程度の創造性と芸術性を持つ分野の探求を考慮し始めるきっかけとなりました。\ntips：易语言は筆者が最初に接触したプログラミング言語です。これは間違いなく「初心者に優しい言語」です。なぜなら、あまりにも便利だからです。グラフィカルインターフェース下でウィンドウ設計を完了できるため、すべてのチュートリアルの第一课はウィンドウから講義を始めます。正にこのため、私は後に他の言語のGUI作成が極めて面倒だと感じるようになりました。","3-特徴比較#3. 特徴比較":"特性 C C++ プログラミングパラダイム 手続き型 マルチパラダイム メモリ管理 手動 手動 + スマートポインタ 標準ライブラリのサイズ 最小 巨大 名前空間管理 欠如 完全 ヘッダファイル包含機構 原始的 改良済み アプリケーションシナリオ 組み込みシステム 大規模商業ソフトウェア tips：C++は多くのCスタイルの操作を保持しながら優れた便利な標準ライブラリを追加したため、算法界では時々「C with STL」と冗談交じりに呼ばれることさえあります。","pythonの利点#Pythonの利点":"定義上、Pythonはインタプリタ型言語であり、Javaと同じ柔軟性と高い移植性を持っています。そしてスクリプト言語として、Pythonはデータ計算などの自動化作業により長けているため、大規模言語モデル、ウェブクローラーなどで広く応用されています。\nPythonの利点は以下の通りです：\n標準ライブラリが強力で、操作が簡潔 オープンソースコミュニティが継続的に維護（メンテナンス）されている サードパーティ製ライブラリが豊富 インタプリタ型言語のため、デバッグ時間の節約 tips：ここ数年、Pythonを一无是处（全く役に立たない）と非難する人々がいます。インタプリタ型言語は実行效率（実行効率）が奇低（異常に低い）と考えています。私は各有各的好处（それぞれに利点がある）と言うしかありません。例えば、Pythonは情報技術の必修1の段階でTKというウィンドウライブラリを教えることができますが、C++はMSDNの中で自分で摸爬滾打（這いずり回って苦労する）しなければ文档（ドキュメント）を見つけられません（実体験）。","一-プログラミング言語の誕生#一. プログラミング言語の誕生":"人類は怠惰であり、昔からそうでした。後漢時代、ジャカード織機と呼ばれるものが広く利用されました。この装置は商代まで遡ることができ、その機能から、それが置かれた時代とはほとんど相容れないものでした：\n紋様式ジャカード織機は後漢に出現し、花楼とも呼ばれました。それは線製の花本（紋様 pattern chain）で提花プログラムを保存し、衢線（ harness cords）で経糸を引き上げ開口（shed）を作りました。花本は提花機上に紋様情報を保存する一連のプログラムであり、紋様の要求に従って経線を代表する脚子線（lingzi threads）と緯線を代表する耳子線（erzi threads）で編成されました。\n客観的物体を利用してプログラムを記録し労力を節約するという点で、ジャカード織機は、後漢の時代に、時代を先取りした種を静かに埋めました。シルクロードが開通すると、ジャカード織機はヨーロッパに流入し、何世代もの工人、物理学者、数学者の手によって、次第に根を下ろし発芽し、「コンピュータ技術」という大木に成長しました。","七-中国語インターネットにおける探求#七. 中国語インターネットにおける探求":"","三-アセンブリ言語プログラマーたちの自然言語への最初の追及#三. アセンブリ言語：プログラマーたちの自然言語への最初の追及":"機械語がそんなに書きにくいなら、どうすればいいのでしょうか？プログラマーたちは考えました：機械と直接「会話」するのが少し困難なら、翻訳者を見つければいいのではないか？こうしてアセンブリ言語が誕生しました。\n百度百科はアセンブリ言語を次のように定義しています：\nアセンブリ言語（Assembly Language）は、電子計算機、マイクロプロセッサ、マイクロコントローラ、またはその他のプログラミング可能なデバイスのための任何一种の低水準言語であり、記号言語とも呼ばれる。\n簡単に言えば、アセンブリ言語は万能の通訳者のようなものです。この「通訳者」は一種の言語を制定しました。あなたが任意の機械と「対話」する必要があるときは、この「通訳者」を見つけ、その制定した言語を話せば、状況に応じて異なる表現で機械に伝えてくれます。\n例えば、機械Aは0000を加算演算と規定し、機械Bは1010を加算演算と規定します。この時、アセンブリ言語は加算演算を+であると規定します。そうすれば、私たちがプログラムを書くときは+と書くだけでいいのです。アセンブリ言語は機械Aに対しては0000を伝え、機械Bに対しては1010を伝えます。\nアセンブリ言語のこの「人によって異なる」翻訳により、機械語の機械への強い依存性の問題が一定程度解決されました。同時に、0000を+に変えるような操作を通じて、プログラムの作成がより直感的になり、記憶しやすくなりました（1 0000 2と1+2、どちらが覚えやすく書きやすいでしょうか？これは明らかです）。\nしたがって、アセンブリ言語は時に記憶を補助するテキストという意味で、ニーモニック（助記符）とも呼ばれます。以下の定義を参照してください：\nニーモニック（mnemonic）は、人々の記憶を容易にし、命令の機能と命令オペランドを記述できる記号である。ニーモニックは、命令機能を示す英語の単語またはその略語である。\nアセンブリの導入により、記憶はもはや退屈で理解しにくいものではなくなりました。例えば、MOV、ADD、CALLなどの命令があり、少しでも英語の基礎があれば十分に理解でき、2進数よりも速く記憶できるようになります。\n異なる設計の機械間には無視できない違いがあることを考慮し、アセンブリもIBM PCアセンブリ、ARMアセンブリ、GNU ASM、MASM、NASMなど、さまざまなバージョンが派生してきました。ここでは詳細には触れません。\nここで、アセンブリ言語に関するある記事の評価を引用します：\nアセンブリ言語の出現は、プログラマーを煩雑な2進数プログラミングから解放し、プログラムの論理と機能実装により集中できるようになり、コンピュータソフトウェアの発展に重要な基礎を築いた。\n要するに、アセンブリ言語は人々に「その然（ぜん）を知って其の所以（ゆえん）を知らず」の状態に到達させます。コンピュータ技術の学習において、これはほとんどの場合実際には良い状態です。なぜなら、これにより煩雑な低水準の原理から解放され、コンピュータで問題を解決したいとき、機械の低水準アーキテクチャがどうなっているかをまず見るのではなく、どのようなアルゴリズムを使うかを直接考えられるようになるからです。\ntips：筆者はアセンブリ言語が非常に好きです。それは低水準に近く、コンピュータ科学の基礎への扉を開く鍵です。これは非常に挑戦的な言語であり、ソフトウェアの動作原理を最も学べる言語です。","九-選択に関する提案#九. 選択に関する提案":"私たちの研究は、プログラミング言語が各有所长（それぞれ長所がある）と結論付けています。言語の選択は、自身のニーズに応じて合理的に組み合わせ、開発効率とアプリケーションシナリオを考慮して行うべきです。以下にいくつか推奨される組み合わせ方案を示します。\n低水準開発\n推奨：C / Rust / 少量のアセンブリ シナリオ：オペレーティングシステム、組み込みシステム 利点：ハードウェアに近く、多种の形態（多种の形態）にコンパイル可能 迅速な開発\n推奨：Python / JavaScript / 少量のshell / 易语言 シナリオ：Webアプリケーション、データ分析 利点：既成の関数、効率的な開発 クロスプラットフォーム要件\n推奨：Java / Kotlin / QTフレームワーク シナリオ：エンタープライズ級アプリケーション、モバイル開発 利点：クロスプラットフォーム、移植性が良い 学術研究\n推奨：Python / Julia シナリオ：科学技術計算、機械学習 利点：コードを简化（簡素化）、コードを書くことが負担にならないようにする 興味駆動\n試す：文言 / 易语言 価値：プログラミングの本質を理解し、計算思维（計算論的思考）を育成する プログラミング言語を選択する際、以下の内容が关键考量维度（重要な考察次元）です：\nプロジェクトの性能要求：高性能要件には断じて高級言語を選ばず、専門的计算（計算）にはなるべく低級言語を選ばない。 チームの技術スタック现状（現状）：チームメンバーのスキルに基づいて決定する。 コミュニティエコシステムの成熟度：コミュニティは開発の支柱です。Rustコミュニティは典型的な案例（ケース）です。良好で成熟したコミュニティは、常にどこでもすべての開発者を助けることができます。 個人の学習曲線：個人の学習計画に基づいて選択する。","二-第一世代プログラミング言語機械語#二. 第一世代プログラミング言語——機械語":"人類と機械の初めての「対話」は、機械語によって行われました。これは純粋な0と1だけで構成される「言語」であり、これが定義上の第一世代コンピュータ言語です。\n0と1の世界は、コンピュータの最も根底にある「本質」です。したがって、十分に基本的で、十分に複雑であり、記述効率も比較的低くなります。以下に、機械語コードの短い例を示します。感じ取ってみてください。\n2進数表現： 10001011 01000101 00000100 01011011 10001001 11000011 16進数表現： 8b 45 04 5b 89 c3 0と1の混在により、コードの内容が識別しにくいことが明らかにわかります。したがって、人間が所謂筋肉記憶のようなもので素早く認識することは非常に困難です。\n実際、上記の長い文字列は、簡単な加算演算さえ支えるには不十分です。もし今、誤って一文字書き間違えたら：\n誤り： 10001011 01000101 00000100 01011011 10001101 11000011 正解： 10001011 01000101 00000100 01011011 10001001 11000011 どちらが間違っているか一目でわかる人はいるでしょうか？おそらくいないでしょう。機械語で加算を実装するには少なくとも3行必要です。たった3行以内でさえ、誤り修正の難しさがこれほど高いのですから、実際のソフトウェア開発に使用する際の困難は想像に難くありません。\nこれが機械語の長所と短所を引き起こします：\n長所は以下の通りです：\n最も低水準に近く、実行速度が十分に速い 機械が直接認識して実行でき、補助プログラムが不要 余計な無駄な内容が出現しない（プログラムサイズが小さい） 短所は以下の通りです：\n記憶难度が大きい 低水準を直視するため、学習難易度が高い 機械への依存性が強く、一種類の機械に対して一種類の構造であり、移植が困難 0と1のみであるため、誤りを書きやすく、誤り修正も困難 王爽氏の『アセンブリ言語』における以下の記述を思わず思い出します：\n機械語プログラムの書取りと読取りは簡単な仕事ではなく、すべての抽象的な2進コードを覚えなければならない。上記は非常に単純な小さなプログラムであるが、機械語の晦渋難解さと誤り確認の難しさを暴露している。こんなに小さなプログラムを書くのでさえこうなのだから、実際に役立つプログラムは少なくとも数十行の機械語が必要だとすると、状況はどうなるだろうか？","五-javaクロスプラットフォームの夢の実現#五. Java：クロスプラットフォームの夢の実現":"高級言語が誕生してしばらく後、インターネットが蓬勃に発展（急成長）しました。しかし当時は、静的ページを表示するためにHTMLのようなマークアップ言語だけに依存していました。そのため、当時インターネットにアクセスすることは、実質的にはオンラインのWord文書を閲覧することであり、これはインターネットの可能性を大幅に制限しました。人々はすぐにこれに気づき、ウェブサイトを動的にする手段を探し求めていました。しかし、初期の言語はデバイスに対する要求が非常に特化しており、コンピュータソフトウェアは決して（絶対に）マイコンなどのハードウェア上では実行できませんでした。そのため、探求の方向は、クロスプラットフォーム伝播能力を持つソフトウェアを開発する技術を持つことになりました。\nこのような背景の中で、Sun MicrosystemsはJava言語を発表し、「Write Once, Run Anywhere」（一度書けば、どこでも実行）という革命的な理念（コンセプト）を伴って登場しました。発表されるとすぐに急速に成功しました。1996年1月、Sunは最初のJava Development Kit（JDK 1.0）をリリースし、Javaが独立した開発ツールとなったことを示しました。わずか8か月後、約8万3千のウェブページがJava技術を応用していました。\n以下はJavaのコードです：\npublic class Main { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 実際、Javaは依然としてC/C++の多くの考え方を保持しています。なぜなら、それ自体がSun Microsystemsによって開発されたOak言語から発展したものであり、Oak言語はSunがマイコンプログラムを開発するために作成した簡略化されたC++だからです。\nJavaは設計当初から消費者向け家電製品ソフトウェアの開発を目的としていたため、「信頼性」に対して多くの最適化が行われました。したがって、Javaには以下の利点があります：\nC/C++から進化したため、習得が容易で、構文がより簡潔 ポインタという概念を削除した。ハードウェアは開発者にとってほとんど完全なブラックボックスとなり、ソフトウェアの安全性を保証すると同時に学習コストを削減 高い移植性 これらの利点により、Javaはエンタープライズ級アプリケーション開発で主導的立場を占め、Android開発の基礎言語の一つとなりました。しかし、移植性のためにもたらされた性能上の損失もあり、高性能計算シナリオには適していません。\ntips：Javaは冗長で有名で、多くのプログラマーからからかわれる点です。正直なところ、私のJavaに対する初期の印象は「C++のクラスを単独で引き出した」というものでした。","八-総括発展の法則#八. 総括：発展の法則":"上記のいくつかの例から、言語の変化の特徴を見ることができます：\n抽象化レベルの向上 プログラミング言語は不断に「抽象化」に向かって発展し、コードの再利用率が逐渐に向上し、開発効率の向上を可能にします。 进化方式（進化の方法）：機械命令 → 記号化 → 構造化 → オブジェクト指向 → 関数型プログラミング\n效率（効率）のバランスの進化 開発者たちは、開発と使用のどちらが重要かについてより喜んで議論するようになりました。 进化方式：実行效率優先 → 開発效率優先 → 両者の動的バランス\n領域特化 各領域で专门性的な言語（専門的な言語）が出現しました。典型的な例は、Windowsシステム下的.rcファイル、Inno Setupの専用インストーラパッケージ記述言語などです。 进化方式：汎用言語 → ドメイン固有言語（DSL）\n構文の簡素化 进化方式：冗長な構文 → 簡潔な表現 → 自然言語への接近（第五世代プログラミング言語の探求方向）","六-python簡潔さの哲学の勝利#六. Python：簡潔さの哲学の勝利":"","十-後書き#十. 後書き":"このテーマは、私がずっと以前から研究を始めたかったものです。今回の研究性学習によって実現でき、自是无比兴奋（もちろんこの上なく興奮しています）。そのため、忙前忙后（前後に忙しく）多くのことをしましたが、確かに少し混乱も追加しました。\n文档の编写者（文書の編著者）として、私は组长（リーダー）のように深厚な专业素养（深い専門的素養）や、一つの研究方向に専念する钻劲（集中力）を持っていません。不精（熟達していない）な知識と自ら尚可（まだまあまあ）と称する文学的水平（文章力）を借りて、これらの最终呈现的文字（最終的に提示された文章）を苟且（やむを得ず）書きました。终究（結局）少し惶恐（恐れ多い）であり、書かれた内容に欠陥があるのではないかと心配しています。読者の各位が記事中の誤りを発見されたならば、大小に関わらず、どうかGitHubのIssueで提交（提出）していただければ幸いです。","十一-再版随笔随想#十一. 再版随笔（随想）":"言語というもの自体が争议（論争）に満ちています。绝对的な正しいとか間違いとか良いとか悪いとかはありません。phpが多くのプログラマーによって「世界上最好的语言」（世界で最高の言語）と皮肉られているように、結局は広く使用されています。どんな言語であれ、自分に适合（合う）さえすれば、それは良い言語です。\n少し前に、C++とPythonの対話というジョークを見ました。以下に大致（おおむね）記録します。\nC++がPythonに「あなたの名前は何ですか」と尋ね、Pythonは答えません。C++は自分が礼儀正しくないと思い、自己紹介を始めます。しかし、自分の名前を言おうとしたところで行き詰まります。スタックエラーが発生したため、エラーを報告しながら去らざるを得ません。C++が遠くへ行ってしまった後、Pythonはようやく叫びます：「Python！」\nこのジョークは、C++が書きにくく、いつもエラーやクラッシュを起こすのに対し、Pythonの反応はとても遅く、C++が何百行もコードを実行し終わってもまだ入口にいるかもしれない、と言いたいのです。このジョークがうまい点は、C++とPythonの欠点を同時に阐明（明らかに）していること、つまり、完璧な言語は存在しないという概念を伝えていることです。","参考文献#参考文献":"川合秀实『30日でできる！OS自作入門』| 人民郵電出版社 プログラミング言語発展簡史 プログラマーとして知っておくべきプログラミング言語年代記 王爽『アセンブリ言語』| 清華大学出版社 百度百科-アセンブリ言語 百度百科-ニーモニック Deep Learning - Ian Goodfellow、Yoshua Bengio、Aaron Courville 黒馬程序员『Webデザインと制作プロジェクト教程』（第2版） | 人民郵電出版社 機械から知能へ：アセンブリ言語の過去、現在、未来 洛谷-P1009-階乗之和 Java 張毅剛、趙光权、劉旺『単片機原理及応用』第三版 | 高等教育出版社 郭衛斌、羅勇軍『算法競賽入門到進階』 | 清華大学出版社 MSDN - Microsoft Learn C++、C およびアセンブラー\\C++ 構文リファレンス C++ reference 汪楚奇『深入浅出程序設計競賽』 | 高等教育出版社 郁紅英、王磊、武磊、李春強『計算機操作系統』（第三版） | 清華大学出版社","四-高級言語の夜明けccの革命#四. 高級言語の夜明け：C/C++の革命":"","声明#声明":"文中の「機械語」セクションにおいて、機械語コードはアセンブリコードをOnline x86 and x64 Intel Instruction Assemblerで変換したものです。変換に問題があるかどうか不确定（不確実）であるため、参考価値はなく、機械語の不便さを辅助理解（理解を助ける）するためにのみ使用されています。"},"title":"研究性学習総合報告書"},"/ja/docs/beepmusic/":{"data":{"beepmusic#BeepMusic":"BeepMusicV 2.1.2.0 终端版本（其实只有终端版，嘻嘻）\n跳转到开发者帮助","功能介绍#功能介绍":"一款可以将简谱转换为频率和时长的软件，转换结果可供Beep函数使用，使蜂鸣器实现奏乐效果","开发者帮助#开发者帮助":"HELPS文件夹下是项目帮助，有些教程文档（我怕我自己忘了怎么写了放进去的），其中Introduce.md会介绍项目的整体结构、各个文件的功能","播放帮助#播放帮助":"对于连续播放短声音困难的硬件，建议使用耳机将蜂鸣器转为电脑内音，经过测试，通常的设备在播放「千本桜」（t=180）时，即使使用耳机，仍然会有声音是无法放出的，因此可以采用t=45;参数播放，录制结果后对结果加速4.2倍左右","示例#示例":"《call of silence》\n参考Call of Silence简谱，基本遵循原谱内容，在后半部分和前面的细节部分做了一定的调整\n下面是标准的速度版本：\nt=72; -6_ 3_ 3. 3_ -7. -6__ 1-. -6_ 3_ 3. 3_ 7. +1__ 3-. 6_ +3_ +3. +3_ 7. +1__ 5-. 5_ 3__ 5-. +2_ +1__ +2.. +1__. 6-. 0--- 3_ 2_ 2_ 1_ 1_ 5_ 1 -7_ 1-. 3_ 2_ 2_ 1_ 1_ 3_ 2 3_ 1-. 3_ 2_ 2_ 1_ 1_ 5_ 5_ 5_ -7_ 1-. -6_ 1_ 2 2_ 1_ 2_ 3_ 2_ 2 1. 0 0_ +1_ 7_ 3__ 6. 0_ +1_. 7_ 3__ 1. 0_ +1_ 7_ 3__ 6 6__ 7 +2__ +1. 0_ +1_ 7 3__ 6_. 0_ +1_ 7_ 3__ 1_- 0_ +1_ 7_ +1__ +2 +3_ +3_. +1_ 7- 对于外放，蜂鸣器可能会吞掉一些声音，t=45;可能更合适","简谱表示规则#简谱表示规则":"基本音符：1(do), 2(re), 3(mi), 4(fa), 5(sol), 6(la), 7(si), 0(休止符)\n前缀：调整音高，+升高八度，-降低八度（可叠加，如++5）\n后缀：\n用于调整单个音的时值\n_：减时线（每增加一个，时值减半）\n-：增时线（每增加一个，时值加倍）\n.：附点（时值增加50%，最多两个）\n~：延音线（连接相同音高的连续音符使之合并）\n速度设置：t=x;（x拍/分钟，默认60），此值为BPM值，简谱一般会提供，不提供的也有参考信息进行查询，一些专业软件也提供检测功能","自行编译方式#自行编译方式":"法一：运行根目录下的build.bat文件，该文件会在release目录下生成两个可执行文件，分别是64位和32位，前者需要安装有g++，后者需要安装有i686-w64-mingw32-g++，如果没有前者，编译不进行，没有后者，则只编译64位版本 法二：运行MakeExe.bat，生成调试版 法三：使用编辑器打开build.bat，把不想要的位数版本删掉（在文档下方，已用注释分割出）","软件操作#软件操作":"初始输出如下：\n===============================================\rC++ 简谱转Beep播放器 (增强版)\r===============================================\r当前曲谱: t=120; 1 2 3 4 5 6 7 #1 +1\r音符解析结果:\r=============================================\r记谱 频率(Hz) 时长(ms) 类型\r------------------------------------------\r1 261 500 音符\r2 293 500 音符\r3 329 500 音符\r4 349 500 音符\r5 392 500 音符\r6 440 500 音符\r7 493 500 音符\r#1 277 500 音符 (升半音)\r+1 523 500 音符\r=============================================\r控制选项:\r[P] 播放音乐 [H] 帮助文本\r[I] 自定义曲谱 [Q] 退出程序\r请选择: 其中\n按下P，播放当前乐谱 按下H，可查看帮助文本 按下I，可输入自定义曲谱 按下Q，退出软件 按下I后，如果是误触，可以输入return（大小写不敏感）来退出录入状态，原本的曲谱可以保留\n软件初次启动时会注册Ctrl+Alt+Shift+S的热键，乐曲播放时可使用此热键停止\n默认设置下，按下P会看到这样的输出：\n请选择: 播放中... (按任意键停止) Play: 1 =\u003e Freq: 261 Hz, Duration: 500ms Play: 2 =\u003e Freq: 293 Hz, Duration: 500ms Play: 3 =\u003e Freq: 329 Hz, Duration: 500ms Play: 4 =\u003e Freq: 349 Hz, Duration: 500ms Play: 5 =\u003e Freq: 392 Hz, Duration: 500ms Play: 6 =\u003e Freq: 440 Hz, Duration: 500ms Play: 7 =\u003e Freq: 493 Hz, Duration: 500ms Play: #1 =\u003e Freq: 277 Hz, Duration: 500ms Play: +1 =\u003e Freq: 523 Hz, Duration: 500ms 按任意键以继续... play表示发出声响的音符，后面跟着音符的原文是便于查找，Freq标记声音频率，Duration标记持续时间\n特殊的，如下\n0\rRest: 0 =\u003e Duration: 1000ms 对于休止符，输出Rest，Freq参数会被省略"},"title":"_index.ja"},"/ja/docs/beepmusic/%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/":{"data":{"1标准方案原生cout#1.标准方案（原生cout）":"1.标准方案（原生cout）使用\\033[开头m结尾，中间包裹参数\n属性代码 功能 属性代码 功能 属性代码 功能 0 重置所有属性 30 黑色 40 黑色 1 高亮/加粗 31 红色 41 红色 2 暗淡 32 绿色 42 绿色 4 下划线 33 黄色 43 黄色 5 闪烁 34 蓝色 44 蓝色 7 反转 35 品红 45 品红 8 隐藏 36 青色 46 青色","2y_print#2.y_print":"256色输出的简化包装，项目中未采用此方案，在function.cpp中予以保留，可以在其他改版中使用但不建议PR中包含此内容（虽然我知道根本不会有人给这个项目交PR🤓）\ny_print(“hello”,10); 0 = 黑色 8 = 灰色 1 = 蓝色 9 = 淡蓝色 2 = 绿色 10 = 淡绿色 3 = 浅绿色 11 = 淡浅绿色 4 = 红色 12 = 淡红色 5 = 紫色 13 = 淡紫色 6 = 黄色 14 = 淡黄色 7 = 白色 15 = 亮白色"},"title":"彩色输出.ja"},"/ja/docs/beepmusic/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/":{"data":{"ini结构说明#ini结构说明":"还没写","项目结构介绍#项目结构介绍":"项目结构介绍结构与文件功能\nroot/ ├── .vscode/ vscode配置文件 │ ├── setting.json │ └── tasks.json ├── head/ │ ├── function.h 封装部分常用的函数（的声明部分） │ └── mainhead.h 头文件（提供大部分cpp）+函数声明（提供main.cpp） ├── HELPS/ │ ├── Color_Print.md 彩色输出帮助 │ ├── Hot_Key.md 热键帮助 │ ├── RC_help.md resources.rc文件的一些帮助内容 │ └── README.md 项目介绍 ├── Icons/ │ ├── favicon.ico 同上级目录的icon.ico，仅名称不同 │ ├── ori.jpg 软件图标原图 │ └── result.png 软件图标透明图 ├── release/ 编译结果（使用build.bat的） │ ├── installer/ 用于放置安装包相关内容 │ │ ├── install_win_64.exe 安装包（编译结果） │ │ └── installer_creator.iss 源码（模板） │ ├── BeepMusic_release_win_x64.exe │ └── BeepMusic_release_win_x86.exe ├── src_c/ │ ├── config.cpp 配置文件读写 │ ├── function.cpp 封装功能函数的定义，简化开发（如彩色输出） │ ├── mods.cpp 菜单栏选项对应激活的函数 │ ├── play_core.cpp 存放核心解析、演奏函数 │ ├── test.cpp 测试文件（保留做纪念也可随时启用进行测试） │ └── UI.cpp UI显示（其实就是输出看起来像是UI的东西） ├── tools/ │ └── XD开发工具-T1 │ ├── 开发工具.exe 热键查询+鼠标查询工具（之前用易语言写的小玩意） │ ├── 源码.e 程序源码，遵守本仓库协议开源 │ ├── iext.fnr 支持库文件 │ └── krnln.fnr 支持库文件 ├── 备忘.txt 更新备忘录，记录需要的功能等 ├── BeepMusic_alpha.exe 开发调试版本的编译结果 ├── build.bat 编译最终版本用的批处理，该批处理会同时编译resources.rc ├── icon.ico 软件图标 ├── LICENSE 开源协议 ├── main.cpp 主函数放置的文件，编译在此处进行 ├── MakeExe.bat 生成调试版用的批处理，不使用VScode的开发者可以借此编译 ├── README.md 本项目的readme └── resources.rc 资源文件，放置图标信息、软件信息"},"title":"文件结构.ja"},"/ja/docs/beepmusic/%E7%83%AD%E9%94%AE%E6%B3%A8%E5%86%8C/":{"data":{"热键注册帮助#热键注册帮助":"热键注册帮助微软键代码查询：Virtual-Key 代码\n键代码查询工具：本地路径./tools/XD开发工具-T1，仅支持10进制查询"},"title":"热键注册.ja"},"/ja/docs/beepmusic/rc%E6%96%87%E4%BB%B6%E5%B8%AE%E5%8A%A9/":{"data":{"":"在 Windows 资源文件 (.rc) 中，这些关键字用于定义可执行文件的版本信息结构，以下是详细解释：","信息块解析#信息块解析":"BLOCK \"StringFileInfo\"\n作用：包含所有语言特定的字符串信息 结构： BLOCK \"StringFileInfo\"\rBEGIN\rBLOCK \"\" // 如 \"040904B0\"\rBEGIN\rVALUE \"Key\", \"Value\" // 实际显示的版本信息\rEND\rEND BLOCK \"VarFileInfo\"\n作用：定义文件的翻译信息（语言和代码页） 结构： BLOCK \"VarFileInfo\"\rBEGIN\rVALUE \"Translation\", , END 示例：VALUE \"Translation\", 0x0804, 1200 表示简体中文 Unicode","关键概念说明#关键概念说明":"部分 功能 典型值 文件属性区 定义二进制特性 FILEFLAGSMASK 有效标志位掩码 VS_FFI_FILEFLAGSMASK FILEFLAGS 实际版本标志 0x0L (正式版) FILEOS 目标操作系统 VOS_NT_WINDOWS32 FILETYPE 文件类型 VFT_APP (应用程序) FILESUBTYPE 文件子类型 VFT2_UNKNOWN 字符串信息区 用户可见信息 StringFileInfo 多语言字符串容器 语言标识 “080404B0” (简体中文) 变量信息区 语言配置 VarFileInfo 语言定义容器 Translation 默认语言设置 0x0804, 1200","工作流程#工作流程":"系统先读取 VarFileInfo 确定默认语言 在 StringFileInfo 中查找匹配的 LangID+CodePage 块 显示对应语言的字符串信息 文件属性区 (FILEOS等) 提供系统级元数据 ⚠️ 注意：当修改语言时，必须同步更新：\nStringFileInfo 中的语言块 ID (如 080404B0) VarFileInfo 中的 Translation 值 实际字符串内容（如需本地化） Windows 资源文件(.rc文件) 关于资源文件","核心结构解析#核心结构解析":"FILEFLAGSMASK\n作用：指定哪些位在 FILEFLAGS 字段中是有效的 值：通常设置为 VS_FFI_FILEFLAGSMASK（预定义值 0x3FL） 含义：表示只检查 FILEFLAGS 的低 6 位 FILEFLAGS\n作用：描述文件属性标志 常用值： 0x0L：正式版 VS_FF_DEBUG (0x1L)：调试版本 VS_FF_PRERELEASE (0x2L)：预发布版 VS_FF_PATCHED (0x4L)：已修补版本 VS_FF_PRIVATEBUILD (0x8L)：私有构建 示例：0x0L 表示标准发布版本 FILEOS\n作用：指定文件支持的操作系统 常用值： VOS_NT_WINDOWS32：Windows NT 32 位系统 VOS__WINDOWS32：通用 Windows 32 位 VOS_DOS_WINDOWS16：Windows 3.x 16 位 FILETYPE\n作用：定义文件类型 常用值： VFT_APP：应用程序 (EXE) VFT_DLL：动态链接库 VFT_DRV：设备驱动 VFT_FONT：字体文件 VFT_VXD：虚拟设备驱动 FILESUBTYPE\n作用：当 FILETYPE 需要细分时指定子类型 对 VFT_APP：必须设为 VFT2_UNKNOWN（无子类型） 对 VFT_DRV：可指定打印机/键盘等子类型 对 VFT_FONT：可指定矢量/位图字体"},"title":"rc文件帮助"},"/ja/docs/dcc-script/":{"data":{"":"DCC是一款简单的编程语言，语法上是仿照汇编设计的，所以你甚至可以通过汇编模块将纯汇编代码引入你的程序\n设计理念上讲，DCC不仅学习了汇编的风格，还吸收了C++与易语言的部分思想，如面向对象编程、中文编程、多态等等，调和了高级语言和低级语言的差异，为各种编程问题提供了独特的解决方案\n实际上，DCC是为了简化纯文字游戏开发而制作的，因此，其官方库尤为适合制作纯文字游戏，尤其是利用控制台的纯文字游戏\n基础语法\r高级语法"},"title":"DCC script"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/":{"data":{"":"下面将介绍DCC的基本语法和思想，使用基础语法，你几乎可以使用DCC的所有功能来编写纯DCC程序，可以编写出简单的控制台程序、模块文件\n函数调用\r特殊函数\r数据类型\r敏感性\r常量\r数值/逻辑运算符\r注释\r优先级\r缩进"},"title":"基础语法"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%BC%98%E5%85%88%E7%BA%A7/":{"data":{"":"DCC改变符号优先级，对于函数调用，在一个参数的位置，可以使用（）或()包裹一个语句，这个语句的执行结果会成为这个参数位的值，括号的包裹内，一定是函数名+参数（参数可空）的形式\n例子：\n；普通语句\r输出 “1”\r；嵌套语句\r输出 （转到文本 (取整 3-2)）"},"title":"改变优先级"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/":{"data":{"":"DCC程序的骨架就是函数，纯DCC程序不含缩进，因此函数名会整齐的排列在左侧\n程序中，标准的函数调用是这样写的：\n函数名 [参数1][,参数2][,参数3][,......] 参数是可省略的，但针对指定个参数的函数，对应数目的逗号需要要保留，下面列出来的几个语句都是合法的：\n输出 ,\r输出 \"你好\",\r输出 \"你好\",1 函数名支持使用一切Unicode字符定义，因此可以包含多种语言"},"title":"函数调用"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%B8%B8%E9%87%8F/":{"data":{"":"DCC拥有系统常量和自定义常量，使用时需使用#进行表达，如下面的示例：\n#asm\r#iostream\r#cpp\r#换行符\r#逻辑型 实际使用效果：\n定义变量 #大数,20"},"title":"常量"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%8F%E6%84%9F%E6%80%A7/":{"data":{"":"DCC对大小写敏感但对符号不敏感，例如，Get和GET对于DCC而言是两个函数，但[]和【】甚至【]对于DCC是同一个符号，下面以引号为例：\n；合法的引号：\r“你好”\r\"你好\"\r“你好\"\r\"你好”\r”你好“\r“你好“\r”你好”\r”你好\"\r\"你好“"},"title":"敏感性"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E5%80%BC%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/":{"data":{"":"DCC支持运算符号如下：\n*\r×\r/\r÷\r%\r+\r-\r！\r!\r\u0026\r^\r\u0026\u0026\r||\r^^\r**\r~\r\u003e\u003e\r\u003c\u003c\r|\rand\ror\rnot\r且\r或\r非"},"title":"数值/逻辑运算符"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/":{"data":{"":"DCC原生支持数据类型包括整数型、小数型、双精度小数型、逻辑型、文本型、大数等数据类型，对于常数的表达，DCC也有相应的符号来描述常数的数据类型\n对于数字，直接写出即可，是否小数会根据前后的代码智能判断，对于文本型，使用全角或半脚引号包裹（参见敏感性章节的示例），对于真、假、true、FALSE（不区分大小写）这四个关键字，则认为是逻辑型数据（布尔型）"},"title":"数据类型"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%B3%A8%E9%87%8A/":{"data":{"":"DCC使用全角或半角的分号来书写注释，如下：\n；注释\r;注释 出现这种注释标记，从标记后面一直到这一行的结束都是注释内容，内容不会生效也不会编译进程序\n有时，为了灵活的嵌套，DCC还会支持收尾包裹式的注释，使用@或/**/标记首尾，从第一个标记到下一个标记之间的内容都是注释，@符号（仅限@）在文本常量中出现不会被视为注释的标记\n“这是文本@这还是文本”@这里是注释@\"这里不是注释\"\r“你好，@这里是文本，不会成为注释@，你好”\r输出@注释@ （转到文本 3@这也是注释@）\r/*这种注释和C语言的性质相同*/ 上面这两种注释是支持多行的"},"title":"注释"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/":{"data":{"":"DCC拥有一些特殊函数会特殊高亮，这些函数在编译中会被特殊处理，也是DCC的功能核心，这些功能即使不引入库也可以照常使用，而这些函数名也就成为了DCC的保留字，不允许其他任何库用作函数名\n函数名 类型 功能 如果 流程控制 判断参数是真还是假 如果结束 流程控制 标志如果彻底结束 否则 流程控制 如果的参数为假进入该分支 if 流程控制 同上“如果”，下面的英文中文都是对应的，不再做解释 else 流程控制 --- endif 流程控制 --- 计次循环 流程控制 循环开始，指定循环次数并给出变量记录 记次循环尾 流程控制 标记计次循环结束 跳出循环 流程控制 跳出当前循环，代码跳转到循环尾后 到循环尾 流程控制 到达循环尾前，进入下一次循环或者完成循环 条件循环 流程控制 根据条件决定是否循环 for 流程控制 --- endfor 流程控制 --- break 流程控制 --- continue 流程控制 --- while 流程控制 --- 定义函数 函数操作 定义一个函数 结束函数定义 函数操作 完成函数定义 def 函数操作 --- enddef 函数操作 --- 创建板块 作用域 创建一个板块，独立于整个文件 结束创建板块 作用域 结束板块的创建，示意内容全部写完 creatd 作用域 --- endcd 作用域 --- 包裹体 作用域 暂定的功能，实际功效待定 包裹体尾 作用域 暂定的功能，实际功效待定 block 作用域 --- endblock 作用域 ---"},"title":"特殊函数"},"/ja/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E7%BC%A9%E8%BF%9B/":{"data":{"":"DCC借助缩进理解语义\n对于纯DCC代码，不会存在缩进，缩进只在嵌套中存在（见下一节）\n下面是存DCC代码示例：\n打开剧情\r如果 （转为文本 （输入））=10\r输出 \"ciallo\"\r如果结束\r展示剧情 10"},"title":"缩进"},"/ja/docs/dcc-script/2.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/":{"data":{"":"DCC拥有一些高级语法，这些语法会使得DCC拥有更强的互联能力，变得高度可扩展"},"title":"高级语法"},"/ja/moments/":{"data":{"":"Note\n本ページはAI技術による翻訳を使用しています。内容は参考までにご覧ください。\n日常の些細な内容です。友達の迷惑にならないように、頻繁に朋友圈（Moments）に投稿するのは避けて、ここで共有することにしました。サイトのコメント機能はもう実装しましたので、ぜひコメントしてくださいね"},"title":"つぶやき"}}