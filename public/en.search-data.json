{"/en/about/":{"data":{"":"Note\nThis page uses AI technology for translation. The content is for reference only.\nThis is my personal website, built with Hextra. Thanks to the open-source authors for their contributions."},"title":"About"},"/en/blog/":{"data":{"":"Note\nThis page uses AI technology for translation. The content is for reference only.\nI usually transfer some articles from my CSDN and Jue Jin platforms, but there likely won’t be any blog posts exclusive to this website.\nBilibili: 小狄同学呀\nGithub: xiaoditx\nACfun: 小狄同学呀\nCSDN, Jue Jin: 小狄同学呀"},"title":"Xiao Di's Blog"},"/en/blog/2025-08-26_%E7%AE%97%E6%B3%95%E7%9C%9F%E9%A2%98gesp202503%E5%9B%9B%E7%BA%A7%E8%8D%92%E5%9C%B0%E5%BC%80%E5%9E%A6%E6%B4%9B%E8%B0%B7b4263/":{"data":{"1-problem-analysis#1. Problem Analysis":"The problem states that wasteland can only be reclaimed if all four adjacent cells (up, down, left, right) contain no debris. Thinking this way seems difficult, but changing perspective might be easier. Let’s assume the following $3×3$ wasteland:\n...\r.#.\r... Here, debris appears in the center. Since reclaimable wasteland must have no debris in adjacent cells, this one debris affects the wasteland above, below, left, and right. Let’s use ! to represent wasteland without debris but non-reclaimable:\n.!.\r!#!\r.!. That is, our way of determining if wasteland is non-reclaimable transforms into finding debris. What follows is the code content.","2-data-reading-and-preliminary-processing#2. Data Reading and Preliminary Processing":"","3-statistics-of-currently-reclaimable-number#3. Statistics of Currently Reclaimable Number":"Our idea here is: Since we can only remove one debris, let’s first calculate how many can be reclaimed without removal, then find the debris whose removal can free up the most land. Thus, we need to first count the current reclaimable number:\nint ans=0;//Initialize an ans variable to 0, used to store final output // The loop below reads the imap array, counting the number of \"0\"s for(int c=0;c\u003cn;c++){ for(int vc=0;vc\u003cm;vc++){ // Standard loop traversal if(imap[vc][c]==0){//Current cell is 0 ans++;//ans records reclaimable cells, 0 means reclaimable, record +1 } } } Obviously, the current state is easy to judge. If it’s 0, it means reclaimable. This is the value we quantified earlier. So whenever we find a 0, increment the ans variable. After one loop, the number of 0s in imap is stored in ans.","4-finding-the-optimal-solution#4. Finding the Optimal Solution":"Now we only need to find the optimal removal solution. The simplest method here is to enumerate object. But my classmate seemingly turned the recorded positions into . one by one and analyzed the reclaimable count, which is somewhat inefficient (maybe I misunderstood him? Anyway, this method is slow). Actually, we can just read according to the offsets.\nWhen a debris is removed, according to the definition, the values of the surrounding cells should decrease by 1, and its own position becomes positive and then decreases by 1. Thus, we know that only if its own cell is -1, removal makes it reclaimable; only if its surrounding cells are 1, removal makes them reclaimable. Thus, we get the following code:\nint area,best=0;//Two variables to calculate reclaimable wasteland after debris removal for(int c=0;c\u003crecord_c;c++){ area=0;//area is just temporary, initialize to 0 each loop // Actually, writing 'int area;' here might be better for(int vc=0;vc\u003c4;vc++){//Four offsets int tx=px[vc]+object[c][0],ty=py[vc]+object[c][1];//Calculate XY if((tx\u003e=0) //Boundary check, same as before \u0026\u0026 (tx\u003cm) \u0026\u0026 (ty\u003e=0) \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]==1){//If it's 1, it means only affected by current debris, removal makes it reclaimable area++;//Reclaimable wasteland count +1 } } } if(imap[object[c][0]][object[c][1]]==-1){//Check if this debris is within the influence range of other debris area++;//If not, add one more } if(best\u003carea)best=area; if(best==5)break;//Maximum value is five (itself + four offsets), break directly to save time } Using a “打擂台” (competition) method to select the optimal solution. Since itself plus offsets amount to at most five points, when best is 5, we can break, as no solution can be better. This saves time. In competitions, even if not done, it might AC, but a simple optimization of a few lines is still necessary. After all, C++’s concept is efficiency first.","5-output#5. Output":"Since the optimal solution only considers -1 and 1, these reclaimable wasteland are additional compared to the state before removal. Simply adding ans and best gives the final result.\nans+=best;//ans plus the space freed up by removing debris std::cout\u003c\u003cans;//Output answer","analysis#Analysis":"","before-we-start#Before We Start":"Note\nThis page uses AI technology for translation. The content is for reference only.\nBefore We StartA classmate took the GESP exam and came back saying he got TLE (Time Limit Exceeded) on one problem. He wrote the problem down for me. I had some ideas after reading it then and tried writing it in Easy Language, but it got messier and I gave up. This week, being a bit bored in class and having nothing better to do, I picked this problem up again. I tried it at home, made some changes, and AC’d (Accepted) smoothly.\nThe original problem goes like this:\nXiao Yang has a large piece of wasteland, which can be represented as an n by m grid.\rXiao Yang wants to reclaim this wasteland, but some positions in the wasteland contain debris. For a piece of wasteland without debris, it can be reclaimed if and only if all four adjacent cells (up, down, left, right) also contain no debris.\rXiao Yang can choose at most one position to clear its debris. After removal, that position becomes wasteland. Xiao Yang wants to know, under the condition of clearing at most one debris, the maximum number of wasteland pieces that can be reclaimed. For input and output details, just check Luogu directly. I won’t paste everything here: Luogu B4263","postscript#Postscript":"I can’t help but share this original handwritten code draft. Although there are some minor flaws, it’s overall complete. Through solving this problem, I realized there is an excellent way to approach problems. When your code runs but doesn’t work as desired, try thinking about how to describe your algorithm in natural language. This way, compared to staring at code and pulling hair, it’s easier to find flaws in thinking. Those working on algorithms can try this.\nI’m a bit sleepy, my brain isn’t working well.可能 (Maybe) I wrote some inexplicable things迷迷糊糊 (drowsily). Going to sleep now, will modify after waking up.","preparing-the-map#Preparing the \u0026ldquo;Map\u0026rdquo;":"To solve the problem, we must first receive the data given by the problem. If we can’t even receive the data well, how can we analyze it? So, we start by writing code to receive the first two data points and prepare for what’s to come:\n#include #include int main(){ int m,n,record_c=0;//Length, width, and debris count recording variable char tmp;//Actually wanted to use string int px[4]={0,0,1,-1},py[4]={1,-1,0,0};//Offset for non-reclaimable areas caused by debris std::cin\u003e\u003en\u003e\u003em;//Read length and width (read reversed due to design reasons) int imap[m][n];//Create map array (2D) int object[m*n][2];//Debris coordinate recording array memset(imap,0,sizeof(imap));//Initialize map to 0 (default no debris, reclaimable) } Two headers are used here, iostream and cstring, one is almost essential, the other is for initializing the array.\nSome might say: Hey? Where did using namespace std go?\nActually, as long as you diligently add std::, you can omit this line. There are benefits to doing this, although it might not be easily apparent in algorithm competitions. But I’m more application-oriented (after all, I started with Easy Language), so I always pay attention to the habit of using using sparingly. You can search for “namespace pollution” to learn more.\nInteger variables m, n, record_c are defined to: receive input n, receive input m, store debris count (due to a flaw, m and n were used reversed, found it hard to change, ended up having to use m for n); a char variable tmp, for receiving the . and # input later.\npx and py in the code are actually “offset arrays”. In practice, take a number n, for a point $A$, add its X coordinate + px[n], its Y coordinate + py[n], you can get an offset point. The offsets in this code correspond to right, left, down, up.\nAfter defining these variables, we can start reading. Read m and n, these two numbers tell us the size of the entire land, helping us define a just right array as our “map” (I personally prefer things to be precisely sized, even with potential risks, but given my extensive experience with EPL, this approach seems quite reasonable).\nint imap[m][n] creates a 2D array, imap means map (originally wrote map, but classmate said it seems to be a reserved word, changed to imap). This allows us to directly manipulate points using X and Y.\nWhat is object? This is used to store the position information of debris. Considering there might be much debris, felt it better to define it as $m×n$. It’s also a 2D array, but like a struct array (actually, each storage is object[n][0] for X, object[n][1] for Y. Could have written it as a struct, but I’m lazy, and I like arrays, hehe).\nLast step, initialize the imap array to 0. Why 0? Please move to the next section.","quantifying-information-for-each-position#Quantifying Information for Each Position":"For a cell, it can be wasteland, debris, wasteland affected by debris, or even debris within the influence range of other debris. Note: A wasteland cell can be affected by two or more debris pieces.\nNote the following example:\n.....\r.#.#.\r..... In this example, the . between the two #s, even if debris on one side is removed, is still within the influence of the other debris, still cannot be reclaimed. So we consider this removal invalid for this single point.\nHow should we record how many debris pieces influence this point? We have a quantification strategy: use 0 for reclaimable, 1 for influence from one debris, 2 for two, up to 4.\nSimilarly, for the cell placing the debris, if removed, this cell might also become reclaimable or not, we also need to record it. Here we use -1 for debris, -2 for debris within the influence range of one other debris, and so on (this setting is for later recording convenience, we’ll talk about it later).","the-code#The Code":"Although I managed to write it, I’m not professionally trained in algorithms, so I don’t really know about time complexity or space complexity, nor do I know what the algorithm I used is called. I only know I AC’d. Each test case大抵 (probably) passed in about 7-25ms (as shown below).\nBelow is my code. This is the version with comments, but it might still confuse you with some of my inexplicable writing styles in certain places. If you can’t understand it, you can just read the analysis, which has an almost line-by-line interpretation:\n#include #include int main(){ int m,n,record_c=0;//Length, width, and debris count recording variable char tmp;//Actually wanted to use string ... int px[4]={0,0,1,-1},py[4]={1,-1,0,0};//Offset for non-reclaimable areas caused by debris std::cin\u003e\u003en\u003e\u003em;//Read length and width (Due to design reasons,I cna't but read them reversed) int imap[m][n];//Create map array (2D) int object[m*n][2];//Debris coordinate recording array memset(imap,0,sizeof(imap));//Initialize map to 0 (default no debris, reclaimable) for(int c=0;c\u003cn;c++){//Loop to read content for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;//Temporarily read into tmp if(tmp=='#'){//Check if it's '#' (debris) imap[vc][c]=-1-imap[vc][c];//If debris, record with negative number and superimpose object[record_c][0]=vc;//Record debris position to reduce later workload, save time object[record_c][1]=c; record_c++;//Increment the recording variable by 1 for(int dev_c=0;dev_c\u003c4;dev_c++){//Calculate offset coordinates four times and check int tx=px[dev_c]+vc,ty=py[dev_c]+c;//Offset X, Y /* Boundary check to prevent out-of-bounds when operating array Actually, if you think 'if' seriously affects efficiency, consider customized boundary checks, handle borders first then interior. This would be more efficient but also means you need to write more code. */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) //These two lines check X \u0026\u0026 (ty\u003e=0) //Next two lines check Y \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){//Check \"is it debris?\" imap[tx][ty]++;// \u003e-1 means not debris, record impact by ++ }else{// \u003c=-1 case imap[tx][ty]--; } } } } } } // Reading finished. Feel the power of machine indentation! // (Actually, if it's uncomfortable, you could use goto to fix it, but not recommended) // Code used for debugging, kept in comments // for(int c=0;c","writing-the-map#Writing the Map":"for(int c=0;c\u003cn;c++){//Loop to read content for(int vc=0;vc\u003cm;vc++){ std::cin\u003e\u003etmp;//Temporarily read into tmp if(tmp=='#'){//Check if it's '#' (debris) imap[vc][c]=-1-imap[vc][c];//If debris, record with negative number and superimpose object[record_c][0]=vc;//Record debris position to reduce later workload, save time object[record_c][1]=c; record_c++;//Increment the recording variable by 1 for(int dev_c=0;dev_c\u003c4;dev_c++){//Calculate offset coordinates four times and check int tx=px[dev_c]+vc,ty=py[dev_c]+c;//Offset X, Y /* Boundary check to prevent out-of-bounds when operating array Actually, if you think 'if' seriously affects efficiency, consider customized boundary checks, handle borders first then interior. This would be more efficient but also means you need to write more code. */ if((tx\u003e=0) \u0026\u0026 (tx\u003cm) //These two lines check X \u0026\u0026 (ty\u003e=0) //Next two lines check Y \u0026\u0026 (ty\u003cn)){ if(imap[tx][ty]\u003e-1){//Check \"is it debris?\" imap[tx][ty]++;// \u003e-1 means not debris, record impact by ++ }else{// \u003c=-1 case imap[tx][ty]--; } } } } } } (Please don’t mind my strange variable names like c, dev_c, I just wanted to write statements like c++)\nWe use a simple loop to read character by character. Since we initialized the map to reclaimable, reading . can probably be directly discarded. Only # is important to us. We record it into imap and object.\nThe operation to record into imap is: -1 - current cell content. If it was originally 0, now it’s -1; originally 1, now it’s -2. You can look back at the Quantifying Information for Each Position section to see if it matches.\nAfter writing, do four loops, corresponding to the four offsets of the px and py arrays, calculating the impact in turn : non-debris cells add one, debris cells subtract one.\nWhen calculating offsets, note that the result might exceed the array range. At this time, we shouldn’t operate on this non-existent coordinate, so add an if to check for out-of-bounds."},"title":"Algorithm Problem: GESP202503 Level 4 — Wasteland Reclamation (Luogu B4263)"},"/en/blog/2025-08-26_vscode%E6%8F%92%E4%BB%B6%E6%8A%A5%E9%94%99g++%E5%8D%B4%E5%AE%8C%E7%BE%8E%E7%BC%96%E8%AF%91api%E8%B0%83%E7%94%A8%E9%94%99%E5%9B%A0%E5%88%86%E6%9E%90/":{"data":{"":"Note\nThis page uses AI technology for translation. The content is for reference only.\nA while ago, I wrote a small application and wanted to add a read/write configuration function. Having only learned C++ for a few days, I searched online for a long time and found two Windows APIs: GetPrivateProfileString for reading INI files and WritePrivateProfileString for writing them. Following online tutorials, I wrote these three lines:\nLPTSTR lpPath = new char[MAX_PATH]; strcpy(lpPath, \".\\\\config.ini\"); ::WritePrivateProfileString(\"config\", \"t\", \"120\", lpPath); Right after writing, the plugin in VScode instantly flagged it in red and gave the following error: But I was sure I followed the tutorial exactly. So where was the problem?\nI tried to compile it, and the result was surprising: g++ compiled successfully without any errors and created config.ini in the current directory, writing the specified content.\nThis was strange. Time to check the official documentation.\nI went to MSDN and searched for WritePrivateProfileString but couldn’t find it. I only found WritePrivateProfileStringA and WritePrivateProfileStringW (both have an extra letter at the end).\nNo choice, I clicked on one to check. I chose WritePrivateProfileStringA. Hmm, the parameter types seemed wrong. The tutorial used LPTSTR, but here it specified LPCSTR.\nScrolling down, below the Example section, I saw a note:\nThe winbase.h header defines WritePrivateProfileString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that is not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for Function Prototypes.\nThis means WritePrivateProfileString is not the API’s real name; it’s selected conditionally.\nBack in VScode, I held Ctrl and clicked on WritePrivateProfileString to see the content in Windows.h:\n#ifdef UNICODE #define WritePrivateProfileString WritePrivateProfileStringW #else #define WritePrivateProfileString WritePrivateProfileStringA #endif VScode showed that the upper condition was active, proving that the UNICODE macro was defined in VScode’s environment.\nMystery solved! Because VScode had the UNICODE macro defined while g++ did not, the plugin checked the code against WritePrivateProfileStringW, expecting Unicode and a path stored in wchar_t (wide characters). When g++ compiled, it used WritePrivateProfileStringA, expecting ANSI and a path stored in char (regular characters). Thus, our code using char worked fine under g++ but failed the VScode plugin’s check.\nTherefore, our code was correct, but the plugin flagged it as an error due to the different environment. The solution is to explicitly specify that we want to use the WritePrivateProfileStringA function:\nchar* lpPath = new char[MAX_PATH]; strcpy(lpPath, \".\\\\config.ini\"); ::WritePrivateProfileStringA(\"LiMing\", \"Sex\", \"Man\", lpPath); delete[] lpPath; And that’s it. The annoying warning finally disappeared.\nAppendix: Specific meanings of LPxxxSTR data types\nCore Base Types:\nCHAR: Represents an ANSI (8-bit) character (char). WCHAR: Represents a wide character (Unicode, typically 16-bit UTF-16) (wchar_t). TCHAR: An adaptive character type. Compiles to CHAR or WCHAR based on project settings (whether the _UNICODE macro is defined). Used for writing code that can be compiled for either ANSI or Unicode. String Pointer Types:\nLPSTR: Long Pointer to STRing. Points to a null-terminated ANSI string (CHAR*). typedef CHAR* LPSTR; LPWSTR: Long Pointer to Wide STRing. Points to a null-terminated Unicode (UTF-16) string (WCHAR*). typedef WCHAR* LPWSTR; LPTSTR: Long Pointer to TCHAR STRing. Points to a null-terminated adaptive character (TCHAR*) string. Depending on the _UNICODE macro definition, it compiles to either LPSTR (ANSI) or LPWSTR (Unicode). typedef TCHAR* LPTSTR; Constant String Pointer Types:\nLPCSTR: Long Pointer to Constant STRing. Points to a null-terminated constant ANSI string (const CHAR*). typedef const CHAR* LPCSTR; LPCWSTR: Long Pointer to Constant Wide STRing. Points to a null-terminated constant Unicode (UTF-16) string (const WCHAR*). typedef const WCHAR* LPCWSTR; LPCTSTR: Long Pointer to Constant TCHAR STRing. Points to a null-terminated constant adaptive character (const TCHAR*) string. Depending on the _UNICODE macro definition, it compiles to either LPCSTR (ANSI) or LPCWSTR (Unicode). typedef const TCHAR* LPCTSTR; Key Differences Summary Table:\nType Character Width Const-ness Base Type Equiv (ANSI Build) Base Type Equiv (Unicode Build) Description LPSTR ANSI (8-bit) Non-const char* char* Pointer to ANSI string LPCSTR ANSI (8-bit) const const char* const char* Pointer to read-only ANSI string LPWSTR Unicode (16-bit) Non-const wchar_t* wchar_t* Pointer to Unicode (UTF-16) string LPCWSTR Unicode (16-bit) const const wchar_t* const wchar_t* Pointer to read-only Unicode (UTF-16) string LPTSTR Adaptive Non-const char* (LPSTR) wchar_t* (LPWSTR) Pointer to adaptive string (TCHAR*) LPCTSTR Adaptive const const char* (LPCSTR) const wchar_t* (LPCWSTR) Pointer to read-only adaptive string (const TCHAR*) Important Notes:\nLP Prefix: “Long Pointer” is a historical artifact. In modern 32/64-bit systems, all pointers are “long.” You can simply think of LP as “Pointer to.” C Suffix: Means const. The content pointed to is read-only; the string cannot be modified through this pointer. T Infix: Means the type is TCHAR, which adapts based on the project’s character set settings. This is for writing code that supports both ANSI and Unicode builds. W Suffix: Means “Wide,” i.e., Unicode (UTF-16). STR Suffix: Means “String” (a NULL-terminated character array). Modern Windows Development Practice: It is highly recommended to always use Unicode builds (set “Character Set” to “Use Unicode Character Set” in Visual Studio project properties). This defines the _UNICODE macro. In Unicode builds: TCHAR = WCHAR LPTSTR = LPWSTR LPCTSTR = LPCWSTR Directly using LPCWSTR/LPWSTR or their aliases like std::wstring (in C++) is often clearer and avoids the ambiguity of the TCHAR family, unless you explicitly need to maintain legacy codebases that support both ANSI/Unicode. ANSI (LPSTR/LPCSTR) API functions often internally convert the string to Unicode and call the corresponding Unicode version, incurring performance overhead and potential character set conversion issues. Prefer using the explicit Unicode (W) version APIs. Compatibility: The TCHAR family exists mainly for compatibility with old Windows 9x systems (which primarily used ANSI) and modern NT systems (native Unicode). Modern development (Windows 2000 and later) should prefer Unicode. Simple Mnemonic:\nSee W -\u003e Unicode. See C -\u003e const (cannot modify string content). See T -\u003e Adaptive, changes to ANSI or Unicode based on project settings. No W and no T -\u003e ANSI. No C -\u003e String content can be modified (non-constant). Has C -\u003e String content is read-only (constant). Usage Advice:\nNew projects: Always enable Unicode build (_UNICODE defined). Prefer using LPCWSTR (input parameters) and LPWSTR (output parameters), or in C++, use const wchar_t* and std::wstring. Maintaining old projects/needing ANSI compatibility: Use LPCTSTR (input) and LPTSTR (output) or the corresponding TCHAR base types, and ensure correct handling of the _UNICODE macro definition. When interacting with Windows API, note that API functions usually have A (ANSI) and W (Wide/Unicode) versions (e.g., MessageBoxA and MessageBoxW). Using the generic macro MessageBox automatically selects the correct version based on _UNICODE. The passed string pointer types must also match (LPCSTR for A version, LPCWSTR for W version, LPCTSTR for the generic macro)."},"title":"VScode Plugin Reports Error, but g++ Compiles Perfectly? Analyzing the Cause of API Call Errors"},"/en/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/":{"data":{"":"学习C/C++时，常常会遇到一个很烦人的东西：指针，说实话，指针在很多人入门C/C++时都是属于噩梦级的，它牵涉了庞大的知识体系，容易出现各种未定义行为，因此被称为C/C++中的最难知识点，那么这篇文章，就让我们好好聊一聊，这个BOSS级的指针。","一汇编层面的指针理解#一.汇编层面的指针理解":"我们都知道，程序运行是依赖CPU的，CPU将可执行程序的指令一步步地执行，呈现出我们看到的各种运行效果，但，在程序的运行中，变量是必要的，因此CPU中设计了一些暂存数据的元件，这些元件就叫做寄存器\n寄存器对于汇编程序，可以理解为变量，比如这样：\nMOV EAX,0x0d00 ; 效果近似于\"EAX=0x0d00\" MOV EBX,EAX ; 类似于\"EBX=EAX\" 但是寄存器的问题很明显，为了足够快，寄存器往往造起来非常的昂贵，再加上各种限制，导致寄存器的数目非常的少，截止到本文书写的2025年9月7日，最新的x86_64架构CPU也只是提供了16个64位通用寄存器（硬算的话倒是还有800个不是通用寄存器的寄存器，不过不是不可见就是会影响CPU的行为），算下来也就$16*(64/8)=128$字节的数据，"},"title":"C/C++指针种类+常见错误+组合技巧，挑战写出全网最全指针文章"},"/en/docs/":{"data":{"":"Note\nThis page uses AI technology for translation. The content is for reference only.\nHere you can find all documents I have participated in writing, including project descriptions, syntax standards, document translations, and more. Click on the options below to navigate.\nBeepMusic Developer Support\rDCC Syntax and Usage Guide\rResearch Study Report"},"title":"Document Collection"},"/en/docs/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E4%B8%8E%E9%80%89%E7%94%A8/":{"data":{"":"Note\nThis page uses AI technology for translation. The content is for reference only.\nWritten by: xiaoditx\nProofread by: Ma Heyang","0-preface#0. Preface":"Computer technology is inseparable from various programming languages. Therefore, the development of programming languages can reflect the development of computer technology from a side perspective. Each evolution of programming languages witnesses the demands of the era for computer technology. It can be said that the history of programming language development is the history of computer technology development.\nThis research study report will start with the history of “programming languages,” analyze the characteristics of different languages in various eras, attempt to glimpse the development process of computer technology, and also aim to analyze how to choose a programming language that suits oneself.\nThe basic structure of this article is as follows:\nThe Prehistoric Prototypes of Programming Languages Machine Language and Assembly Language The Evolution Path of High-Level Languages The Multi-Dimensional Development of Modern Programming Languages The Development Laws of Programming Languages and Selection Suggestions","1-concise-syntax#1. Concise Syntax":"In 1989, Guido van Rossum designed Python, pushing code readability to the extreme. By using syntax extremely close to natural language, Python’s learning difficulty greatly reduced, attracting a large number of programming beginners.\nBelow is a sample Python program to output Hello World:\nprint(\"Hello World\") With just one line, Python can complete the output. This reflects one of its major characteristics: simplicity. Python simplified some verbose content in languages before it, allowing developers to focus on the real algorithm rather than function implementation.","1-easy-language#1. Easy Language":"Programming languages kept developing, extending into China. In 2000, a Chinese programming language emerged, using form programming, also interpreted, enabling software development with simple Chinese. This is Easy Language:\n.如果（用户输入==\"你好\"）\r输出框.显示（\"你好，世界！\"）\r.否则\r输出框.显示（\"无法识别\"） Unlike other programming languages, Easy Language’s first lesson is directly about window development. Short software development cycles and low difficulty of learning programming in Chinese instantly attracted many people.\nBelow is a screenshot of Easy Language’s code writing interface:\nAdvantages of Easy Language:\nLowers the English barrier Simplifies development, accelerates development efficiency Powerful official components, covering various aspects Disadvantages also exist:\nLimited to the Windows platform Lacks an open-source ecosystem Only supports 32-bit compilation, insufficient runtime efficiency","1-the-birth-of-programming-languages#1. The Birth of Programming Languages":"Humans are lazy, and have been since ancient times. During the Eastern Han Dynasty, a device called the Jacquard loom was widely used. This device can be traced back to the Shang Dynasty. It was almost out of place in its time because of its function:\nThe pattern-based Jacquard loom appeared in the Eastern Han Dynasty, also known as the Hua Lou (flower tower). It used a thread-based pattern chain to store the jacquard program, and then used harness cords to lift the warp threads to open the shed. The pattern chain was a set of programs stored on the Jacquard loom for preserving pattern information. It was woven from lingzi threads (representing warp threads) and erzi threads (representing weft threads) according to the pattern requirements.\nUsing an objective object to record a program to save effort—the Jacquard loom, during the Eastern Han Dynasty, quietly planted a seed ahead of its time. As the Silk Road opened up, the Jacquard loom flowed into Europe and, under the hands of generations of workers, physicists, and mathematicians, gradually took root and sprouted, growing into a towering tree named “Computer Technology”.","1-the-birth-of-the-c-language#1. The Birth of the C Language":"In 1972, Dennis MacAlistair Ritchie of Bell Labs created the C language while developing the UNIX operating system. This is a language closer to natural language compared to assembly, with stronger readability.\nBelow is a classic code snippet to output Hello World, which is almost the common first lesson for everyone learning C language development.\n#include int main() { printf(\"Hello, World!\\n\"); return 0; } These five lines accomplish one task: outputting a string of text to the console.\nSome might think this is a simple matter, believing that C language is just this and has no great significance. That would be a big mistake. Let’s take a look at the implementation of the same functionality in assembly language:\ndata segment ;data segment string db 'Hello,World!$' data ends code segment ;code segment assume cs:code,ds:data start: mov ax,data ;get segment base address mov ds,ax ;load segment base address into register mov dx,offset string mov ah,9 int 21h mov ah,4ch int 21h code ends end start To write such a piece of assembly code, one needs to know at least: the concept of registers, what a code segment is, what a data segment is, what a base address is, and the many syntaxes of assembly. Most assembly language textbooks take over fifty pages and still require external software assistance to see any effect at the software level. C language is clearly much better.\nFor those few lines of C language, most tutorials hardly exceed a thousand words: what is a header file, what is the main function—these concepts are very simple and can be understood with a little explanation.\nTherefore, the advantages of the C language are the following:\nStarts from the software level rather than the hardware level, reducing learning costs Natively supports a large number of operations, simplifies writing, and facilitates reading Of course, there are also disadvantages. When we use the gcc -S -masm=intel m.c -o m.s command to compile the program, we can see the compiler translates the C code into something like this:\nA total of thirty lines. Now, let’s write the equivalent assembly code in the usual way (the output has an extra word but it doesn’t affect the point):\nThe pure assembly version uses only fifteen lines. That is, the compiler wrote twice as much just to achieve the same effect. In fact, this difference becomes more pronounced in the later stages of compilation. Usually, GCC compiled programs need to link some library files during the linking stage, and the final product can sometimes be dozens of times larger than pure assembly.\nThis is the disadvantage of C language: it exchanges “less writing” in the process for “more writing” in the result. The reason ultimately lies in templating. Taking the output here as an example, the content we want to output is text, and we use the printf function. But this function can also output integers, floating-point numbers, etc. To ensure universality, the compiler has to include code adapted to other data types in the compiled file, even though some features may not be used.\ntips: The author actually doesn’t have much fondness for C. Putting aside memory leak issues, procedural languages themselves aren’t that convenient. Sometimes when writing software in C++, one has to use C syntax—frankly, it’s quite troublesome (I heard the current GCC compiler is still written in C++, which is quite amusing).","10-postscript#10. Postscript":"This topic is something I have wanted to research for a long time. Being able to realize it through this research study naturally makes me extremely excited, hence I busied myself back and forth doing many things, although I certainly added some chaos.\nAs the document’s writer, I lack the team leader’s profound professional accomplishments and the persistence focused on a single research direction. I could only rely on my not-so-deep knowledge and self-proclaimed passable literary skills to barely write down these finally presented words. I am ultimately somewhat apprehensive, worried that the written content has flaws. If readers can find errors in the article, big or small, I sincerely hope you can submit them via Issues on GitHub.","11-reprint-afterthoughts#11. Reprint Afterthoughts":"Language itself is full of controversy; there is no absolute right or wrong, good or bad. Just like PHP is sarcastically called “the best language in the world” by many programmers, it is still widely used after all. Whatever the language, as long as it suits you, it’s a good language.\nA while ago, I saw a joke, a dialogue between C++ and Python. It is roughly recorded below.\nC++ asks Python “What’s your name?”, Python doesn’t answer. C++ thinks it wasn’t polite enough, so it starts introducing itself. But it gets stuck when saying its own name because a stack error occurs. It can only leave while reporting errors. After C++ goes far away, Python finally shouts: “Python!”\nThis joke aims to say C++ is hard to write, prone to errors and crashes, while Python is very slow—maybe C++ has already run hundreds of lines of code while Python is still at the entry point. What this joke does well is that it simultaneously illustrates the disadvantages of both C++ and Python, conveying the concept that there is no perfect language.","2-first-generation-programming-language--machine-language#2. First-Generation Programming Language — Machine Language":"The first “communication” between humans and machines relied on machine language. This is a “language” composed purely of 0s and 1s, which is defined as the first-generation computer language.\nThe world of zeros and ones is the most fundamental “essence” of computers. Therefore, it is sufficiently basic, sufficiently complex, and has relatively low writing efficiency. Below is a small snippet of machine language code for you to experience:\nBinary representation: 10001011 01000101 00000100 01011011 10001001 11000011 Hexadecimal representation: 8b 45 04 5b 89 c3 It’s evident that the mix of zeros and ones makes the code content difficult to discern. Therefore, it’s very difficult for humans to quickly recognize it relying on so-called muscle memory or similar things.\nIn fact, the long string above is not even sufficient to support a simple addition operation. If we accidentally write one character wrong now:\nIncorrect: 10001011 01000101 00000100 01011011 10001101 11000011 Correct: 10001011 01000101 00000100 01011011 10001001 11000011 Can anyone tell at a glance which one is wrong? Probably not. Machine language requires at least three lines to implement addition. Within just three lines, the difficulty of error correction is so high; imagine the difficulties when actually used for software development.\nThis leads to the advantages and drawbacks of machine language:\nAdvantages are as follows:\nClosest to the bottom layer, runs fast enough Machines can directly recognize and run it without auxiliary programs No redundant or useless content (program size is small) Disadvantages are as follows:\nHigh memorization difficulty Faces the bottom layer directly, high learning difficulty Strong dependence on the machine; one machine, one structure, difficult to port Only 0s and 1s, easy to make mistakes and difficult to correct errors This inevitably brings to mind Wang Shuang’s description in “Assembly Language”:\nWriting and reading machine code programs is not a simple task; one must remember all the abstract binary codes. The above is just a very simple small program, yet it exposes the obscurity and difficulty in error checking of machine code. If writing such a small program is already like this, what about a useful program that requires at least dozens of lines of machine code?","2-powerful-standard-library#2. Powerful Standard Library":"Comparing Python with C++, an indisputable fact is that C++’s int type variable can only store values between -2,147,483,648 and 2,147,483,647. Even the longest long long type variable can only represent values between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807. Python’s int variable, however, has no such limitations and can store data of any size without overflow.\nBringing the aforementioned differences into actual development, we can understand by comparing C++ and Python’s handling of high-precision calculations. There is a problem on the algorithm platform Luogu: find the sum of factorials from 1 to n. Let’s look at the Python solution:\nn=int(input()) ans=0 # Final answer storage rec=1 # Factorial accumulation variable for i in range(1,n+1): rec*=i ans+=rec print(ans) Done in just a few lines. It’s a very simple problem, right?\nBut why does Luogu mark its difficulty as relatively high? The C++ code below will make it clear:\n#include #include using namespace std; struct bigint { int len, nm[1000]; // Use struct to simulate big integer bigint() { // Parameterless initialization len = 0; // Initial length 0 memset(nm, 0, sizeof(nm)); // Initialize to 0 } bigint(int num) { // Initialize with int memset(nm, 0, sizeof(nm)); len = 0; do { nm[len++] = num % 10; num /= 10; } while (num); } int operator[](int idx) const { // Return value of corresponding digit return nm[idx]; } void process() { // Handle carry int carry = 0; for (int i = 0; i \u003c 1000; ++i) { nm[i] += carry; carry = nm[i] / 10; nm[i] %= 10; } zero_processing(); } void zero_processing() { // Reset length len = 0; for (int i = 999; i \u003e= 0; --i) { if (nm[i] != 0) { len = i + 1; break; } } if (len == 0) len = 1; // Handle all-zero case } void print() { // Output for (int i = len - 1; i \u003e= 0; --i) cout \u003c\u003c nm[i]; } }; bigint operator+(const bigint\u0026 a, const bigint\u0026 b) { bigint c; for (int i = 0; i \u003c max(a.len, b.len); ++i) c.nm[i] = a[i] + b[i]; c.process(); return c; } bigint operator*(const bigint\u0026 a, int b) { bigint c; for (int i = 0; i \u003c a.len; ++i) c.nm[i] = a[i] * b; c.process(); return c; } int main() { int n; cin \u003e\u003e n; bigint ans(0), tmp(1); for (int i = 1; i \u003c= n; ++i) { tmp = tmp * i; ans = ans + tmp; } ans.print(); return 0; } Writing this problem in C++ is exceptionally long. This is because the calculation result of this problem will be very long, and C++ requires simulation algorithms to prevent result overflow, whereas Python has a built-in simulation mechanism,no need for users to write it themselves.","2-the-new-birth-of-c#2. The New Birth of C++":"The C language is indeed powerful, but this does not mean people were already satisfied with C’s development efficiency. C language still had some unsatisfactory aspects: C is a procedural language, code reuse率 (rate) is insufficient. Due to its own design issues, dangerous type conversions and various errors are prone to occur, along with a high risk of memory leaks. During development, C’s error reporting mechanism is not perfect and only guarantees stable operation within ten thousand lines of code.\nTherefore, in 1983, C++ emerged. Danish professor Bjarne Stroustrup added concepts like classes to the C language, creating the so-called “object-oriented programming supported” C++. This language significantly reduced memory leak rates and provided support for large projects of million-line magnitude.\nThe emergence of C++ was undoubtedly a milestone. With its appearance, concepts like polymorphism, encapsulation, objects, inheritance, namespaces, virtual functions, templates quickly became popular, also influencing subsequent languages (like Java) to varying degrees, treating language abstraction capability as paramount.\nBelow are some feature demonstrations of C++:\nclass Person { public: virtual void SenRen_BanKa() = 0; }; class DiYongJie : public Person { public: std::string play = \"YuZu soft!\" void SenRen_BanKa() override { std::cout \u003c\u003c \"Ciallo!\" \u003c\u003c std::endl; } }; Although many concepts were added, C++ and C are still strongly related. C++ is basically compatible with C language code (although old header files certainly need to be replaced). The two languages are actually very similar:\n#include using namespace std; int main(){ cout\u003c\u003c\"Hello World\"; return 0; } This coexistence of retention and evolution led to the rapid success of C++, making large-scale software development possible. It is still widely used today in high-performance fields like game engines and operating systems.","2-wenyan-lang#2. Wenyan-lang":"After Easy Language, Chinese programming was popular for a while. In 2019, another language called Wenyan-lang emerged.\nAs the name suggests, Wenyan uses classical Chinese to write programs, making it almost an art form rather than a programming tool:\n吾有一數。曰三。名之曰「甲」。\r為是「甲」遍。\r吾有一言。曰「「問天地好在。」」。書之。\r云云。 The Wenyan programming language is an experimental language used to spread classical Chinese culture and computer culture. Like the Chicken language, ///, Glass language, Piet language, etc., it is a kind of semi-artwork. This marks the high development of programming languages, leading people to begin exploring branches with certain creativity and artistry.\ntips: Easy Language was the first programming language the author encountered. It is definitely a “beginner-friendly language” because it is so convenient. Graphical interface allows window design, so all tutorials start with windows. Because of this, I later found GUI creation in other languages extremely troublesome.","3-assembly-language-programmers-first-pursuit-of-natural-language#3. Assembly Language: Programmers\u0026rsquo; First Pursuit of Natural Language":"Since machine language is so difficult to write, what should be done? Programmers came up with a solution: since direct “chatting” with the machine is somewhat difficult, why not find a translator? Thus, Assembly Language was born.\nBaidu Baike defines assembly language as follows:\nAssembly Language is any kind of low-level language for electronic computers, microprocessors, microcontrollers, or other programmable devices, also known as a symbolic language.\nSimply put, assembly language is like a universal translator. This “translator” established a language. When you need to “talk” to any machine, just find this “translator,” speak the language it established, and it can interpret and convey the message to the machine using different expressions depending on the situation.\nFor example, Machine A stipulates that 0000 is an addition operation, while Machine B stipulates that 1010 is an addition operation. Now, assembly language stipulates that the addition operation is +. So when we write a program, we just need to write +. Assembly language will convey 0000 to Machine A and 1010 to Machine B.\nBecause of this varies from person to person translation of assembly language, it to some extent solves the problem of machine language’s strong dependence on specific machines. Simultaneously, through operations like changing 0000 to +, writing programs becomes more intuitive and easier to remember (Which is easier to remember and write: 1 0000 2 or 1+2? It’s quite obvious).\nTherefore, assembly language is sometimes called a mnemonic, meaning text that aids memory. Refer to the following definition:\nA mnemonic is a symbol that facilitates people’s memory and can describe the instruction function and instruction operands. Mnemonics are English words or their abbreviations that indicate the instruction function.\nThe introduction of assembly made memorization no longer tedious and difficult to understand. For example, there are commands like MOV, ADD, CALL, etc. With a slight foundation in English, one can understand them well and remember them faster than binary codes.\nConsidering the non-negligible differences between machines of different designs, assembly has also derived different versions, such as IBM PC Assembly, ARM Assembly, GNU ASM, MASM, NASM, etc., which will not be expanded upon here.\nHere is a quote from an article evaluating assembly language:\nThe emergence of assembly language liberated programmers from tedious binary programming, allowing them to focus more on the logic and functional implementation of programs, laying an important foundation for the development of computer software.\nIn summary, assembly language allows people to achieve a state of knowing the how but not the why. For learning computer technology, this is actually a good state most of the time because it allows one to break free from tedious underlying principles. When wanting to use a computer to solve a problem, one can directly think about what algorithm to use, rather than first looking at the underlying architecture of the machine.\ntips: The author really likes assembly language. It is close to the bottom layer and is the key to unlocking the door to the fundamentals of computer science. It is an extremely challenging language and the language where one can learn the most about software operation principles.","3-feature-comparison#3. Feature Comparison":"Feature C C++ Programming Paradigm Procedural Multi-paradigm Memory Management Manual Manual + Smart Pointers Standard Library Size Minimal Large Namespace Management Lacking Comprehensive Header Inclusion Mechanism Primitive Improved Application Scenarios Embedded Systems Large Commercial Software tips: Because C++ retains a lot of C-style operations while adding an excellent and convenient standard library, C++ is sometimes jokingly called “C with STL” in the algorithm community.","4-the-dawn-of-high-level-languages-the-cc-revolution#4. The Dawn of High-Level Languages: The C/C++ Revolution":"","5-java-realizing-the-cross-platform-dream#5. Java: Realizing the Cross-Platform Dream":"Some time after the birth of high-level languages, the internet boomed. But at that time, it relied solely on HTML, a markup language, to display static pages. So accessing the internet was essentially browsing online Word documents, which greatly limited the potential of the internet. People quickly noticed this and were searching for ways to make websites dynamic. However, early languages had very specific device requirements; computer software absolutely could not run on hardware like microcontrollers. So the direction of exploration became having a technology to develop software with cross-platform dissemination capabilities.\nAgainst this background, Sun Microsystems introduced the Java language, accompanied by the revolutionary concept of “Write Once, Run Anywhere.” It succeeded rapidly upon its release. In January 1996, Sun released the first Java Development Kit (JDK 1.0), marking Java as an independent development tool. Just eight months later, about 83,000 web pages had applied Java technology.\nBelow is Java code:\npublic class Main { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } Actually, Java still retains many ideas from C/C++ because it itself evolved from the Oak language developed by Sun Microsystems. And the Oak language was a simplified C++ created by Sun for developing microcontroller programs.\nSince Java was designed initially for developing consumer electronic product software, many optimizations were made for “reliability.” Therefore, Java has the following advantages:\nEvolved from C/C++, easy to learn, syntax more concise Removed the concept of pointers; hardware is almost completely a black box for developers, ensuring software security while reducing learning costs High portability These advantages made Java dominate enterprise-level application development and become one of the foundational languages for Android development. However, the performance cost brought about for the sake of portability also makes it unsuitable for high-performance computing scenarios.\ntips: Java is notorious for being verbose, a point often teased by many programmers. Frankly, my early impression of Java was “pulling the classes out of C++ separately.”","6-python-the-victory-of-the-philosophy-of-simplicity#6. Python: The Victory of the Philosophy of Simplicity":"","7-exploration-in-the-chinese-internet#7. Exploration in the Chinese Internet":"","8-overall-summary-development-laws#8. Overall Summary: Development Laws":"Based on the examples above, we can see the characteristics of language evolution:\nIncrease in Abstraction Level Programming languages continuously develop towards “abstraction,” gradually increasing code reuse rates, thereby improving development efficiency. Evolution Path: Machine Instructions → Symbolization → Structuring → Object-Oriented → Functional Programming\nBalanced Evolution of Efficiency Developers are more willing to discuss the trade-off between development and usage efficiency. Evolution Path: Execution Efficiency Priority → Development Efficiency Priority → Dynamic Balance Between the Two\nDomain Specialization Specialized languages emerged for various domains,typical examples include .rc files in Windows systems and the specialized language for writing installers in Inno Setup. Evolution Path: General-Purpose Languages → Domain-Specific Languages (DSL)\nSyntax Simplification Evolution Path: Redundant Syntax → Concise Expression → Approximation of Natural Language (Exploration direction for fifth-generation programming languages)","9-selection-suggestions#9. Selection Suggestions":"Our research concludes that programming languages each have their own strengths. Language selection should be reasonably matched according to one’s own needs, considering development efficiency and application scenarios. Below are some recommended pairing schemes.\nLow-Level Development\nRecommendation: C / Rust / A little Assembly Scenarios: Operating Systems, Embedded Systems Advantages: Close to the hardware, can be compiled into various forms Rapid Development\nRecommendation: Python / JavaScript / A little shell / Easy Language Scenarios: Web Applications, Data Analysis Advantages: Ready-made functions, efficient development Cross-Platform Requirements\nRecommendation: Java / Kotlin / QT framework Scenarios: Enterprise-Level Applications, Mobile Development Advantages: Cross-platform, easy to port Academic Research\nRecommendation: Python / Julia Scenarios: Scientific Computing, Machine Learning Advantages: Simplified code, prevents writing code from becoming a burden Interest-Driven\nTry: Wenyan-lang / Easy Language Value: Understand programming essence, cultivate computational thinking When selecting a programming language, the following are key considerations:\nProject Performance Requirements: Absolutely avoid high-level languages for high-performance needs;try to avoid low-level languages for specialized calculations. Current Team Tech Stack: Decide based on team members’ skills. Community Ecosystem Maturity: The community is the pillar of development. The Rust community is a typical case; a good, mature community can always help every developer everywhere. Personal Learning Curve: Choose based on personal learning plans.","declaration#Declaration":"In the “Machine Language” section, the machine language code was generated from assembly code via Online x86 and x64 Intel Instruction Assembler. It is uncertain if there are conversion issues, so it holds no reference value and is only used to辅助理解 (aid understanding) the inconvenience of machine language.","pythons-advantages#Python\u0026rsquo;s Advantages":"By definition, Python is an interpreted language, possessing the same flexibility and high portability as Java. As a scripting language, Python is more adept at automated tasks like data calculations, hence it is widely used in large language models and web crawlers.\nPython’s advantages are as follows:\nPowerful standard library, simple operations Open-source community continuously maintained Abundant third-party libraries Interpreted language, saves debugging time tips: In recent years, some people have criticized Python as useless, claiming interpreted languages have extremely low runtime efficiency. I can only say each has its own advantages. For example, Python can teach the TK window library in the first compulsory IT course, while C++ requires groping around in MSDN for documentation (personal experience).","references#References":"川合秀实 (Kawai Hidekazu) 《三十天自制操作系统》 (30-Day DIY Operating System) | People’s Posts and Telecommunications Press A Brief History of Programming Language Development The Chronicle of Programming Languages That Programmers Must Know 王爽 (Wang Shuang) 《汇编语言》 (Assembly Language) | Tsinghua University Press Baidu Baike - Assembly Language Baidu Baike - Mnemonic Deep Learning - Ian Goodfellow, Yoshua Bengio, Aaron Courville 黑马程序员 (Heima Programmers) 《网页设计与制作项目教程》（第2版） (Web Design and Production Project Tutorial, 2nd Edition) | People’s Posts and Telecommunications Press From Machine to Intelligence: The Past, Present, and Future of Assembly Language Luogu - P1009 - Sum of Factorials Java 张毅刚 (Zhang Yigang)、赵光权 (Zhao Guangquan)、刘旺 (Liu Wang) 《单片机原理及应用》第三版 (Principles and Applications of Microcontrollers, 3rd Edition) | Higher Education Press 郭卫斌 (Guo Weibin)、罗勇军 (Luo Yongjun) 《算法竞赛入门到进阶》 (From Beginner to Advanced in Algorithm Competitions) | Tsinghua University Press MSDN - Microsoft Learn C++, C and Assembler\\C++ Syntax Reference C++ reference 汪楚奇 (Wang Chuqi) 《深入浅出程序设计竞赛》 (Head First Programming Competitions) | Higher Education Press 郁红英 (Yu Hongying)、王磊 (Wang Lei)、武磊 (Wu Lei)、李春强 (Li Chunqiang) 《计算机操作系统》（第三版） (Computer Operating Systems, 3rd Edition) | Tsinghua University Press"},"title":"Comprehensive Research Study Report"},"/en/docs/beepmusic/":{"data":{"beepmusic#BeepMusic":"BeepMusicV 2.1.2.0 终端版本（其实只有终端版，嘻嘻）\n跳转到开发者帮助","功能介绍#功能介绍":"一款可以将简谱转换为频率和时长的软件，转换结果可供Beep函数使用，使蜂鸣器实现奏乐效果","开发者帮助#开发者帮助":"HELPS文件夹下是项目帮助，有些教程文档（我怕我自己忘了怎么写了放进去的），其中Introduce.md会介绍项目的整体结构、各个文件的功能","播放帮助#播放帮助":"对于连续播放短声音困难的硬件，建议使用耳机将蜂鸣器转为电脑内音，经过测试，通常的设备在播放「千本桜」（t=180）时，即使使用耳机，仍然会有声音是无法放出的，因此可以采用t=45;参数播放，录制结果后对结果加速4.2倍左右","示例#示例":"《call of silence》\n参考Call of Silence简谱，基本遵循原谱内容，在后半部分和前面的细节部分做了一定的调整\n下面是标准的速度版本：\nt=72; -6_ 3_ 3. 3_ -7. -6__ 1-. -6_ 3_ 3. 3_ 7. +1__ 3-. 6_ +3_ +3. +3_ 7. +1__ 5-. 5_ 3__ 5-. +2_ +1__ +2.. +1__. 6-. 0--- 3_ 2_ 2_ 1_ 1_ 5_ 1 -7_ 1-. 3_ 2_ 2_ 1_ 1_ 3_ 2 3_ 1-. 3_ 2_ 2_ 1_ 1_ 5_ 5_ 5_ -7_ 1-. -6_ 1_ 2 2_ 1_ 2_ 3_ 2_ 2 1. 0 0_ +1_ 7_ 3__ 6. 0_ +1_. 7_ 3__ 1. 0_ +1_ 7_ 3__ 6 6__ 7 +2__ +1. 0_ +1_ 7 3__ 6_. 0_ +1_ 7_ 3__ 1_- 0_ +1_ 7_ +1__ +2 +3_ +3_. +1_ 7- 对于外放，蜂鸣器可能会吞掉一些声音，t=45;可能更合适","简谱表示规则#简谱表示规则":"基本音符：1(do), 2(re), 3(mi), 4(fa), 5(sol), 6(la), 7(si), 0(休止符)\n前缀：调整音高，+升高八度，-降低八度（可叠加，如++5）\n后缀：\n用于调整单个音的时值\n_：减时线（每增加一个，时值减半）\n-：增时线（每增加一个，时值加倍）\n.：附点（时值增加50%，最多两个）\n~：延音线（连接相同音高的连续音符使之合并）\n速度设置：t=x;（x拍/分钟，默认60），此值为BPM值，简谱一般会提供，不提供的也有参考信息进行查询，一些专业软件也提供检测功能","自行编译方式#自行编译方式":"法一：运行根目录下的build.bat文件，该文件会在release目录下生成两个可执行文件，分别是64位和32位，前者需要安装有g++，后者需要安装有i686-w64-mingw32-g++，如果没有前者，编译不进行，没有后者，则只编译64位版本 法二：运行MakeExe.bat，生成调试版 法三：使用编辑器打开build.bat，把不想要的位数版本删掉（在文档下方，已用注释分割出）","软件操作#软件操作":"初始输出如下：\n===============================================\rC++ 简谱转Beep播放器 (增强版)\r===============================================\r当前曲谱: t=120; 1 2 3 4 5 6 7 #1 +1\r音符解析结果:\r=============================================\r记谱 频率(Hz) 时长(ms) 类型\r------------------------------------------\r1 261 500 音符\r2 293 500 音符\r3 329 500 音符\r4 349 500 音符\r5 392 500 音符\r6 440 500 音符\r7 493 500 音符\r#1 277 500 音符 (升半音)\r+1 523 500 音符\r=============================================\r控制选项:\r[P] 播放音乐 [H] 帮助文本\r[I] 自定义曲谱 [Q] 退出程序\r请选择: 其中\n按下P，播放当前乐谱 按下H，可查看帮助文本 按下I，可输入自定义曲谱 按下Q，退出软件 按下I后，如果是误触，可以输入return（大小写不敏感）来退出录入状态，原本的曲谱可以保留\n软件初次启动时会注册Ctrl+Alt+Shift+S的热键，乐曲播放时可使用此热键停止\n默认设置下，按下P会看到这样的输出：\n请选择: 播放中... (按任意键停止) Play: 1 =\u003e Freq: 261 Hz, Duration: 500ms Play: 2 =\u003e Freq: 293 Hz, Duration: 500ms Play: 3 =\u003e Freq: 329 Hz, Duration: 500ms Play: 4 =\u003e Freq: 349 Hz, Duration: 500ms Play: 5 =\u003e Freq: 392 Hz, Duration: 500ms Play: 6 =\u003e Freq: 440 Hz, Duration: 500ms Play: 7 =\u003e Freq: 493 Hz, Duration: 500ms Play: #1 =\u003e Freq: 277 Hz, Duration: 500ms Play: +1 =\u003e Freq: 523 Hz, Duration: 500ms 按任意键以继续... play表示发出声响的音符，后面跟着音符的原文是便于查找，Freq标记声音频率，Duration标记持续时间\n特殊的，如下\n0\rRest: 0 =\u003e Duration: 1000ms 对于休止符，输出Rest，Freq参数会被省略"},"title":"_index.en"},"/en/docs/beepmusic/%E5%BD%A9%E8%89%B2%E8%BE%93%E5%87%BA/":{"data":{"1标准方案原生cout#1.标准方案（原生cout）":"1.标准方案（原生cout）使用\\033[开头m结尾，中间包裹参数\n属性代码 功能 属性代码 功能 属性代码 功能 0 重置所有属性 30 黑色 40 黑色 1 高亮/加粗 31 红色 41 红色 2 暗淡 32 绿色 42 绿色 4 下划线 33 黄色 43 黄色 5 闪烁 34 蓝色 44 蓝色 7 反转 35 品红 45 品红 8 隐藏 36 青色 46 青色","2y_print#2.y_print":"256色输出的简化包装，项目中未采用此方案，在function.cpp中予以保留，可以在其他改版中使用但不建议PR中包含此内容（虽然我知道根本不会有人给这个项目交PR🤓）\ny_print(“hello”,10); 0 = 黑色 8 = 灰色 1 = 蓝色 9 = 淡蓝色 2 = 绿色 10 = 淡绿色 3 = 浅绿色 11 = 淡浅绿色 4 = 红色 12 = 淡红色 5 = 紫色 13 = 淡紫色 6 = 黄色 14 = 淡黄色 7 = 白色 15 = 亮白色"},"title":"彩色输出.en"},"/en/docs/beepmusic/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/":{"data":{"ini结构说明#ini结构说明":"还没写","项目结构介绍#项目结构介绍":"项目结构介绍结构与文件功能\nroot/ ├── .vscode/ vscode配置文件 │ ├── setting.json │ └── tasks.json ├── head/ │ ├── function.h 封装部分常用的函数（的声明部分） │ └── mainhead.h 头文件（提供大部分cpp）+函数声明（提供main.cpp） ├── HELPS/ │ ├── Color_Print.md 彩色输出帮助 │ ├── Hot_Key.md 热键帮助 │ ├── RC_help.md resources.rc文件的一些帮助内容 │ └── README.md 项目介绍 ├── Icons/ │ ├── favicon.ico 同上级目录的icon.ico，仅名称不同 │ ├── ori.jpg 软件图标原图 │ └── result.png 软件图标透明图 ├── release/ 编译结果（使用build.bat的） │ ├── installer/ 用于放置安装包相关内容 │ │ ├── install_win_64.exe 安装包（编译结果） │ │ └── installer_creator.iss 源码（模板） │ ├── BeepMusic_release_win_x64.exe │ └── BeepMusic_release_win_x86.exe ├── src_c/ │ ├── config.cpp 配置文件读写 │ ├── function.cpp 封装功能函数的定义，简化开发（如彩色输出） │ ├── mods.cpp 菜单栏选项对应激活的函数 │ ├── play_core.cpp 存放核心解析、演奏函数 │ ├── test.cpp 测试文件（保留做纪念也可随时启用进行测试） │ └── UI.cpp UI显示（其实就是输出看起来像是UI的东西） ├── tools/ │ └── XD开发工具-T1 │ ├── 开发工具.exe 热键查询+鼠标查询工具（之前用易语言写的小玩意） │ ├── 源码.e 程序源码，遵守本仓库协议开源 │ ├── iext.fnr 支持库文件 │ └── krnln.fnr 支持库文件 ├── 备忘.txt 更新备忘录，记录需要的功能等 ├── BeepMusic_alpha.exe 开发调试版本的编译结果 ├── build.bat 编译最终版本用的批处理，该批处理会同时编译resources.rc ├── icon.ico 软件图标 ├── LICENSE 开源协议 ├── main.cpp 主函数放置的文件，编译在此处进行 ├── MakeExe.bat 生成调试版用的批处理，不使用VScode的开发者可以借此编译 ├── README.md 本项目的readme └── resources.rc 资源文件，放置图标信息、软件信息"},"title":"文件结构.en"},"/en/docs/beepmusic/%E7%83%AD%E9%94%AE%E6%B3%A8%E5%86%8C/":{"data":{"热键注册帮助#热键注册帮助":"热键注册帮助微软键代码查询：Virtual-Key 代码\n键代码查询工具：本地路径./tools/XD开发工具-T1，仅支持10进制查询"},"title":"热键注册.en"},"/en/docs/beepmusic/rc%E6%96%87%E4%BB%B6%E5%B8%AE%E5%8A%A9/":{"data":{"":"在 Windows 资源文件 (.rc) 中，这些关键字用于定义可执行文件的版本信息结构，以下是详细解释：","信息块解析#信息块解析":"BLOCK \"StringFileInfo\"\n作用：包含所有语言特定的字符串信息 结构： BLOCK \"StringFileInfo\"\rBEGIN\rBLOCK \"\" // 如 \"040904B0\"\rBEGIN\rVALUE \"Key\", \"Value\" // 实际显示的版本信息\rEND\rEND BLOCK \"VarFileInfo\"\n作用：定义文件的翻译信息（语言和代码页） 结构： BLOCK \"VarFileInfo\"\rBEGIN\rVALUE \"Translation\", , END 示例：VALUE \"Translation\", 0x0804, 1200 表示简体中文 Unicode","关键概念说明#关键概念说明":"部分 功能 典型值 文件属性区 定义二进制特性 FILEFLAGSMASK 有效标志位掩码 VS_FFI_FILEFLAGSMASK FILEFLAGS 实际版本标志 0x0L (正式版) FILEOS 目标操作系统 VOS_NT_WINDOWS32 FILETYPE 文件类型 VFT_APP (应用程序) FILESUBTYPE 文件子类型 VFT2_UNKNOWN 字符串信息区 用户可见信息 StringFileInfo 多语言字符串容器 语言标识 “080404B0” (简体中文) 变量信息区 语言配置 VarFileInfo 语言定义容器 Translation 默认语言设置 0x0804, 1200","工作流程#工作流程":"系统先读取 VarFileInfo 确定默认语言 在 StringFileInfo 中查找匹配的 LangID+CodePage 块 显示对应语言的字符串信息 文件属性区 (FILEOS等) 提供系统级元数据 ⚠️ 注意：当修改语言时，必须同步更新：\nStringFileInfo 中的语言块 ID (如 080404B0) VarFileInfo 中的 Translation 值 实际字符串内容（如需本地化） Windows 资源文件(.rc文件) 关于资源文件","核心结构解析#核心结构解析":"FILEFLAGSMASK\n作用：指定哪些位在 FILEFLAGS 字段中是有效的 值：通常设置为 VS_FFI_FILEFLAGSMASK（预定义值 0x3FL） 含义：表示只检查 FILEFLAGS 的低 6 位 FILEFLAGS\n作用：描述文件属性标志 常用值： 0x0L：正式版 VS_FF_DEBUG (0x1L)：调试版本 VS_FF_PRERELEASE (0x2L)：预发布版 VS_FF_PATCHED (0x4L)：已修补版本 VS_FF_PRIVATEBUILD (0x8L)：私有构建 示例：0x0L 表示标准发布版本 FILEOS\n作用：指定文件支持的操作系统 常用值： VOS_NT_WINDOWS32：Windows NT 32 位系统 VOS__WINDOWS32：通用 Windows 32 位 VOS_DOS_WINDOWS16：Windows 3.x 16 位 FILETYPE\n作用：定义文件类型 常用值： VFT_APP：应用程序 (EXE) VFT_DLL：动态链接库 VFT_DRV：设备驱动 VFT_FONT：字体文件 VFT_VXD：虚拟设备驱动 FILESUBTYPE\n作用：当 FILETYPE 需要细分时指定子类型 对 VFT_APP：必须设为 VFT2_UNKNOWN（无子类型） 对 VFT_DRV：可指定打印机/键盘等子类型 对 VFT_FONT：可指定矢量/位图字体"},"title":"rc文件帮助"},"/en/docs/dcc-script/":{"data":{"":"DCC是一款简单的编程语言，语法上是仿照汇编设计的，所以你甚至可以通过汇编模块将纯汇编代码引入你的程序\n设计理念上讲，DCC不仅学习了汇编的风格，还吸收了C++与易语言的部分思想，如面向对象编程、中文编程、多态等等，调和了高级语言和低级语言的差异，为各种编程问题提供了独特的解决方案\n实际上，DCC是为了简化纯文字游戏开发而制作的，因此，其官方库尤为适合制作纯文字游戏，尤其是利用控制台的纯文字游戏\n基础语法\r高级语法"},"title":"DCC script"},"/en/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/":{"data":{"":"下面将介绍DCC的基本语法和思想，使用基础语法，你几乎可以使用DCC的所有功能来编写纯DCC程序，可以编写出简单的控制台程序、模块文件\n函数调用\r特殊函数\r数据类型\r敏感性\r常量\r数值/逻辑运算符\r注释\r优先级\r缩进"},"title":"基础语法"},"/en/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E4%BC%98%E5%85%88%E7%BA%A7/":{"data":{"":"DCC改变符号优先级，对于函数调用，在一个参数的位置，可以使用（）或()包裹一个语句，这个语句的执行结果会成为这个参数位的值，括号的包裹内，一定是函数名+参数（参数可空）的形式\n例子：\n；普通语句\r输出 “1”\r；嵌套语句\r输出 （转到文本 (取整 3-2)）"},"title":"改变优先级"},"/en/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/":{"data":{"":"DCC程序的骨架就是函数，纯DCC程序不含缩进，因此函数名会整齐的排列在左侧\n程序中，标准的函数调用是这样写的：\n函数名 [参数1][,参数2][,参数3][,......] 参数是可省略的，但针对指定个参数的函数，对应数目的逗号需要要保留，下面列出来的几个语句都是合法的：\n输出 ,\r输出 \"你好\",\r输出 \"你好\",1 函数名支持使用一切Unicode字符定义，因此可以包含多种语言"},"title":"函数调用"},"/en/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E5%B8%B8%E9%87%8F/":{"data":{"":"DCC拥有系统常量和自定义常量，使用时需使用#进行表达，如下面的示例：\n#asm\r#iostream\r#cpp\r#换行符\r#逻辑型 实际使用效果：\n定义变量 #大数,20"},"title":"常量"},"/en/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%8F%E6%84%9F%E6%80%A7/":{"data":{"":"DCC对大小写敏感但对符号不敏感，例如，Get和GET对于DCC而言是两个函数，但[]和【】甚至【]对于DCC是同一个符号，下面以引号为例：\n；合法的引号：\r“你好”\r\"你好\"\r“你好\"\r\"你好”\r”你好“\r“你好“\r”你好”\r”你好\"\r\"你好“"},"title":"敏感性"},"/en/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%95%B0%E5%80%BC%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/":{"data":{"":"DCC支持运算符号如下：\n*\r×\r/\r÷\r%\r+\r-\r！\r!\r\u0026\r^\r\u0026\u0026\r||\r^^\r**\r~\r\u003e\u003e\r\u003c\u003c\r|\rand\ror\rnot\r且\r或\r非"},"title":"数值/逻辑运算符"},"/en/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%B3%A8%E9%87%8A/":{"data":{"":"DCC使用全角或半角的分号来书写注释，如下：\n；注释\r;注释 出现这种注释标记，从标记后面一直到这一行的结束都是注释内容，内容不会生效也不会编译进程序\n有时，为了灵活的嵌套，DCC还会支持收尾包裹式的注释，使用@或/**/标记首尾，从第一个标记到下一个标记之间的内容都是注释，@符号（仅限@）在文本常量中出现不会被视为注释的标记\n“这是文本@这还是文本”@这里是注释@\"这里不是注释\"\r“你好，@这里是文本，不会成为注释@，你好”\r输出@注释@ （转到文本 3@这也是注释@）\r/*这种注释和C语言的性质相同*/ 上面这两种注释是支持多行的"},"title":"注释"},"/en/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/":{"data":{"":"DCC拥有一些特殊函数会特殊高亮，这些函数在编译中会被特殊处理，也是DCC的功能核心，这些功能即使不引入库也可以照常使用，而这些函数名也就成为了DCC的保留字，不允许其他任何库用作函数名\n函数名 类型 功能 如果 流程控制 判断参数是真还是假 如果结束 流程控制 标志如果彻底结束 否则 流程控制 如果的参数为假进入该分支 if 流程控制 同上“如果”，下面的英文中文都是对应的，不再做解释 else 流程控制 --- endif 流程控制 --- 计次循环 流程控制 循环开始，指定循环次数并给出变量记录 记次循环尾 流程控制 标记计次循环结束 跳出循环 流程控制 跳出当前循环，代码跳转到循环尾后 到循环尾 流程控制 到达循环尾前，进入下一次循环或者完成循环 条件循环 流程控制 根据条件决定是否循环 for 流程控制 --- endfor 流程控制 --- break 流程控制 --- continue 流程控制 --- while 流程控制 --- 定义函数 函数操作 定义一个函数 结束函数定义 函数操作 完成函数定义 def 函数操作 --- enddef 函数操作 --- 创建板块 作用域 创建一个板块，独立于整个文件 结束创建板块 作用域 结束板块的创建，示意内容全部写完 creatd 作用域 --- endcd 作用域 --- 包裹体 作用域 暂定的功能，实际功效待定 包裹体尾 作用域 暂定的功能，实际功效待定 block 作用域 --- endblock 作用域 ---"},"title":"特殊函数"},"/en/docs/dcc-script/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E7%BC%A9%E8%BF%9B/":{"data":{"":"DCC借助缩进理解语义\n对于纯DCC代码，不会存在缩进，缩进只在嵌套中存在（见下一节）\n下面是存DCC代码示例：\n打开剧情\r如果 （转为文本 （输入））=10\r输出 \"ciallo\"\r如果结束\r展示剧情 10"},"title":"缩进"},"/en/docs/dcc-script/2.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/":{"data":{"":"DCC拥有一些高级语法，这些语法会使得DCC拥有更强的互联能力，变得高度可扩展"},"title":"高级语法"},"/en/moments/":{"data":{"":"Note\nThis page uses AI technology for translation. The content is for reference only.\nSome daily updates. Since I don’t want to constantly post on Moments and bother my friends, I’ll share them here instead. The website’s comment feature is now set up, so feel free to leave comments"},"title":"Moments"}}