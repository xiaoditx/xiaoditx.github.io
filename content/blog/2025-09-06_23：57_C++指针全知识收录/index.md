---
title: "C/C++指针种类+常见错误+组合技巧，挑战写出全网最全指针文章"
draft: false  # 是否为草稿。设为 false 才会发布
description: "要说C/C++中什么东西最烦人，那肯定是指针了，各种概念绕来绕去非常烦人，本文就是为了方便随时查阅写出的偏收录性的文章"
tags: ["C", "C++", "指针"]  # 文章标签，用于分类和关联
categories: ["编程基本功"]  # 文章分类
date: 2025-09-07
comments: true
authors:
  - name: xiaoditx
    link: https://github.com/xiaoditx
    image: https://github.com/xiaoditx.png
---

学习C/C++时，常常会遇到一个很烦人的东西：**指针**，说实话，指针在很多人入门C/C++时都是属于噩梦级的，它牵涉了庞大的知识体系，容易出现各种未定义行为，因此被称为C/C++中的最难知识点，那么这篇文章，就让我们好好聊一聊，这个BOSS级的指针。

## 一.汇编层面的指针理解

### 1.程序与内存

不管你使用什么语言，只要它最后生成了可执行程序，在运行时都是被分为四部分读入内存的，在内存中，分别是：

- **代码段**：程序编译出的机器码逐行存放在代码段

- **数据段**：静态变量、全局变量等生命周期跨越整个程序的数据存放的位置

- **堆栈段**：又分为堆段和栈段，堆段放置动态的变量，栈段存放上下文信息（函数的局部变量、调用时的参数、返回地址）

从上面可以看出，我们在开发中使用到的**变量**实际上都是写入了内存的，因此理论上我们可以通过修改内存来修改变量

### 2.内存地址、变量地址

内存是一小块一小块存储单元线性排列组成的的，因此我们可以为内存的每一块都依次标上序号，这样的序号我们称之为内存地址，内存地址相当于内存每一个单元的身份证号，**对于一块内存，有且只有一个内存地址与之对应**，以此，我们可以很方便的利用内存地址**描述、操作**内存中的区块。

[上面](#1程序与内存)讲过，高级语言编写的程序运行时变量都是写在内存之中的，因此我们可以使用内存地址来描述一个变量的起始位置，在这种情况下，变量对应的内存地址就称为变量地址。

我们看下面的例子：

```cpp
int a;
a = 10;
```

对于编译器，你定义了一个变量，并且在之后赋值为了10，那么它转换后的机器语言代码大致如下：

1. 找连续的空内存，累计大小正好是一个`int`型的大小

2. 将`10`的二进制值写入内存，假内存长度大于数字长度，则数字前面的部分全部为0

也就是说变量名在高级语言中属于**标识符**，相对于汇编使用内存地址，你可以更方便的在开发中明白某个内容的用意是什么，但它的本质还是内存操作，只是操作内存的部分由编译器帮你编写了。

### 3.汇编与内存

汇编中（起码在intel汇编中）使用`[]`标记地址，汇编编译器在看到这个符号时，就会将里面的内容理解为地址，然后读取内容后参与操作，比如`MOV EAX,[EBX]`指令的作用，就是到EBX寄存器（一种高速但很小的存储器，位价很高）存储的内存地址值对应的内存中取出数据然后移动到EAX寄存器，此例中，EAX存储数据，EBX存储地址，EBX存储的地址对应的内存存储数据。

实际上，汇编语言更多时候使用诸如`MOV EAX,BYTE[EBX]`的格式，`BYTE`近似于高级语言中的数据格式，约定了<strong>"这个地址指向的数据有多长"</strong>

### 3.C/C++的内存操作

作为现代最贴近硬件的高级语言，C/C++自然保存了内存操作，这也就是我们要讲的**指针**。

指针在本质上讲是变量，只不过存储的是地址，因此是一类特殊的变量，指针变量的数据类型可以说是“某类型指针”，比如“整数指针”就是指向整数的指针。类比[汇编的内存操作](#3汇编与内存)中的内容，变量类似于寄存器，可以存储各种数据，此时我们单独拿出一个寄存器，使其只存储地址，这个寄存器就是指针。

指针**提供了灵活操作内存的可能**，扩展了C/C++的能力，同时也可以用于节约复制传址造成的大开销，如果你对指针有所了解，你甚至会发现它允许你将一个有你自定义的数据类型交给已经写好的函数进行传递（我是指Win32的窗口状态信息）

我们将在下面细致讨论他。

## 二.C/C++指针基础

### 1.指针的基本定义格式

C/C++的指针本质就是变量，因此也和变量遵循近似的定义方式，下面是基本模板：

```cpp
<type> * <name>;
```

其中，`<type>`填充指针**所指向的数据的数据类型**，`<name>`填充这个指针的名称（类似于变量名，可以自己在规则内随便起名）；`*`是C/C++的特殊符号，有很多重意义，在这里用于标注紧跟的标识符是指针。

下面的内容定义了一个整数型指针：

```cpp
int *ptr; // 这里是无初始值的，所以不指向任何内容
```

### 2.星号的位置

需要注意的是，指针的定义有一个坑，就是`*`的位置，有时它在不同位置是同样的效果，但是阅读起来却会给人两种感觉，错用可能会导致阅读者对代码产生误解。

```cpp
// 下面两种都是正确的
int *ptr1;    // 星号紧跟标识符
int* ptr2;    // 星号紧跟数据类型
```

对于指针的定义，C/C++不关心数据类型、`*`、标识符中间的空格，因此上面的两种间隔方式都是对的，但是普遍来讲在开发中更推荐第一种，因为第二种写法容易给人一种错觉：`ptr2`的数据类型是`int*`，这在单个指针的定义中还看不出什么，但是如果多写几个，情况就不一样了，前面我们说到过，`*`算是一种**特殊符号**，它只作用于**紧跟的标识符**，所以之后出现的被分隔的标识符**不会被作用到！**

我们来看例子：

```cpp
int* ptr1,ptr2,ptr3,*ptr4;
```

此时，`ptr1`、`ptr4`是指针，另外两个则是普通变量，`*`并没有作用于2、3，想要定义的全部都是指针变量，则需要：

```cpp
int *ptr1,*ptr2,*ptr3,*ptr4;
```

在项目开发中，建议避免`int* ptr;`的使用，这样能够有效的防止误解的产生，当然你也可以选择讲所有指针的定义放到普通变量之后，，如果你翻看`windows.h`就会发现很多数据类型的定义都是这种顺序（其实也许不止这个头，但我只看过这个头）

### 3.指针的初始化

普通变量可以初始化，指针变量当然也可以初始化，指针变量的初始化如下：

```cpp
// 我们这里先介绍借助已有变量的初始化，其他方式之后再讲
int var;            // 先要有一个int变量 
int *ptr = &var;    // 借助已有变量初始化
```

上述代码出现了`&`符号，这个符号跟在标识符前方时是取地址的意思，可以获取变量、函数等内容在内存中的地址。

指针变量一般直接使用`=`进行初始化，将右侧内容写入指针变量，也就是说，右侧的初始值应当是内存地址。

### 4.使用指针

使用指针时，`*`又有了新的含义，当其紧跟着已经定义过的标识符时，`*`就是**解引用**符号，与汇编`[]`发挥相同效用，操作被解引用的地址就可以理解为在直接操作地址对应的内存：

```cpp
*ptr = 20
```

指针很大一部分难点就是要需要区分`ptr`和`*ptr`，前面我们讲过，指针变量就相当于汇编里存了数据的寄存器，因此我们可以修改指针变量的内容，这会调整其指向；我们也可以修改指针变量指向内容的值。

下面是C++的例子，大家可以自己复制下来放到编译器里运行试试：

```cpp
#include<iostream>
int main(){
    int var = 10;    // 普通变量
    int *ptr = &var;    // 初始化ptr指向var
    std::cout<<&var<<" "<<ptr<<" "<<(*ptr)<<" "<<var<<std::endl;
    *ptr++;
    std::cout<<&var<<" "<<ptr<<" "<<(*ptr)<<" "<<var<<std::endl;
    return 0;
}
```

可以很明显的看出，指针变量的单独使用，其内容是地址，与对应的变量取地址的结果相同；指针解引用后的内容是真正的数据，也就是对应变量的内容

> [!note]
> 上面的代码中`(*ptr)`使用括号来改变符号优先级，其实完全没必要，但我不知道当时看的哪个指针教程教了一个优先级，导致我现在会在任何我觉得必要的地方加括号

### 5.引用

C++提供了一种C语言没有的形式叫引用，它与指针相似，都是基于地址操作的，所以我们放在一起讲。

一个变量具有以下属性：

- 变量地址：变量的起始位置

- 数据类型：变量的长度、编码等信息

- 修饰信息：决定变量以什么形态存在

- 生命周期等等....

对于指针变量，他存储了某个地址，同时它也有自己的地址，也就是我们在借助一个变量访问一个内存，指针正如它的名字那样，它就是一个路标

引用则与之不同，引用本身可以理解为普通变量，只是不会在定义时寻找空的内存，而是直接把自己的地址信息改成别的变量的，你可以理解为内存是一间小屋，变量是允许你进入的门，引用就是再开一个门：

```cpp
int a;        // 一个变量a
int &b = a;    // 一个引用b
b=20;
a=10;
```

上面就是引用的写法了，此时我们直接改a，a和b的值同时变化，因为它们本质上对应的同一块内存，只是取了个别名而已。

### 6.多级指针

指针是可以指向指针的，像这样：

```cpp
int *ptr;
int **ptr2=&ptr;
```

如果想通过`ptr2`访问到`ptr`指向的内存，就需要写`*(*ptr2)`，这样的嵌套理论上可以无限地进行，但是实际上你在应用中用到三级以上的指针就很罕见了

## 三.动态内存分配

你可能会问：指针一定需要指向已经有的变量吗？答案是：没必要。

上面使用已有变量取地址初始化讲解只是为了方便讲解，指针真正的大用途是动态内存分配，也就是灵活的、直接的申请内存、操作内存，标准店的定义是：

> 动态内存分配是指在程序运行时根据需要分配和释放内存，而不是在编译时确定内存大小

C++和C的实现是不一样的，我们分开讲

### 1.C语言实现

C语言有这样几个函数：`malloc`、`calloc`、`realloc`、`free`，定义在 `<stdlib.h>` 头文件中，负责完成动态内存分配的工作

#### 1.1. malloc (Memory Allocation)

`malloc`函数允许你申请指定长度的内存，常见的使用模板如下：

```cpp
<type>* <ptr_name> = (<type>*) malloc(<size>)
```

其中，等号左侧内容是指针的定义，用来保存申请到的内存信息（也就是起始地址），等号右侧的`(<type>*)`是在转换数据类型，因为malloc返回的是`void*`型的也就是说没有数据类型[泛型指针](#5泛型指针)，我们需要告诉编译器我们申请的内存里面存了什么

malloc只要一个参数，那就是申请多大的内存，我们直接使用`sizeof`函数即可，申请内存存放n个typeA型数据就申请`n*sizeof(typeA)`长度的内存

下面是使用示例

```cpp
int *arr = (int *)malloc(5 * sizeof(int)); // 分配5个整数大小的内存
```

> [!note]
> 
> malloc函数返回值可能为NULL，发生在申请失败时，大项目中要对此做错误处理；malloc申请到的内容都不初始化，可能包含垃圾数据，一定要手动初始化

#### 1.2. calloc (Contiguous Allocation)

`calloc`与`malloc`类似，这个函数的语法如下：

```cpp
void* calloc(size_t num, size_t size);
```

`calloc`的一个好处是分为了数量和单个大小两部分，不需要你自己计算了，定一个好处就是它的特性：会初始化内存所有字节为`0`

下面是例子：

```cpp
int *arr = (int *)calloc(5, sizeof(int)); // 分配并初始化5个整数大小的内存
```

#### 1.3. realloc (Reallocate Memory)

`realloc`函数可以用于调整已分配内存块的大小，当新大小＞原大小时，新增部分未初始化；当其＜原大小时，多余部分被释放，语法如下：

```cpp
void* realloc(void* ptr, size_t new_size);
```

用例如下：

```cpp
arr = (int *)realloc(arr, 5 * sizeof(int)); // 扩展到5个整数大小
```

### 1.4. free (Free Memory)

`free`函数用于释放通过 `malloc`、`calloc` 或 `realloc` 分配的内存,语法如下

```cpp
void free(void* ptr);
```

这样做，是为了节约系统资源，否则会出现[内存泄漏](#1内存泄漏)

> [!note]
> 
> 内存在使用Free释放后，指针仍然会存在，但不再指向有效内存，此时就成为了[悬空指针](#2%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88)，建议将其置为 `NULL`。

> [!warning]
> 
> 重复释放同一块内存；释放某块内存后继续访问该内存

### 2.C++的实现

C++的动态内存分配使用`new`和`delete`实现，相对于C语言，C++的分配更为简单

#### 2.1.new

`new`是C++的一个关键字，负责开辟一块连续的内存空间存放指定类型的数据，不同于C语言版本需要自己计算内存大小、自行数据转换，C++的`new`会直接指定申请的内存的数据类型，它的基本写法是这样的：

```cpp
new type;
```

如果new出来的内存不是直接使用的（比如使用构造函数初始化[智能指针](#1智能指针)），我们就需要一个指针来存储，写法大致是这样：

```cpp
type *name = new type;
```

我们可以写一个申请单个`int`变量长度的内存的程序试试手

```cpp
int *ptr = new int;
```

我们不止可以使用`new`关键字开辟一个变量的长度的内存，也可以开辟可容纳多个变量的内存空间，如下：

```cpp
int *ptr = new int[5]
```

此时我们开辟了`5*sizeof(int)`大小的内存空间，`ptr`指针可以在`ptr`到`ptr+4`之间自由活动。

另外需要说明的是，我们可以在new时使用构造函数赋予内存初始值，比如我们可以写：`new int(10)`

#### 2.2.delete

和C一样的，在用完了申请的内存后，需要进行释放，以便告诉计算机对应的内存已经不会被用到了，好让计算机分配给别的东西，这就会用到`delete`。

`delete`很简单，直接就写成：

```cpp
delete ptr_name;
```

他会释放紧跟着的指针变量所指向的内存地址

当然，这种方式有一个局限，就是不能很好的释放诸如`new int[10]`申请的内存，因此就需要使用`delete[]`来与之对应：

```cpp
int *ptr = new int[10];
delete[] ptr;
```

注意`[]`中不需要填充任何内容

## 四.进阶的指针常见种类

讲完了指针的基础，我们可以看看常用的一些进阶概念了

### 1.智能指针

**动态内存分配**很容易搞出[内存泄漏](1内存泄漏)，C++提供了方便的方式也就是智能指针，它可以来避免这种危险（C语言没有智能指针，需要手动管理指针），智能指针会根据情况自动的释放内存

智能指针由`<memory>`提供，包括`shared_ptr`、`unique_ptr`和`weak_ptr`三种，他们有着不同的释放判断方式，但基本功能都差不多，我们之后将逐一讲解

#### 1.1.定义智能指针与初始化

智能指针的定义是这样的：

```cpp
std::ptr_type<type> ptr_name;
```

其中，`ptr_type`填上上面说的三种中的一种，`type`填数据类型，`ptr_name`填指针名，此时我们的指针是没有初始值的，我们还需要赋初始值才能使用

刚刚的内容改成：

```cpp
std::ptr_type<type> ptr_name(...);
```

这个是通过构造函数赋值的方法，比如：

```cpp
std::shared_ptr<int> ptr(new int);
```

这就是`new`了一块内存然后用于构建智能指针ptr，其初始值为`new int`的返回结果

假设你更喜欢看`=`的初始化，那当然也是可以的：

```cpp
auto ptr = make_shared<int>(20);
```

此时我们就得到了一个指向内容为20的内存的智能指针。

#### 1.2.unique_ptr

`std::unique_ptr`指向一个内存，当它移走或结束了生命周期时，也就是说不再指向那一块内存，对应的内存会自动`delete`，可以看下面的例子：

```cpp
{std::unique_ptr<int> ptr(new int(10));}
// ptr超出作用域被销毁，自动delete
```

对于一块内存，只会有一个`unique_ptr`指向它，因此只要这个指针不再指向这块内存，就自动销毁

#### 1.3.shared_ptr

与`unique_ptr`不同，`std::shared_ptr`允许多指针同时指向同一内存，因此它是计数销毁的指针，也就是当很多`shared_ptr`指向同一个内存，只有这些指针都不指向这块内存了（引用计数为0），它才会被销毁

#### 1.4.weak_ptr

在某种程度上，`std::weak_ptr`和`shared_ptr`其实差不多，只是它不参与引用计数，也就是说，当weak和shared同时指向一块内存，只要shared都不在指向该内存，无论weak是否还在指着，内存都会被销毁

------

## 下面的内容还没更完，稍等哦OvO

#### 1.5.转移所有权、放弃所有权

#### 1.6.释放资源

#### 1.7.获取原始指针

#### 1.8.shared特有操作

#### 1.9.weak特有操作

#### 1.10.自定义删除器

#### 1.11.一些坑

### 2.常量指针、指针常量

### 3.数组指针、指针数组

### 4.restric修饰符

### 5.泛型指针

### 6.函数指针

### 7.\_\_ptr32、\_\_ptr64

### 8.长指针

## 五.语法糖

## 六.指针有关的错误

### 1.内存泄漏

### 2.悬空指针

### 3.野指针

### 4.未初始化指针

### 5.空指针

## 七.写在最后

转发本文章到以下平台？

<div style="display: flex;justify-content: flex-start;align-items: center;gap: 10px;">

<a href="https://connect.qq.com/widget/shareqq/index.html?url=http://xiaoditx.github.io/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95&title=C/C++指针种类+常见错误+组合技巧，挑战写出全网最全指针文章&source=小狄同学呀&desc=指针是一个很让人头痛的东西，今天，就让我们一起去探究指针的使用与常见的那些问题&pics=http://xiaoditx.github.io/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/pic.png">
    <img src="https://cdn.simpleicons.org/qq/black?size=35" alt="QQ">
</a>

<a href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://xiaoditx.github.io/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/&title=C/C++指针种类+常见错误+组合技巧，挑战写出全网最全指针文章&desc=找到一篇很好的技术文章！&summary=指针想必是很多C/C++学习者的噩梦了，今天就让我写篇这样的文章，带着大家逐步探索指针吧！&site=http://xiaoditx.github.io/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/&pics=http://xiaoditx.github.io/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/pic.png">
    <img src="https://cdn.simpleicons.org/qzone/black?size=35" alt="QQ空间">
</a>

<a href="#" class="share-btn wechat" onclick="shareToWeChat()">
    <img src="https://cdn.simpleicons.org/wechat/black?size=35" alt="微信">
</a>

<a href="https://service.weibo.com/share/share.php?url=http://xiaoditx.github.io/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/#3%e6%8c%87%e9%92%88%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96&title=C/Cpp指针种类、常见错误、组合技巧&pic=http://xiaoditx.github.io/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/#3%e6%8c%87%e9%92%88%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96/pic.png">
    <img src="https://cdn.simpleicons.org/sinaweibo/black?size=35" alt="微博">
</a>

<a href="https://twitter.com/intent/tweet?text=C/Cpp指针种类、常见错误、组合技巧全解&url=http://xiaoditx.github.io/blog/2025-09-06_2357_c++%E6%8C%87%E9%92%88%E5%85%A8%E7%9F%A5%E8%AF%86%E6%94%B6%E5%BD%95/#3%e6%8c%87%e9%92%88%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96&via=xiaoditx">
    <img src="https://cdn.simpleicons.org/x/black?size=35" alt="Twitter">
</a>
</div>